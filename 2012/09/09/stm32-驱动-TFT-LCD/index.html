<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="LCD/LCM的基本概念&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;液晶显示器(Liquid Crystal Display: LCD)的构造是在两片平行的玻璃当中放置液态的晶体，两片玻璃中间有许多垂直和水平的细小电线，透过通电与否来控制杆状水晶分子改变方向，将光线折射出来产生画面。它包括了TFT,OLED,UFB,TFD,STN等类型的液晶显示屏. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;n">
<meta property="og:type" content="article">
<meta property="og:title" content="stm32 驱动 TFT LCD">
<meta property="og:url" content="http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/index.html">
<meta property="og:site_name" content="Neil Pan">
<meta property="og:description" content="LCD/LCM的基本概念&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;液晶显示器(Liquid Crystal Display: LCD)的构造是在两片平行的玻璃当中放置液态的晶体，两片玻璃中间有许多垂直和水平的细小电线，透过通电与否来控制杆状水晶分子改变方向，将光线折射出来产生画面。它包括了TFT,OLED,UFB,TFD,STN等类型的液晶显示屏. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;n">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://neil-pan.com/uploads/2012/09/4270516043.jpg">
<meta property="og:image" content="http://neil-pan.com/uploads/2012/09/2242973916.jpg">
<meta property="og:updated_time" content="2024-07-11T12:49:21.239Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="stm32 驱动 TFT LCD">
<meta name="twitter:description" content="LCD/LCM的基本概念&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;液晶显示器(Liquid Crystal Display: LCD)的构造是在两片平行的玻璃当中放置液态的晶体，两片玻璃中间有许多垂直和水平的细小电线，透过通电与否来控制杆状水晶分子改变方向，将光线折射出来产生画面。它包括了TFT,OLED,UFB,TFD,STN等类型的液晶显示屏. &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;n">
<meta name="twitter:image" content="http://neil-pan.com/uploads/2012/09/4270516043.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>stm32 驱动 TFT LCD</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/projects/">Projects</a></li>
         
          <li><a href="https://about.me/neilpan">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2012/09/11/stm32-驱动-触摸屏/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li>
        
        
        <li><a class="icon" href="/2012/08/25/stm32-Fatfs-读写SD卡/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&text=stm32 驱动 TFT LCD"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&is_video=false&description=stm32 驱动 TFT LCD"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=stm32 驱动 TFT LCD&body=Check out this article: http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&name=stm32 驱动 TFT LCD&description=&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;LCD/LCM的基本概念&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;液晶显示器(Liquid Crystal Display: LCD)的构造是在两片平行的玻璃当中放置液态的晶体，两片玻璃中间有许多垂直和水平的细小电线，透过通电与否来控制杆状水晶分子改变方向，将光线折射出来产生画面。它包括了TFT,OLED,UFB,TFD,STN等类型的液晶显示屏.&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LCM(LCD Module)即LCD显示模组、液晶模块，是指将液晶显示器件，连接件，控制与驱动等外围电路，PCB电路板，背光源，结构件等装配在一起的组件。 购买相应的LCD Module时，会提供相关驱动IC资料，很多会有驱动代码。不过价格会比单买 LCD显示屏贵很多。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;LCD显示模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LCD的接口有多种，分类很细。主要看LCD的驱动方式和控制方式，目前手机上的彩色LCD的连接方式一般有这么几种：MCU模式，RGB模式，SPI模式，VSYNC模式，MDDI模式，DSI模式。MCU模式（也写成MPU模式的）。只有TFT模块才有RGB接口。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;MCU模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为主要针对单片机的领域在使用,因此得名.后在中低端手机大量使用,其主要特点是价格便宜的。MCU-LCD接口的标准术语是Intel提出的8080总线标准，因此在很多文档中用I80 来指MCU-LCD屏。主要又可以分为8080模式和6800模式，这两者之间主要是时序的区别。数据位传输有8位，9位，16位，18位，24位。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;MCU接口标准名称是I80，管脚的控制脚有5个：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;CS 片选信号&lt;/div&gt;&lt;div&gt;RS (置1为写数据,置0为写命令）&lt;/div&gt;&lt;div&gt;/WR （为0表示写数据) 数据命令区分信号&lt;/div&gt;&lt;div&gt;/RD （为0表示读数据）&lt;/div&gt;&lt;div&gt;RESET 复位LCD（ 用固定命令系列 0 1 0来复位)&lt;/div&gt;&lt;div&gt;数据总线 &amp;nbsp;DATA (8~24位)&amp;nbsp;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;RGB模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大屏采用较多的模式，数据位传输也有6位，16位和18位，24位之分。连线一般有：VSYNC，HSYNC，DOTCLK，CS，RESET，有的也需要RS，剩下就是数据线。它的优缺点正好和MCU模式相反。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MCU-LCD屏它与RGB-LCD屏主要区别在于显存的位置。RGB-LCD的显存是由系统内存充当的，因此其大小只受限于系统内存的大小，这样RGB-LCD可以做出较大尺寸，象现在4.3”只能算入门级，而MID中7”,10”的屏都开始大量使用。而MCU-LCD的设计之初只要考虑单片机的内存较小，因此都是把显存内置在LCD模块内部.然后软件通过专门显示命令来更新显存，因此MCU屏往往不能做得很大。同时显示更新速度也比RGB-LCD慢。显示数据传输模式也有差别。RGB屏只需显存组织好数据。启动显示后，LCD-DMA会自动把显存中的数据通过RGB接口送到LCM。而MCU屏则需要发送画点的命令来修改MCU内部的RAM（即不能直接写MCU屏的RAM）。所以RGB显示速度明显比MCU快，而且播放视频方面，MCU-LCD也比较慢。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于RGB接口的LCM，主机输出的直接是每个象素的RGB数据，不需要进行变换（GAMMA校正等除外），对于这种接口，需要在主机部分有个LCD控制器，以产生RGB数据和点、行、帧同步信号。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;MCU接口和RGB接口主要的区别是：&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MCU接口方式：显示数据写入DDRAM，常用于静止图片显示。控制简单方便，无需时钟和同步信号。要耗费GRAM，所以难以做到大屏（QVGA以上）。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RGB接口方式：显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。&lt;/div&gt;"><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      
    </div>
  </span>
</div>

      <div class="content index width mx-auto px2 my4">
    
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        stm32 驱动 TFT LCD
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Neil Pan</span>
      </span>
      
    <div class="postdate">
        <time datetime="2012-09-09T05:03:29.000Z" itemprop="datePublished">2012-09-09</time>
    </div>


      

    </div>
  </header>
  


  <!-- Google Adsense -->
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-7002319867557344",
      enable_page_level_ads: true
    });
  </script> 

  <div class="content" itemprop="articleBody">
    <div> </div><div><strong>LCD/LCM的基本概念</strong></div><div>&nbsp;&nbsp;&nbsp;&nbsp;液晶显示器(Liquid Crystal Display: LCD)的构造是在两片平行的玻璃当中放置液态的晶体，两片玻璃中间有许多垂直和水平的细小电线，透过通电与否来控制杆状水晶分子改变方向，将光线折射出来产生画面。它包括了TFT,OLED,UFB,TFD,STN等类型的液晶显示屏.</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;LCM(LCD Module)即LCD显示模组、液晶模块，是指将液晶显示器件，连接件，控制与驱动等外围电路，PCB电路板，背光源，结构件等装配在一起的组件。 购买相应的LCD Module时，会提供相关驱动IC资料，很多会有驱动代码。不过价格会比单买 LCD显示屏贵很多。</div><div> </div><div><div><strong>LCD显示模式</strong></div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;LCD的接口有多种，分类很细。主要看LCD的驱动方式和控制方式，目前手机上的彩色LCD的连接方式一般有这么几种：MCU模式，RGB模式，SPI模式，VSYNC模式，MDDI模式，DSI模式。MCU模式（也写成MPU模式的）。只有TFT模块才有RGB接口。</div><div> </div><div>&nbsp; &nbsp;&nbsp;<strong>MCU模式</strong></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为主要针对单片机的领域在使用,因此得名.后在中低端手机大量使用,其主要特点是价格便宜的。MCU-LCD接口的标准术语是Intel提出的8080总线标准，因此在很多文档中用I80 来指MCU-LCD屏。主要又可以分为8080模式和6800模式，这两者之间主要是时序的区别。数据位传输有8位，9位，16位，18位，24位。</div><div> </div><div>MCU接口标准名称是I80，管脚的控制脚有5个：</div><div> </div><div>CS 片选信号</div><div>RS (置1为写数据,置0为写命令）</div><div>/WR （为0表示写数据) 数据命令区分信号</div><div>/RD （为0表示读数据）</div><div>RESET 复位LCD（ 用固定命令系列 0 1 0来复位)</div><div>数据总线 &nbsp;DATA (8~24位)&nbsp;</div><div> </div><div>&nbsp; &nbsp;&nbsp;<strong>RGB模式</strong></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大屏采用较多的模式，数据位传输也有6位，16位和18位，24位之分。连线一般有：VSYNC，HSYNC，DOTCLK，CS，RESET，有的也需要RS，剩下就是数据线。它的优缺点正好和MCU模式相反。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;MCU-LCD屏它与RGB-LCD屏主要区别在于显存的位置。RGB-LCD的显存是由系统内存充当的，因此其大小只受限于系统内存的大小，这样RGB-LCD可以做出较大尺寸，象现在4.3”只能算入门级，而MID中7”,10”的屏都开始大量使用。而MCU-LCD的设计之初只要考虑单片机的内存较小，因此都是把显存内置在LCD模块内部.然后软件通过专门显示命令来更新显存，因此MCU屏往往不能做得很大。同时显示更新速度也比RGB-LCD慢。显示数据传输模式也有差别。RGB屏只需显存组织好数据。启动显示后，LCD-DMA会自动把显存中的数据通过RGB接口送到LCM。而MCU屏则需要发送画点的命令来修改MCU内部的RAM（即不能直接写MCU屏的RAM）。所以RGB显示速度明显比MCU快，而且播放视频方面，MCU-LCD也比较慢。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;对于RGB接口的LCM，主机输出的直接是每个象素的RGB数据，不需要进行变换（GAMMA校正等除外），对于这种接口，需要在主机部分有个LCD控制器，以产生RGB数据和点、行、帧同步信号。</div><div> </div><div>&nbsp; &nbsp;&nbsp;<strong>MCU接口和RGB接口主要的区别是：</strong></div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MCU接口方式：显示数据写入DDRAM，常用于静止图片显示。控制简单方便，无需时钟和同步信号。要耗费GRAM，所以难以做到大屏（QVGA以上）。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; RGB接口方式：显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。</div>

<a id="more"></a>
<div> </div><div>&nbsp; &nbsp;&nbsp;<strong>VSYNC模式</strong></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该模式其实就是就是在MCU模式上加了一个VSYNC信号，应用于运动画面更新，这样就与上述两个接口有很大的区别。该模式支持直接进行动画显示的功能，它提供了一个对MCU接口最小的改动，实现动画显示的解决方案。</div><div> </div><div>其他还有 SPI模式 &nbsp;MDDI模式 &nbsp; DSI模式 采用较少 这里不一一介绍。</div><div> </div><div><div>&nbsp;&nbsp;&nbsp;&nbsp;显示屏的驱动IC采用Ili93xx 系列的居多，资料较多。我使用的是正点原子的开发板,显示屏驱动IC是xxxB505 ，不过驱动代码和ili9320类似，为i80接口。不过我一直有一个疑问，这块IC的具体位置在哪？ 显示屏由屏幕和排线构成，LCM上只有一块芯片 XPT2046是触摸屏的驱动IC？这样的问题Google也不会知道。。 拆开了一个废旧的显示屏，熟悉了一下显示屏的结构，询问了不少淘宝卖家后，总算弄明白了。这块芯片的封装和常见的芯片不同，以2cm<em>2mm左右的一块硅片封装在屏幕下和排线相连接。如图：</em></div><div> </div><div><img src="/uploads/2012/09/4270516043.jpg" alt="ili3920.jpg"></div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;这里对正点原子的相关代码进行了整理，<strong>使用库函数操作，并且整合和横竖屏的代码，实现横竖屏显示。</strong></div><div> </div><div>相关驱动代码如下:</div><div> </div><div>&nbsp; &nbsp; LCD/ili93xx.c&nbsp;</div><div><pre class="brush:cpp;">#include “ili93xx.h”<br>#include “font.h”<br><br>#define USE_HORIZONTAL  0 //定义是否使用横屏<br><br>//画笔颜色,背景颜色<br>u16 POINT_COLOR = 0x0000,BACK_COLOR = 0xFFFF;<br>u16 DeviceCode;<br><br>void LCD_Delay_Us(u32 us)<br>{<br>    u32 time=100us/7;<br>    while(–time);<br>}<br><br>//LCD延时函数 10MS<br>void LCD_Delay (u32 nCount)<br>{<br>    volatile int i;<br>    for (i=0;i&lt;nCount<em>100;i++);<br>}<br><br>//LCD_GPIO_DATA_PIN 模式设置<br>//u8 Mode :<br>//             1    推挽输出<br>//            0    上拉输出<br>void LCD_Data_Pin_Mode(u8 Mode){<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br><br>    GPIO_InitStructure.GPIO_Pin = LCD_GPIO_DATA_PIN;<br><br>    if(Mode == 1)<br>        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;      //推挽输出<br>    else<br>        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU ;        // 上拉输入<br><br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>    GPIO_Init(LCD_GPIO_DATA_PORT, &amp;GPIO_InitStructure);<br>}<br><br>//写寄存器函数<br>void LCD_WR_REG(u8 data)<br>{<br>    Clr_Rs;//写地址<br>    Clr_Cs;<br>    Write_Data(data);<br>    Clr_Wr;<br>    Set_Wr;<br>    Set_Cs;<br>}<br><br>//写寄存器<br>void LCD_WriteReg(u8 LCD_Reg, u16 LCD_RegValue)<br>{<br>    LCD_WR_REG(LCD_Reg);<br>    LCD_WR_DATA(LCD_RegValue);<br>}<br><br>//读寄存器<br>u16 LCD_ReadReg(u8 LCD_Reg)<br>{<br>    u16 t;<br>    LCD_WR_REG(LCD_Reg);   //写入要读的寄存器号<br><br>    LCD_Data_Pin_Mode(0);    //上拉模式<br><br>    Set_Rs;<br>    Clr_Cs;<br>                          //读取数据(读寄存器时,并不需要读2次)<br>    Clr_Rd;<br>    Set_Rd;<br>    t=Read_Data();<br>    Set_Cs;<br><br>    LCD_Data_Pin_Mode(1);    //推挽模式<br>    Write_Data(0xffff);<br>    return t;<br>}<br><br>//开始写GRAM<br>void LCD_WriteRAM_Prepare(void)<br>{<br>    LCD_WR_REG(R34);<br>}<br><br>//LCD写GRAM<br>void LCD_WriteRAM(u16 RGB_Code)<br>{<br>    LCD_WR_DATA(RGB_Code);//写十六位GRAM<br>}<br><br>//从ILI93xx读出的数据为GBR格式，而我们写入的时候为RGB格式。<br>//通过该函数转换<br>//c:GBR格式的颜色值<br>//返回值：RGB格式的颜色值<br>u16 LCD_BGR2RGB(u16 c)<br>{<br>    u16  r,g,b,rgb;<br>    b=(c&gt;&gt;0)&amp;0x1f;<br>    g=(c&gt;&gt;5)&amp;0x3f;<br>    r=(c&gt;&gt;11)&amp;0x1f;<br>    rgb=(b&lt;&lt;11)+(g&lt;&lt;5)+(r&lt;&lt;0);<br>    return(rgb);<br>}<br><br>//读取个某点的颜色值<br>//x:0~239<br>//y:0~319<br>//返回值:此点的颜色<br>u16 LCD_ReadPoint(u16 x,u16 y)<br>{<br>    u16 t;<br>    if(x&gt;=LCD_WIDTH||y&gt;=LCD_HEIGHT)return 0;//超过了范围,直接返回<br>    LCD_SetCursor(x,y);<br>    LCD_WR_REG(R34);       //选择GRAM地址<br><br>    LCD_Data_Pin_Mode(0);    //上拉模式<br><br>    Set_Rs;<br>    Clr_Cs;<br>    //读取数据(读GRAM时,需要读2次)<br>    Clr_Rd;<br>    Set_Rd;<br>    LCD_Delay_Us(2);<br>    //dummy READ<br>    Clr_Rd;<br>    LCD_Delay_Us(2);<br>    Set_Rd;<br><br>    t=Read_Data();<br>    Set_Cs;<br><br>    LCD_Data_Pin_Mode(1);    //推挽模式<br>    Write_Data(0xFFFF);<br><br>    if(DeviceCode==0X4531||DeviceCode==0X8989||DeviceCode==0XB505)<br>        return t;//4531驱动IC<br>    else<br>        return LCD_BGR2RGB(t);<br>}<br><br>//LCD开启显示<br>void LCD_DisplayOn(void)<br>{<br>    LCD_WriteReg(R7, 0x0173); //26万色显示开启<br>}<br><br>//LCD关闭显示<br>void LCD_DisplayOff(void)<br>{<br>    LCD_WriteReg(R7, 0x0);//关闭显示<br>}<br><br>//设置光标位置<br>//Xpos:横坐标<br>//Ypos:纵坐标<br>__inline void LCD_SetCursor(u8 Xpos, u16 Ypos)<br>{<br>    #if USE_HORIZONTAL<br>        LCD_WriteReg(R32, Ypos);<br>        LCD_WriteReg(R33, 319-Xpos);<br>    #else<br>        LCD_WriteReg(R32, Xpos);<br>        LCD_WriteReg(R33, Ypos);<br>    #endif<br>}<br><br>//画点<br>//x:0~239<br>//y:0~319<br>//POINT_COLOR:此点的颜色<br>void LCD_DrawPoint(u16 x,u16 y)<br>{<br>    LCD_SetCursor(x,y);//设置光标位置<br>    LCD_WR_REG(R34);//开始写入GRAM<br>    LCD_WR_DATA(POINT_COLOR);<br>}<br><br>//初始化lcd<br>void LCD_Config(void)<br>{<br>    /</em>Set_Cs;<br>    Set_Rs;<br>    Set_Wr;<br>    Set_Rd;     <em>/<br><br>    LCD_Delay(5); // LCD_Delay 50 ms<br>    LCD_WriteReg(0x0000,0x0001);<br>    LCD_Delay(5); // LCD_Delay 50 ms<br>    DeviceCode = LCD_ReadReg(0x0000);<br>    //printf(“ID:%d\n”,DeviceCode);<br><br>    if(DeviceCode==0x9325||DeviceCode==0x9328){            //ILI9325<br><br>        LCD_WriteReg(0x00e7,0x0010);<br>        LCD_WriteReg(0x0000,0x0001);//开启内部时钟<br>        LCD_WriteReg(0x0001,0x0100);<br>        LCD_WriteReg(0x0002,0x0700);//电源开启<br>        //LCD_WriteReg(0x0003,(1&lt;&lt;3)|(1&lt;&lt;4) );     //65K  RGB<br>        //DRIVE TABLE(寄存器 03H)<br>        //BIT3=AM BIT4:5=ID0:1<br>        //AM ID0 ID1   FUNCATION<br>        // 0  0   0       R-&gt;L D-&gt;U<br>        // 1  0   0       D-&gt;U    R-&gt;L<br>        // 0  1   0       L-&gt;R D-&gt;U<br>        // 1  1   0    D-&gt;U    L-&gt;R<br>        // 0  0   1       R-&gt;L U-&gt;D<br>        // 1  0   1    U-&gt;D    R-&gt;L<br>        // 0  1   1    L-&gt;R U-&gt;D 正常就用这个.<br>        // 1  1   1       U-&gt;D    L-&gt;R<br>        LCD_WriteReg(0x0003,(1&lt;&lt;12)|(3&lt;&lt;4)|(0&lt;&lt;3) );//65K<br>        LCD_WriteReg(0x0004,0x0000);<br>        LCD_WriteReg(0x0008,0x0207);<br>        LCD_WriteReg(0x0009,0x0000);<br>        LCD_WriteReg(0x000a,0x0000);//display setting<br>        LCD_WriteReg(0x000c,0x0001);//display setting<br>        LCD_WriteReg(0x000d,0x0000);//0f3c<br>        LCD_WriteReg(0x000f,0x0000);<br>        //电源配置<br>        LCD_WriteReg(0x0010,0x0000);<br>        LCD_WriteReg(0x0011,0x0007);<br>        LCD_WriteReg(0x0012,0x0000);<br>        LCD_WriteReg(0x0013,0x0000);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0010,0x1590);<br>        LCD_WriteReg(0x0011,0x0227);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0012,0x009c);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0013,0x1900);<br>        LCD_WriteReg(0x0029,0x0023);<br>        LCD_WriteReg(0x002b,0x000e);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0020,0x0000);<br>        LCD_WriteReg(0x0021,0x013f);<br>        LCD_Delay(5);<br>        //伽马校正<br>        LCD_WriteReg(0x0030,0x0007);<br>        LCD_WriteReg(0x0031,0x0707);<br>        LCD_WriteReg(0x0032,0x0006);<br>        LCD_WriteReg(0x0035,0x0704);<br>        LCD_WriteReg(0x0036,0x1f04);<br>        LCD_WriteReg(0x0037,0x0004);<br>        LCD_WriteReg(0x0038,0x0000);<br>        LCD_WriteReg(0x0039,0x0706);<br>        LCD_WriteReg(0x003c,0x0701);<br>        LCD_WriteReg(0x003d,0x000f);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0050,0x0000); //水平GRAM起始位置<br>        LCD_WriteReg(0x0051,(LCD_WIDTH-1)); //水平GRAM终止位置<br>        LCD_WriteReg(0x0052,0x0000); //垂直GRAM起始位置<br>        LCD_WriteReg(0x0053,(LCD_HEIGHT-1)); //垂直GRAM终止位置<br><br>        LCD_WriteReg(0x0060,0xa700);<br>        LCD_WriteReg(0x0061,0x0001);<br>        LCD_WriteReg(0x006a,0x0000);<br>        LCD_WriteReg(0x0080,0x0000);<br>        LCD_WriteReg(0x0081,0x0000);<br>        LCD_WriteReg(0x0082,0x0000);<br>        LCD_WriteReg(0x0083,0x0000);<br>        LCD_WriteReg(0x0084,0x0000);<br>        LCD_WriteReg(0x0085,0x0000);<br><br>        LCD_WriteReg(0x0090,0x0010);<br>        LCD_WriteReg(0x0092,0x0000);<br>        LCD_WriteReg(0x0093,0x0003);<br>        LCD_WriteReg(0x0095,0x0110);<br>        LCD_WriteReg(0x0097,0x0000);<br>        LCD_WriteReg(0x0098,0x0000);<br>        //开启显示设置<br>        LCD_WriteReg(0x0007,0x0133);<br>        LCD_WriteReg(0x0020,0x0000);<br>        LCD_WriteReg(0x0021,0x013f);<br><br>    }else if(DeviceCode==0x9320||DeviceCode==0x9300){<br><br>        LCD_WriteReg(0x00,0x0000);<br>        LCD_WriteReg(0x01,0x0100);    //Driver Output Contral.<br>        LCD_WriteReg(0x02,0x0700);    //LCD Driver Waveform Contral.<br>        LCD_WriteReg(0x03,0x1030);//Entry Mode Set.<br>        //LCD_WriteReg(0x03,0x1018);    //Entry Mode Set.<br><br>        LCD_WriteReg(0x04,0x0000);    //Scalling Contral.<br>        LCD_WriteReg(0x08,0x0202);    //Display Contral 2.(0x0207)<br>        LCD_WriteReg(0x09,0x0000);    //Display Contral 3.(0x0000)<br>        LCD_WriteReg(0x0a,0x0000);    //Frame Cycle Contal.(0x0000)<br>        LCD_WriteReg(0x0c,(1&lt;&lt;0));    //Extern Display Interface Contral 1.(0x0000)<br>        LCD_WriteReg(0x0d,0x0000);    //Frame Maker Position.<br>        LCD_WriteReg(0x0f,0x0000);    //Extern Display Interface Contral 2.<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x07,0x0101);    //Display Contral.<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x10,(1&lt;&lt;12)|(0&lt;&lt;8)|(1&lt;&lt;7)|(1&lt;&lt;6)|(0&lt;&lt;4));    //Power Control 1.(0x16b0)<br>        LCD_WriteReg(0x11,0x0007);                                //Power Control 2.(0x0001)<br>        LCD_WriteReg(0x12,(1&lt;&lt;8)|(1&lt;&lt;4)|(0&lt;&lt;0));                //Power Control 3.(0x0138)<br>        LCD_WriteReg(0x13,0x0b00);                                //Power Control 4.<br>        LCD_WriteReg(0x29,0x0000);                                //Power Control 7.<br><br>        LCD_WriteReg(0x2b,(1&lt;&lt;14)|(1&lt;&lt;4));<br>        LCD_WriteReg(0x50,0);    //Set X Star<br>        //水平GRAM终止位置Set X End.<br>        LCD_WriteReg(0x51,(LCD_WIDTH-1));    //Set Y Star<br>        LCD_WriteReg(0x52,0);    //Set Y End.t.<br>        LCD_WriteReg(0x53,(LCD_HEIGHT-1));    //<br><br>        LCD_WriteReg(0x60,0x2700);    //Driver Output Control.<br>        LCD_WriteReg(0x61,0x0001);    //Driver Output Control.<br>        LCD_WriteReg(0x6a,0x0000);    //Vertical Srcoll Control.<br><br>        LCD_WriteReg(0x80,0x0000);    //Display Position? Partial Display 1.<br>        LCD_WriteReg(0x81,0x0000);    //RAM Address Start? Partial Display 1.<br>        LCD_WriteReg(0x82,0x0000);    //RAM Address End-Partial Display 1.<br>        LCD_WriteReg(0x83,0x0000);    //Displsy Position? Partial Display 2.<br>        LCD_WriteReg(0x84,0x0000);    //RAM Address Start? Partial Display 2.<br>        LCD_WriteReg(0x85,0x0000);    //RAM Address End? Partial Display 2.<br><br>        LCD_WriteReg(0x90,(0&lt;&lt;7)|(16&lt;&lt;0));    //Frame Cycle Contral.(0x0013)<br>        LCD_WriteReg(0x92,0x0000);    //Panel Interface Contral 2.(0x0000)<br>        LCD_WriteReg(0x93,0x0001);    //Panel Interface Contral 3.<br>        LCD_WriteReg(0x95,0x0110);    //Frame Cycle Contral.(0x0110)<br>        LCD_WriteReg(0x97,(0&lt;&lt;8));    //<br>        LCD_WriteReg(0x98,0x0000);    //Frame Cycle Contral.<br>        LCD_WriteReg(0x07,0x0173);    //(0x0173)<br><br>    }else if(DeviceCode==0x1505){<br><br>        // second release on 3/5  ,luminance is acceptable,water wave appear during camera preview<br>        LCD_WriteReg(0x0007,0x0000);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0012,0x011C);//0x011A   why need to set several times?<br>        LCD_WriteReg(0x00A4,0x0001);//NVM<br>        LCD_WriteReg(0x0008,0x000F);<br>        LCD_WriteReg(0x000A,0x0008);<br>        LCD_WriteReg(0x000D,0x0008);<br>        //伽马校正<br>        LCD_WriteReg(0x0030,0x0707);<br>        LCD_WriteReg(0x0031,0x0007); //0x0707<br>        LCD_WriteReg(0x0032,0x0603);<br>        LCD_WriteReg(0x0033,0x0700);<br>        LCD_WriteReg(0x0034,0x0202);<br>        LCD_WriteReg(0x0035,0x0002); //?0x0606<br>        LCD_WriteReg(0x0036,0x1F0F);<br>        LCD_WriteReg(0x0037,0x0707); //0x0f0f  0x0105<br>        LCD_WriteReg(0x0038,0x0000);<br>        LCD_WriteReg(0x0039,0x0000);<br>        LCD_WriteReg(0x003A,0x0707);<br>        LCD_WriteReg(0x003B,0x0000); //0x0303<br>        LCD_WriteReg(0x003C,0x0007); //?0x0707<br>        LCD_WriteReg(0x003D,0x0000); //0x1313//0x1f08<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0007,0x0001);<br>        LCD_WriteReg(0x0017,0x0001);//开启电源<br>        LCD_Delay(5);<br>        //电源配置<br>        LCD_WriteReg(0x0010,0x17A0);<br>        LCD_WriteReg(0x0011,0x0217);//reference voltage VC[2:0]   Vciout = 1.00</em>Vcivl<br>        LCD_WriteReg(0x0012,0x011E);//0x011c  //Vreg1out = Vcilvl<em>1.80   is it the same as Vgama1out ?<br>        LCD_WriteReg(0x0013,0x0F00);//VDV[4:0]–&gt;VCOM Amplitude VcomL = VcomH - Vcom Ampl<br>        LCD_WriteReg(0x002A,0x0000);<br>        LCD_WriteReg(0x0029,0x000A);//0x0001F  Vcomh = VCM1[4:0]</em>Vreg1out    gate source voltage??<br>        LCD_WriteReg(0x0012,0x013E);// 0x013C  power supply on<br>        //Coordinates Control//<br>        LCD_WriteReg(0x0050,0x0000);//0x0e00<br>        LCD_WriteReg(0x0051,(LCD_WIDTH-1));<br>        LCD_WriteReg(0x0052,0x0000);<br>        LCD_WriteReg(0x0053,(LCD_HEIGHT-1));<br>        //Pannel Image Control//<br>        LCD_WriteReg(0x0060,0x2700);<br>        LCD_WriteReg(0x0061,0x0001);<br>        LCD_WriteReg(0x006A,0x0000);<br>        LCD_WriteReg(0x0080,0x0000);<br>        //Partial Image Control//<br>        LCD_WriteReg(0x0081,0x0000);<br>        LCD_WriteReg(0x0082,0x0000);<br>        LCD_WriteReg(0x0083,0x0000);<br>        LCD_WriteReg(0x0084,0x0000);<br>        LCD_WriteReg(0x0085,0x0000);<br>        //Panel Interface Control//<br>        LCD_WriteReg(0x0090,0x0013);//0x0010 frenqucy<br>        LCD_WriteReg(0x0092,0x0300);<br>        LCD_WriteReg(0x0093,0x0005);<br>        LCD_WriteReg(0x0095,0x0000);<br>        LCD_WriteReg(0x0097,0x0000);<br>        LCD_WriteReg(0x0098,0x0000);<br><br>        LCD_WriteReg(0x0001,0x0100);<br>        LCD_WriteReg(0x0002,0x0700);<br>        LCD_WriteReg(0x0003,0x1030);<br>        LCD_WriteReg(0x0004,0x0000);<br>        LCD_WriteReg(0x000C,0x0000);<br>        LCD_WriteReg(0x000F,0x0000);<br>        LCD_WriteReg(0x0020,0x0000);<br>        LCD_WriteReg(0x0021,0x0000);<br>        LCD_WriteReg(0x0007,0x0021);<br>        LCD_Delay(20);<br>        LCD_WriteReg(0x0007,0x0061);<br>        LCD_Delay(20);<br>        LCD_WriteReg(0x0007,0x0173);<br>        LCD_Delay(20);<br><br>    }else if(DeviceCode==0xB505){                     //stm32 正点原子 LCD 驱动IC<br><br>        LCD_WriteReg(0x0000,0x0000);<br>        LCD_WriteReg(0x0000,0x0000);<br>        LCD_WriteReg(0x0000,0x0000);<br>        LCD_WriteReg(0x0000,0x0000);<br><br>        LCD_WriteReg(0x00a4,0x0001);<br>        LCD_Delay(20);<br>        LCD_WriteReg(0x0060,0x2700);<br>        LCD_WriteReg(0x0008,0x0202);<br><br>        LCD_WriteReg(0x0030,0x0214);<br>        LCD_WriteReg(0x0031,0x3715);<br>        LCD_WriteReg(0x0032,0x0604);<br>        LCD_WriteReg(0x0033,0x0e16);<br>        LCD_WriteReg(0x0034,0x2211);<br>        LCD_WriteReg(0x0035,0x1500);<br>        LCD_WriteReg(0x0036,0x8507);<br>        LCD_WriteReg(0x0037,0x1407);<br>        LCD_WriteReg(0x0038,0x1403);<br>        LCD_WriteReg(0x0039,0x0020);<br><br>        LCD_WriteReg(0x0090,0x001a);<br>        LCD_WriteReg(0x0010,0x0000);<br>        LCD_WriteReg(0x0011,0x0007);<br>        LCD_WriteReg(0x0012,0x0000);<br>        LCD_WriteReg(0x0013,0x0000);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0010,0x0730);<br>        LCD_WriteReg(0x0011,0x0137);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0012,0x01b8);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0013,0x0f00);<br>        LCD_WriteReg(0x002a,0x0080);<br>        LCD_WriteReg(0x0029,0x0048);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0001,0x0100);<br>        LCD_WriteReg(0x0002,0x0700);<br>        LCD_WriteReg(0x0003,0x1230);<br>        LCD_WriteReg(0x0008,0x0202);<br>        LCD_WriteReg(0x000a,0x0000);<br>        LCD_WriteReg(0x000c,0x0000);<br>        LCD_WriteReg(0x000d,0x0000);<br>        LCD_WriteReg(0x000e,0x0030);<br>        LCD_WriteReg(0x0050,0x0000);<br>        LCD_WriteReg(0x0051,0x00ef);<br>        LCD_WriteReg(0x0052,0x0000);<br>        LCD_WriteReg(0x0053,0x013f);<br>        LCD_WriteReg(0x0060,0x2700);<br>        LCD_WriteReg(0x0061,0x0001);<br>        LCD_WriteReg(0x006a,0x0000);<br>        //LCD_WriteReg(0x0080,0x0000);<br>        //LCD_WriteReg(0x0081,0x0000);<br>        LCD_WriteReg(0x0090,0X0011);<br>        LCD_WriteReg(0x0092,0x0600);<br>        LCD_WriteReg(0x0093,0x0402);<br>        LCD_WriteReg(0x0094,0x0002);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0007,0x0001);<br>        LCD_Delay(20);<br>        LCD_WriteReg(0x0007,0x0061);<br>        LCD_WriteReg(0x0007,0x0173);<br><br>        LCD_WriteReg(0x0020,0x0000);<br>        LCD_WriteReg(0x0021,0x0000);<br>        LCD_WriteReg(0x00,0x22);<br><br>    }else if(DeviceCode==0x8989){<br><br>        LCD_WriteReg(0x0000,0x0001);LCD_Delay(5);//打开晶振<br>        LCD_WriteReg(0x0003,0xA8A4);LCD_Delay(5);//0xA8A4<br>        LCD_WriteReg(0x000C,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x000D,0x080C);LCD_Delay(5);<br>        LCD_WriteReg(0x000E,0x2B00);LCD_Delay(5);<br>        LCD_WriteReg(0x001E,0x00B0);LCD_Delay(5);<br>        LCD_WriteReg(0x0001,0x2B3F);LCD_Delay(5);//驱动输出控制320<em>240  0x6B3F<br>        LCD_WriteReg(0x0002,0x0600);LCD_Delay(5);<br>        LCD_WriteReg(0x0010,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0011,0x6070);LCD_Delay(5);//定义数据格式  16位色         横屏 0x6058<br>        LCD_WriteReg(0x0005,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0006,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0016,0xEF1C);LCD_Delay(5);<br>        LCD_WriteReg(0x0017,0x0003);LCD_Delay(5);<br>        LCD_WriteReg(0x0007,0x0233);LCD_Delay(5);//0x0233<br>        LCD_WriteReg(0x000B,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x000F,0x0000);LCD_Delay(5);//扫描开始地址<br>        LCD_WriteReg(0x0041,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0042,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0048,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0049,0x013F);LCD_Delay(5);<br>        LCD_WriteReg(0x004A,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x004B,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0044,0xEF00);LCD_Delay(5);<br>        LCD_WriteReg(0x0045,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0046,0x013F);LCD_Delay(5);<br>        LCD_WriteReg(0x0030,0x0707);LCD_Delay(5);<br>        LCD_WriteReg(0x0031,0x0204);LCD_Delay(5);<br>        LCD_WriteReg(0x0032,0x0204);LCD_Delay(5);<br>        LCD_WriteReg(0x0033,0x0502);LCD_Delay(5);<br>        LCD_WriteReg(0x0034,0x0507);LCD_Delay(5);<br>        LCD_WriteReg(0x0035,0x0204);LCD_Delay(5);<br>        LCD_WriteReg(0x0036,0x0204);LCD_Delay(5);<br>        LCD_WriteReg(0x0037,0x0502);LCD_Delay(5);<br>        LCD_WriteReg(0x003A,0x0302);LCD_Delay(5);<br>        LCD_WriteReg(0x003B,0x0302);LCD_Delay(5);<br>        LCD_WriteReg(0x0023,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0024,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0025,0x8000);LCD_Delay(5);<br>        LCD_WriteReg(0x004f,0);        //行首址0<br>        LCD_WriteReg(0x004e,0);        //列首址0<br><br>    }else if(DeviceCode==0x4531){<br><br>        LCD_WriteReg(0X00,0X0001);<br>        LCD_Delay(50);<br>        LCD_WriteReg(0X10,0X1628);<br>        LCD_WriteReg(0X12,0X000e);//0x0006<br>        LCD_WriteReg(0X13,0X0A39);<br>        LCD_Delay(10);<br>        LCD_WriteReg(0X11,0X0040);<br>        LCD_WriteReg(0X15,0X0050);<br>        LCD_Delay(40);<br>        LCD_WriteReg(0X12,0X001e);//16<br>        LCD_Delay(40);<br>        LCD_WriteReg(0X10,0X1620);<br>        LCD_WriteReg(0X13,0X2A39);<br>        LCD_Delay(10);<br>        LCD_WriteReg(0X01,0X0100);<br>        LCD_WriteReg(0X02,0X0300);<br>        LCD_WriteReg(0X03,0X1030);//改变方向的<br>        LCD_WriteReg(0X08,0X0202);<br>        LCD_WriteReg(0X0A,0X0008);<br>        LCD_WriteReg(0X30,0X0000);<br>        LCD_WriteReg(0X31,0X0402);<br>        LCD_WriteReg(0X32,0X0106);<br>        LCD_WriteReg(0X33,0X0503);<br>        LCD_WriteReg(0X34,0X0104);<br>        LCD_WriteReg(0X35,0X0301);<br>        LCD_WriteReg(0X36,0X0707);<br>        LCD_WriteReg(0X37,0X0305);<br>        LCD_WriteReg(0X38,0X0208);<br>        LCD_WriteReg(0X39,0X0F0B);<br>        LCD_WriteReg(0X41,0X0002);<br>        LCD_WriteReg(0X60,0X2700);<br>        LCD_WriteReg(0X61,0X0001);<br>        LCD_WriteReg(0X90,0X0210);<br>        LCD_WriteReg(0X92,0X010A);<br>        LCD_WriteReg(0X93,0X0004);<br>        LCD_WriteReg(0XA0,0X0100);<br>        LCD_WriteReg(0X07,0X0001);<br>        LCD_WriteReg(0X07,0X0021);<br>        LCD_WriteReg(0X07,0X0023);<br>        LCD_WriteReg(0X07,0X0033);<br>        LCD_WriteReg(0X07,0X0133);<br>        LCD_WriteReg(0XA0,0X0000);<br>    }<br><br>    LCD_Delay(5000);<br>    Set_LED;//点亮背光<br>    LCD_Clear(WHITE);<br>}<br><br>//清屏函数<br>//Color:要清屏的填充色<br>void LCD_Clear(u16 Color)<br>{<br>    u32 index=0;<br>    LCD_SetCursor(0x00,0x0000);//设置光标位置<br>    LCD_WriteRAM_Prepare();     //开始写入GRAM<br>    for(index=0;index&lt;76800;index++)<br>    {<br>        LCD_WR_DATA(Color);   //向每个GRAM写入数据<br>    }<br>}<br><br>//在指定区域内填充指定颜色<br>//区域大小:<br>//  (xend-xsta)</em>(yend-ysta)<br>void LCD_Fill(u8 xsta,u16 ysta,u8 xend,u16 yend,u16 color)<br>{<br><br>#if USE_HORIZONTAL         //横屏<br><br>    u16 colortemp=POINT_COLOR;<br>    u16 ytemp=ysta;<br>    POINT_COLOR=color;<br>    for(;xsta&lt;=xend;xsta++)<br>    {<br>        for(;ysta&lt;=yend;ysta++)LCD_DrawPoint(xsta,ysta);<br>        ysta=ytemp;<br>    }<br>    POINT_COLOR=colortemp;<br><br>#else                        //竖屏<br><br>    u32 n;<br>    //设置窗口<br>    LCD_WriteReg(R80, xsta); //水平方向GRAM起始地址<br>    LCD_WriteReg(R81, xend); //水平方向GRAM结束地址<br>    LCD_WriteReg(R82, ysta); //垂直方向GRAM起始地址<br>    LCD_WriteReg(R83, yend); //垂直方向GRAM结束地址<br>    LCD_SetCursor(xsta,ysta);//设置光标位置<br>    LCD_WriteRAM_Prepare();  //开始写入GRAM<br>    n=(u32)(yend-ysta+1)<em>(xend-xsta+1);<br>    while(n–){LCD_WR_DATA(color);}//显示所填充的颜色.<br>    //恢复设置<br>    LCD_WriteReg(R80, 0x0000); //水平方向GRAM起始地址<br>    LCD_WriteReg(R81, (LCD_WIDTH-1)); //水平方向GRAM结束地址<br>    LCD_WriteReg(R82, 0x0000); //垂直方向GRAM起始地址<br>    LCD_WriteReg(R83, (LCD_HEIGHT-1)); //垂直方向GRAM结束地址<br><br>#endif<br><br>}<br><br>//画线<br>//x1,y1:起点坐标<br>//x2,y2:终点坐标<br>void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)<br>{<br>    u16 t;<br>    int xerr=0,yerr=0,delta_x,delta_y,distance;<br>    int incx,incy,uRow,uCol;<br><br>    delta_x=x2-x1; //计算坐标增量<br>    delta_y=y2-y1;<br>    uRow=x1;<br>    uCol=y1;<br>    if(delta_x&gt;0)incx=1; //设置单步方向<br>    else if(delta_x==0)incx=0;//垂直线<br>    else {incx=-1;delta_x=-delta_x;}   //终点坐标小于起始坐标,反方向,将坐标重新定位为正坐标<br>    if(delta_y&gt;0)incy=1;<br>    else if(delta_y==0)incy=0;//水平线<br>    else{incy=-1;delta_y=-delta_y;}   //终点坐标小于起始坐标,反方向,将坐标重新定位为正坐标<br>    if( delta_x&gt;delta_y)distance=delta_x; //选取基本增量坐标轴<br>    else distance=delta_y;<br>    for(t=0;t&lt;=distance+1;t++ )//画线输出<br>    {<br>        LCD_DrawPoint(uRow,uCol);//根据坐标画点<br>        xerr+=delta_x ;  //X坐标增量<br>        yerr+=delta_y ;  //Y坐标增量<br>        if(xerr&gt;distance)<br>        {<br>            xerr-=distance;<br>            uRow+=incx;<br><br>        }<br>        if(yerr&gt;distance)<br>        {<br>            yerr-=distance;<br>            uCol+=incy;<br>        }<br>    }<br>}<br><br>//画矩形<br>void LCD_DrawRectangle(u8 x1, u16 y1, u8 x2, u16 y2)<br>{<br>    LCD_DrawLine(x1,y1,x2,y1);<br>    LCD_DrawLine(x1,y1,x1,y2);<br>    LCD_DrawLine(x1,y2,x2,y2);<br>    LCD_DrawLine(x2,y1,x2,y2);<br>}<br><br>//在指定位置画一个指定大小的圆<br>//(x,y):中心点<br>//r    :半径<br>void Draw_Circle(u8 x0,u16 y0,u8 r)<br>{<br>    int a,b;<br>    int di;<br>    a=0;b=r;<br>    di=3-(r&lt;&lt;1);             //判断下个点位置的标志<br>    while(a&lt;=b)<br>    {<br>        LCD_DrawPoint(x0-b,y0-a);             //3<br>        LCD_DrawPoint(x0+b,y0-a);             //0<br>        LCD_DrawPoint(x0-a,y0+b);             //1<br>        LCD_DrawPoint(x0-b,y0-a);             //7<br>        LCD_DrawPoint(x0-a,y0-b);             //2<br>        LCD_DrawPoint(x0+b,y0+a);             //4<br>        LCD_DrawPoint(x0+a,y0-b);             //5<br>        LCD_DrawPoint(x0+a,y0+b);             //6<br>        LCD_DrawPoint(x0-b,y0+a);<br><br>        a++;<br><br>        //使用Bresenham算法画圆<br>        if(di&lt;0){<br>            di +=4</em>a+6;<br>        }else{<br>            di+=10+4<em>(a-b);<br>            b–;<br>        }<br>        LCD_DrawPoint(x0+a,y0+b);<br>    }<br>}<br><br>//在指定位置显示一个字符<br>//x:0~234<br>//y:0~308<br>//num:要显示的字符:” “—&gt;”~”<br>//size:字体大小 12/16<br>//mode:叠加方式(1)还是非叠加方式(0)<br>void LCD_ShowChar(u8 x,u16 y,u8 num,u8 size,u8 mode)<br>{<br><br>#if USE_HORIZONTAL<br><br>    #define MAX_CHAR_POSX 312<br>    #define MAX_CHAR_POSY 232<br><br>    u8 temp;<br>    u8 pos,t;<br>    u16 x0=x;<br>    u16 colortemp=POINT_COLOR;<br>    if(x&gt;MAX_CHAR_POSX||y&gt;MAX_CHAR_POSY)return;<br>    //设置窗口<br>    num=num-‘ ‘;//得到偏移后的值<br>    if(!mode) //非叠加方式<br>    {<br>        for(pos=0;pos&lt;size;pos++)<br>        {<br>            if(size==12)<br>                temp=asc2_1206[num][pos];//调用1206字体<br>            else<br>                temp=asc2_1608[num][pos];         //调用1608字体<br><br>            for(t=0;t&lt;size/2;t++)<br>            {<br>                if(temp&amp;0x01)<br>                    POINT_COLOR=colortemp;<br>                else<br>                    POINT_COLOR=BACK_COLOR;<br><br>                LCD_DrawPoint(x,y);<br>                temp&gt;&gt;=1;<br>                x++;<br>            }<br>            x=x0;<br>            y++;<br>        }<br>    }else{                                            //叠加方式<br>        for(pos=0;pos&lt;size;pos++)<br>        {<br>            if(size==12)<br>                temp=asc2_1206[num][pos];//调用1206字体<br>            else<br>                temp=asc2_1608[num][pos];         //调用1608字体<br><br>            for(t=0;t&lt;size/2;t++)<br>            {<br>                if(temp&amp;0x01)LCD_DrawPoint(x+t,y+pos);//画一个点<br>                temp&gt;&gt;=1;<br>            }<br>        }<br>    }<br>    POINT_COLOR=colortemp;<br><br>#else<br>    #define MAX_CHAR_POSX 232<br>    #define MAX_CHAR_POSY 304<br><br>    u8 temp;<br>    u8 pos,t;<br><br>    if(x&gt;MAX_CHAR_POSX||y&gt;MAX_CHAR_POSY)return;<br>    //设置窗口<br><br>    LCD_WriteReg(R80,x);           //水平方向GRAM起始地址<br>    LCD_WriteReg(R81,x+(size/2-1));//水平方向GRAM结束地址<br>    LCD_WriteReg(R82,y);           //垂直方向GRAM起始地址<br>    LCD_WriteReg(R83,y+size-1);    //垂直方向GRAM结束地址<br>    LCD_SetCursor(x,y);            //设置光标位置<br>    LCD_WriteRAM_Prepare();        //开始写入GRAM<br>    num=num-‘ ‘;//得到偏移后的值<br>    if(!mode) //非叠加方式<br>    {<br>        for(pos=0;pos&lt;size;pos++)<br>        {<br>            if(size==12)<br>                temp=asc2_1206[num][pos];//调用1206字体<br>            else<br>                temp=asc2_1608[num][pos];         //调用1608字体<br><br>            for(t=0;t&lt;size/2;t++)<br>            {<br>                if(temp&amp;0x01){<br>                    LCD_WR_DATA(POINT_COLOR);<br>                }else{<br>                    LCD_WR_DATA(BACK_COLOR);<br>                }<br><br>                temp&gt;&gt;=1;<br>            }<br>        }<br>    }else{            //叠加方式<br><br>        for(pos=0;pos&lt;size;pos++)<br>        {<br>            if(size==12)<br>                temp=asc2_1206[num][pos];        //调用1206字体<br>            else<br>                temp=asc2_1608[num][pos];         //调用1608字体<br>            for(t=0;t&lt;size/2;t++)<br>            {<br>                if(temp&amp;0x01)<br>                    LCD_DrawPoint(x+t,y+pos);//画一个点<br>                temp&gt;&gt;=1;<br>            }<br>        }<br>    }<br>    //恢复窗体大小<br>    LCD_WriteReg(R80, 0x0000); //水平方向GRAM起始地址<br>    LCD_WriteReg(R81, (LCD_WIDTH-1)); //水平方向GRAM结束地址<br>    LCD_WriteReg(R82, 0x0000); //垂直方向GRAM起始地址<br>    LCD_WriteReg(R83, (LCD_HEIGHT-1)); //垂直方向GRAM结束地址<br><br>#endif<br><br>}<br><br>//m^n函数<br>u32 mypow(u8 m,u8 n)<br>{<br>    u32 result=1;<br>    while(n–)result</em>=m;<br>    return result;<br>}<br><br>//显示数字<br>//x,y :起点坐标<br>//len :数字的位数<br>//size:字体大小<br>//color:颜色<br>//num:数值(0~4294967295);<br>void LCD_ShowNum(u8 x,u16 y,u32 num,u8 len,u8 size)<br>{<br>    u8 t,temp;<br>    u8 enshow=0;<br>    for(t=0;t&lt;len;t++)<br>    {<br>        temp=(num/mypow(10,len-t-1))%10;<br>        if(enshow==0&amp;&amp;t&lt;(len-1))<br>        {<br>            if(temp==0)<br>            {<br>                LCD_ShowChar(x+(size/2)<em>t,y,’ ‘,size,0);<br>                continue;<br>            }else{<br>                enshow=1;<br>            }<br>        }<br>        LCD_ShowChar(x+(size/2)</em>t,y,temp+’0’,size,0);<br>    }<br>}<br><br>//显示字符串<br>//x,y:起点坐标<br>//<em>p:字符串起始地址<br>//用16字体<br>void LCD_ShowString(u8 x,u16 y,const u8 </em>p)<br>{<br>    while(<em>p!=’\0’)     //字符串到达结束<br>    {<br>        if(x&gt;MAX_CHAR_POSX){x=0;y+=16;}       //换行<br>        if(y&gt;MAX_CHAR_POSY){y=x=0;LCD_Clear(WHITE);}  //超出屏幕显示范围<br>        LCD_ShowChar(x,y,</em>p,16,0);<br>        x+=8;<br>        p++;<br>    }<br>}<br><br></pre></div></div></div><div>&nbsp; &nbsp; LCD/ili93xx.h (相关I/O操作在此文件中以宏定义的方式实现)</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br><br>//TFTLCD部分外要调用的函数<br>extern u16  POINT_COLOR;//默认红色<br>extern u16  BACK_COLOR; //背景颜色.默认为白色<br><br>//定义LCD的尺寸<br>#define LCD_WIDTH 240<br>#define LCD_HEIGHT 320<br><br>//9320/9325 LCD寄存器<br>#define R0             0x00<br>#define R1             0x01<br>#define R2             0x02<br>#define R3             0x03<br>#define R4             0x04<br>#define R5             0x05<br>#define R6             0x06<br>#define R7             0x07<br>#define R8             0x08<br>#define R9             0x09<br>#define R10            0x0A<br>#define R12            0x0C<br>#define R13            0x0D<br>#define R14            0x0E<br>#define R15            0x0F<br>#define R16            0x10<br>#define R17            0x11<br>#define R18            0x12<br>#define R19            0x13<br>#define R20            0x14<br>#define R21            0x15<br>#define R22            0x16<br>#define R23            0x17<br>#define R24            0x18<br>#define R25            0x19<br>#define R26            0x1A<br>#define R27            0x1B<br>#define R28            0x1C<br>#define R29            0x1D<br>#define R30            0x1E<br>#define R31            0x1F<br>#define R32            0x20<br>#define R33            0x21<br>#define R34            0x22<br>#define R36            0x24<br>#define R37            0x25<br>#define R40            0x28<br>#define R41            0x29<br>#define R43            0x2B<br>#define R45            0x2D<br>#define R48            0x30<br>#define R49            0x31<br>#define R50            0x32<br>#define R51            0x33<br>#define R52            0x34<br>#define R53            0x35<br>#define R54            0x36<br>#define R55            0x37<br>#define R56            0x38<br>#define R57            0x39<br>#define R59            0x3B<br>#define R60            0x3C<br>#define R61            0x3D<br>#define R62            0x3E<br>#define R63            0x3F<br>#define R64            0x40<br>#define R65            0x41<br>#define R66            0x42<br>#define R67            0x43<br>#define R68            0x44<br>#define R69            0x45<br>#define R70            0x46<br>#define R71            0x47<br>#define R72            0x48<br>#define R73            0x49<br>#define R74            0x4A<br>#define R75            0x4B<br>#define R76            0x4C<br>#define R77            0x4D<br>#define R78            0x4E<br>#define R79            0x4F<br>#define R80            0x50<br>#define R81            0x51<br>#define R82            0x52<br>#define R83            0x53<br>#define R96            0x60<br>#define R97            0x61<br>#define R106           0x6A<br>#define R118           0x76<br>#define R128           0x80<br>#define R129           0x81<br>#define R130           0x82<br>#define R131           0x83<br>#define R132           0x84<br>#define R133           0x85<br>#define R134           0x86<br>#define R135           0x87<br>#define R136           0x88<br>#define R137           0x89<br>#define R139           0x8B<br>#define R140           0x8C<br>#define R141           0x8D<br>#define R143           0x8F<br>#define R144           0x90<br>#define R145           0x91<br>#define R146           0x92<br>#define R147           0x93<br>#define R148           0x94<br>#define R149           0x95<br>#define R150           0x96<br>#define R151           0x97<br>#define R152           0x98<br>#define R153           0x99<br>#define R154           0x9A<br>#define R157           0x9D<br>#define R192           0xC0<br>#define R193           0xC1<br>#define R229           0xE5<br><br>/<em>硬件相关的宏定义</em>/<br>#define LCD_FAST_IO     1     //定义是否使用快速IO     建议使用快速IO,效率更高<br><br>//—————–LCD端口定义—————-<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><br>#define LCD_GPIO_LED_PORT              GPIOC<br>#define LCD_GPIO_LED_PIN               GPIO_Pin_10<br><br>#define LCD_GPIO_CS_PORT              GPIOC<br>#define LCD_GPIO_CS_PIN               GPIO_Pin_9<br><br>#define LCD_GPIO_RS_PORT              GPIOC<br>#define LCD_GPIO_RS_PIN               GPIO_Pin_8<br><br>#define LCD_GPIO_WR_PORT             GPIOC<br>#define LCD_GPIO_WR_PIN              GPIO_Pin_7<br><br>#define LCD_GPIO_RD_PORT              GPIOC<br>#define LCD_GPIO_RD_PIN               GPIO_Pin_6<br><br>//16位数据所在端口,PB0~15作为数据线<br>#define LCD_GPIO_DATA_PORT            GPIOB<br>#define LCD_GPIO_DATA_PIN             GPIO_Pin_All<br><br>#if LCD_FAST_IO == 1 //快速IO<br><br>#define    Set_Cs  GPIOC-&gt;BSRR=1&lt;&lt;9    //片选端口           PC9<br>#define    Set_Rs    GPIOC-&gt;BSRR=1&lt;&lt;8    //数据/命令          PC8<br>#define    Set_Wr    GPIOC-&gt;BSRR=1&lt;&lt;7    //写数据             PC7<br>#define    Set_Rd    GPIOC-&gt;BSRR=1&lt;&lt;6    //读数据             PC6<br><br>#define    Clr_Cs  GPIOC-&gt;BRR=1&lt;&lt;9     //片选端口           PC9<br>#define    Clr_Rs    GPIOC-&gt;BRR=1&lt;&lt;8     //数据/命令          PC8<br>#define    Clr_Wr    GPIOC-&gt;BRR=1&lt;&lt;7     //写数据             PC7<br>#define    Clr_Rd    GPIOC-&gt;BRR=1&lt;&lt;6     //读数据             PC6<br><br>#else<br><br>#define Set_Cs   {GPIO_SetBits(LCD_GPIO_CS_PORT,LCD_GPIO_CS_PIN);}<br>#define Clr_Cs   {GPIO_ResetBits(LCD_GPIO_CS_PORT,LCD_GPIO_CS_PIN);}<br>#define Set_Rs   {GPIO_SetBits(LCD_GPIO_RS_PORT,LCD_GPIO_RS_PIN);}<br>#define Clr_Rs   {GPIO_ResetBits(LCD_GPIO_RS_PORT,LCD_GPIO_RS_PIN);}<br>#define Set_Wr   {GPIO_SetBits(LCD_GPIO_WR_PORT,LCD_GPIO_WR_PIN);}<br>#define Clr_Wr   {GPIO_ResetBits(LCD_GPIO_WR_PORT,LCD_GPIO_WR_PIN);}<br>#define Set_Rd   {GPIO_SetBits(LCD_GPIO_RD_PORT,LCD_GPIO_RD_PIN);}<br>#define Clr_Rd   {GPIO_ResetBits(LCD_GPIO_RD_PORT,LCD_GPIO_RD_PIN);}<br><br>#endif<br><br>#define Set_LED  {GPIO_SetBits(LCD_GPIO_LED_PORT,LCD_GPIO_LED_PIN);}<br>#define Clr_LED  {GPIO_ResetBits(LCD_GPIO_LED_PORT,LCD_GPIO_LED_PIN);}<br><br>#define Write_Data(DataValue) {GPIO_Write(LCD_GPIO_DATA_PORT,DataValue);}<br><br>//直接操作寄存器读取,使用库函数读取I/O有问题,原因不详<br>#define Read_Data() (LCD_GPIO_DATA_PORT -&gt;IDR)                        //必须使用宏定义,写成函数会有问题<br>//#define Read_Data()  (GPIO_ReadInputData(LCD_GPIO_DATA_PORT))        //这句有问题<br><br>//写8位数据函数<br>//用宏定义,提高速度.<br>#define  LCD_WR_DATA(data){\<br>Set_Rs;\<br>Clr_Cs;\<br>Write_Data(data);\<br>Clr_Wr;\<br>Set_Wr;\<br>Set_Cs;\<br>}<br><br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><br>//画笔颜色<br>#define WHITE              0xFFFF<br>#define BLACK              0x0000<br>#define BLUE              0x001F<br>#define BRED             0XF81F<br>#define GRED              0XFFE0<br>#define GBLUE             0X07FF<br>#define RED                0xF800<br>#define MAGENTA            0xF81F<br>#define GREEN              0x07E0<br>#define CYAN               0x7FFF<br>#define YELLOW             0xFFE0<br>#define BROWN              0XBC40 //棕色<br>#define BRRED              0XFC07 //棕红色<br>#define GRAY               0X8430 //灰色<br>//GUI颜色<br><br>#define DARKBLUE           0X01CF    //深蓝色<br>#define LIGHTBLUE           0X7D7C    //浅蓝色<br>#define GRAYBLUE            0X5458 //灰蓝色<br>//以上三色为PANEL的颜色<br><br>#define LIGHTGREEN          0X841F //浅绿色<br>//#define LIGHTGRAY        0XEF5B //浅灰色(PANNEL)<br>#define LGRAY              0XC618 //浅灰色(PANNEL),窗体背景色<br>#define LGRAYBLUE        0XA651 //浅灰蓝色(中间层颜色)<br>#define LBBLUE           0X2B12 //浅棕蓝色(选择条目的反色)<br><br>void LCD_Delay(u32 nCount);<br>void LCD_Config(void);<br>void LCD_DisplayOn(void);<br>void LCD_DisplayOff(void);<br>void LCD_Clear(u16 Color);<br>void LCD_SetCursor(u8 Xpos, u16 Ypos);<br>void LCD_DrawPoint(u16 x,u16 y);//画点<br>u16 LCD_ReadPoint(u16 x,u16 y); //读点<br>void Draw_Circle(u8 x0,u16 y0,u8 r);<br>void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2);<br>void LCD_DrawRectangle(u8 x1, u16 y1, u8 x2, u16 y2);<br>void LCD_Fill(u8 xsta,u16 ysta,u8 xend,u16 yend,u16 color);<br>void LCD_ShowChar(u8 x,u16 y,u8 num,u8 size,u8 mode);//显示一个字符<br>void LCD_ShowNum(u8 x,u16 y,u32 num,u8 len,u8 size);  //显示一个数字<br>void LCD_ShowString(u8 x,u16 y,const u8 <em>p);         //显示一个字符串,16字体<br><br>void LCD_WriteReg(u8 LCD_Reg, u16 LCD_RegValue);<br>u16 LCD_ReadReg(u8 LCD_Reg);<br>void LCD_WriteRAM_Prepare(void);<br>void LCD_WriteRAM(u16 RGB_Code);<br>u16 LCD_ReadRAM(void);<br><br></em></pre></div><div>&nbsp;font.h （字库文件）</div><div><pre class="brush:cpp;"><br>//常用ASCII表<br>//偏移量32<br>//ASCII字符集<br>//偏移量32<br>//大小:126<br>const unsigned char asc2_1206[95][12]={<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“ “,0</em>/<br>{0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x04,0x00,0x00},/<em>“!”,1</em>/<br>{0x00,0x14,0x0A,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“””,2</em>/<br>{0x00,0x00,0x14,0x14,0x3F,0x14,0x0A,0x3F,0x0A,0x0A,0x00,0x00},/<em>“#”,3</em>/<br>{0x00,0x04,0x1E,0x15,0x05,0x06,0x0C,0x14,0x15,0x0F,0x04,0x00},/<em>“$”,4</em>/<br>{0x00,0x00,0x12,0x15,0x0D,0x0A,0x14,0x2C,0x2A,0x12,0x00,0x00},/<em>“%”,5</em>/<br>{0x00,0x00,0x04,0x0A,0x0A,0x1E,0x15,0x15,0x09,0x36,0x00,0x00},/<em>“&amp;”,6</em>/<br>{0x00,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“‘“,7</em>/<br>{0x00,0x20,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x20,0x00},/<em>“(“,8</em>/<br>{0x00,0x02,0x04,0x08,0x08,0x08,0x08,0x08,0x08,0x04,0x02,0x00},/<em>“)”,9</em>/<br>{0x00,0x00,0x00,0x04,0x15,0x0E,0x0E,0x15,0x04,0x00,0x00,0x00},/<em>“</em>“,10<em>/<br>{0x00,0x00,0x04,0x04,0x04,0x1F,0x04,0x04,0x04,0x00,0x00,0x00},/</em>“+”,11<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x01},/</em>“,”,12<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00},/</em>“-“,13<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00},/</em>“.”,14<em>/<br>{0x00,0x10,0x08,0x08,0x08,0x04,0x04,0x02,0x02,0x02,0x01,0x00},/</em>“/“,15<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x11,0x11,0x0E,0x00,0x00},/</em>“0”,16<em>/<br>{0x00,0x00,0x04,0x06,0x04,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/</em>“1”,17<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x08,0x04,0x02,0x01,0x1F,0x00,0x00},/</em>“2”,18<em>/<br>{0x00,0x00,0x0E,0x11,0x10,0x0C,0x10,0x10,0x11,0x0E,0x00,0x00},/</em>“3”,19<em>/<br>{0x00,0x00,0x08,0x0C,0x0A,0x0A,0x09,0x1E,0x08,0x18,0x00,0x00},/</em>“4”,20<em>/<br>{0x00,0x00,0x1F,0x01,0x01,0x0F,0x10,0x10,0x11,0x0E,0x00,0x00},/</em>“5”,21<em>/<br>{0x00,0x00,0x0E,0x09,0x01,0x0F,0x11,0x11,0x11,0x0E,0x00,0x00},/</em>“6”,22<em>/<br>{0x00,0x00,0x1F,0x09,0x08,0x04,0x04,0x04,0x04,0x04,0x00,0x00},/</em>“7”,23<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x0E,0x11,0x11,0x11,0x0E,0x00,0x00},/</em>“8”,24<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x11,0x1E,0x10,0x12,0x0E,0x00,0x00},/</em>“9”,25<em>/<br>{0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x04,0x00,0x00},/</em>“:”,26<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x04,0x00},/</em>“;”,27<em>/<br>{0x00,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x00,0x00},/</em>“&lt;”,28<em>/<br>{0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x1F,0x00,0x00,0x00,0x00},/</em>“=”,29<em>/<br>{0x00,0x02,0x04,0x08,0x10,0x20,0x10,0x08,0x04,0x02,0x00,0x00},/</em>“&gt;”,30<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x08,0x04,0x04,0x00,0x04,0x00,0x00},/</em>“?”,31<em>/<br>{0x00,0x00,0x0E,0x11,0x19,0x15,0x15,0x1D,0x01,0x1E,0x00,0x00},/</em>“@”,32<em>/<br>{0x00,0x00,0x04,0x04,0x0C,0x0A,0x0A,0x1E,0x12,0x33,0x00,0x00},/</em>“A”,33<em>/<br>{0x00,0x00,0x0F,0x12,0x12,0x0E,0x12,0x12,0x12,0x0F,0x00,0x00},/</em>“B”,34<em>/<br>{0x00,0x00,0x1E,0x11,0x01,0x01,0x01,0x01,0x11,0x0E,0x00,0x00},/</em>“C”,35<em>/<br>{0x00,0x00,0x0F,0x12,0x12,0x12,0x12,0x12,0x12,0x0F,0x00,0x00},/</em>“D”,36<em>/<br>{0x00,0x00,0x1F,0x12,0x0A,0x0E,0x0A,0x02,0x12,0x1F,0x00,0x00},/</em>“E”,37<em>/<br>{0x00,0x00,0x1F,0x12,0x0A,0x0E,0x0A,0x02,0x02,0x07,0x00,0x00},/</em>“F”,38<em>/<br>{0x00,0x00,0x1C,0x12,0x01,0x01,0x39,0x11,0x12,0x0C,0x00,0x00},/</em>“G”,39<em>/<br>{0x00,0x00,0x33,0x12,0x12,0x1E,0x12,0x12,0x12,0x33,0x00,0x00},/</em>“H”,40<em>/<br>{0x00,0x00,0x1F,0x04,0x04,0x04,0x04,0x04,0x04,0x1F,0x00,0x00},/</em>“I”,41<em>/<br>{0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x09,0x07,0x00},/</em>“J”,42<em>/<br>{0x00,0x00,0x37,0x12,0x0A,0x06,0x0A,0x0A,0x12,0x37,0x00,0x00},/</em>“K”,43<em>/<br>{0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x02,0x22,0x3F,0x00,0x00},/</em>“L”,44<em>/<br>{0x00,0x00,0x1B,0x1B,0x1B,0x1B,0x15,0x15,0x15,0x15,0x00,0x00},/</em>“M”,45<em>/<br>{0x00,0x00,0x3B,0x12,0x16,0x16,0x1A,0x1A,0x12,0x17,0x00,0x00},/</em>“N”,46<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x11,0x11,0x0E,0x00,0x00},/</em>“O”,47<em>/<br>{0x00,0x00,0x0F,0x12,0x12,0x0E,0x02,0x02,0x02,0x07,0x00,0x00},/</em>“P”,48<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x17,0x19,0x0E,0x18,0x00},/</em>“Q”,49<em>/<br>{0x00,0x00,0x0F,0x12,0x12,0x0E,0x0A,0x12,0x12,0x37,0x00,0x00},/</em>“R”,50<em>/<br>{0x00,0x00,0x1E,0x11,0x01,0x06,0x08,0x10,0x11,0x0F,0x00,0x00},/</em>“S”,51<em>/<br>{0x00,0x00,0x1F,0x15,0x04,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/</em>“T”,52<em>/<br>{0x00,0x00,0x33,0x12,0x12,0x12,0x12,0x12,0x12,0x0C,0x00,0x00},/</em>“U”,53<em>/<br>{0x00,0x00,0x33,0x12,0x12,0x0A,0x0A,0x0C,0x04,0x04,0x00,0x00},/</em>“V”,54<em>/<br>{0x00,0x00,0x15,0x15,0x15,0x0E,0x0A,0x0A,0x0A,0x0A,0x00,0x00},/</em>“W”,55<em>/<br>{0x00,0x00,0x1B,0x0A,0x0A,0x04,0x04,0x0A,0x0A,0x1B,0x00,0x00},/</em>“X”,56<em>/<br>{0x00,0x00,0x1B,0x0A,0x0A,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/</em>“Y”,57<em>/<br>{0x00,0x00,0x1F,0x09,0x08,0x04,0x04,0x02,0x12,0x1F,0x00,0x00},/</em>“Z”,58<em>/<br>{0x00,0x1C,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x1C,0x00},/</em>“[“,59<em>/<br>{0x00,0x02,0x02,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x00,0x00},/</em>“\”,60<em>/<br>{0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0E,0x00},/</em>“]”,61<em>/<br>{0x00,0x04,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/</em>“^”,62<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F},/</em>“_”,63<em>/<br>{0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/</em>“<code>&quot;,64*/
{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x1C,0x12,0x3C,0x00,0x00},/*&quot;a&quot;,65*/
{0x00,0x00,0x03,0x02,0x02,0x0E,0x12,0x12,0x12,0x0E,0x00,0x00},/*&quot;b&quot;,66*/
{0x00,0x00,0x00,0x00,0x00,0x1C,0x12,0x02,0x02,0x1C,0x00,0x00},/*&quot;c&quot;,67*/
{0x00,0x00,0x18,0x10,0x10,0x1C,0x12,0x12,0x12,0x3C,0x00,0x00},/*&quot;d&quot;,68*/
{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x1E,0x02,0x1C,0x00,0x00},/*&quot;e&quot;,69*/
{0x00,0x00,0x38,0x04,0x04,0x1E,0x04,0x04,0x04,0x1E,0x00,0x00},/*&quot;f&quot;,70*/
{0x00,0x00,0x00,0x00,0x00,0x3C,0x12,0x0C,0x02,0x1E,0x22,0x1C},/*&quot;g&quot;,71*/
{0x00,0x00,0x03,0x02,0x02,0x0E,0x12,0x12,0x12,0x37,0x00,0x00},/*&quot;h&quot;,72*/
{0x00,0x00,0x04,0x00,0x00,0x06,0x04,0x04,0x04,0x0E,0x00,0x00},/*&quot;i&quot;,73*/
{0x00,0x00,0x08,0x00,0x00,0x0C,0x08,0x08,0x08,0x08,0x08,0x07},/*&quot;j&quot;,74*/
{0x00,0x00,0x03,0x02,0x02,0x3A,0x0A,0x0E,0x12,0x37,0x00,0x00},/*&quot;k&quot;,75*/
{0x00,0x00,0x07,0x04,0x04,0x04,0x04,0x04,0x04,0x1F,0x00,0x00},/*&quot;l&quot;,76*/
{0x00,0x00,0x00,0x00,0x00,0x0F,0x15,0x15,0x15,0x15,0x00,0x00},/*&quot;m&quot;,77*/
{0x00,0x00,0x00,0x00,0x00,0x0F,0x12,0x12,0x12,0x37,0x00,0x00},/*&quot;n&quot;,78*/
{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x12,0x12,0x0C,0x00,0x00},/*&quot;o&quot;,79*/
{0x00,0x00,0x00,0x00,0x00,0x0F,0x12,0x12,0x12,0x0E,0x02,0x07},/*&quot;p&quot;,80*/
{0x00,0x00,0x00,0x00,0x00,0x1C,0x12,0x12,0x12,0x1C,0x10,0x38},/*&quot;q&quot;,81*/
{0x00,0x00,0x00,0x00,0x00,0x1B,0x06,0x02,0x02,0x07,0x00,0x00},/*&quot;r&quot;,82*/
{0x00,0x00,0x00,0x00,0x00,0x1E,0x02,0x0C,0x10,0x1E,0x00,0x00},/*&quot;s&quot;,83*/
{0x00,0x00,0x00,0x04,0x04,0x0E,0x04,0x04,0x04,0x18,0x00,0x00},/*&quot;t&quot;,84*/
{0x00,0x00,0x00,0x00,0x00,0x1B,0x12,0x12,0x12,0x3C,0x00,0x00},/*&quot;u&quot;,85*/
{0x00,0x00,0x00,0x00,0x00,0x37,0x12,0x0A,0x0C,0x04,0x00,0x00},/*&quot;v&quot;,86*/
{0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x0E,0x0A,0x0A,0x00,0x00},/*&quot;w&quot;,87*/
{0x00,0x00,0x00,0x00,0x00,0x1B,0x0A,0x04,0x0A,0x1B,0x00,0x00},/*&quot;x&quot;,88*/
{0x00,0x00,0x00,0x00,0x00,0x37,0x12,0x0A,0x0C,0x04,0x04,0x03},/*&quot;y&quot;,89*/
{0x00,0x00,0x00,0x00,0x00,0x1E,0x08,0x04,0x04,0x1E,0x00,0x00},/*&quot;z&quot;,90*/
{0x00,0x18,0x08,0x08,0x08,0x04,0x08,0x08,0x08,0x08,0x18,0x00},/*&quot;{&quot;,91*/
{0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},/*&quot;|&quot;,92*/
{0x00,0x06,0x04,0x04,0x04,0x08,0x04,0x04,0x04,0x04,0x06,0x00},/*&quot;}&quot;,93*/
{0x02,0x25,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00} /*&quot;~&quot;,94*/
}; 
const unsigned char asc2_1608[95][16]={
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot; &quot;,0*/
{0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x18,0x18,0x00,0x00},/*&quot;!&quot;,1*/
{0x00,0x48,0x6C,0x24,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;&quot;&quot;,2*/
{0x00,0x00,0x00,0x24,0x24,0x24,0x7F,0x12,0x12,0x12,0x7F,0x12,0x12,0x12,0x00,0x00},/*&quot;#&quot;,3*/
{0x00,0x00,0x08,0x1C,0x2A,0x2A,0x0A,0x0C,0x18,0x28,0x28,0x2A,0x2A,0x1C,0x08,0x08},/*&quot;$&quot;,4*/
{0x00,0x00,0x00,0x22,0x25,0x15,0x15,0x15,0x2A,0x58,0x54,0x54,0x54,0x22,0x00,0x00},/*&quot;%&quot;,5*/
{0x00,0x00,0x00,0x0C,0x12,0x12,0x12,0x0A,0x76,0x25,0x29,0x11,0x91,0x6E,0x00,0x00},/*&quot;&amp;amp;&quot;,6*/
{0x00,0x06,0x06,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;&#39;&quot;,7*/
{0x00,0x40,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x40,0x00},/*&quot;(&quot;,8*/
{0x00,0x02,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x02,0x00},/*&quot;)&quot;,9*/
{0x00,0x00,0x00,0x00,0x08,0x08,0x6B,0x1C,0x1C,0x6B,0x08,0x08,0x00,0x00,0x00,0x00},/*&quot;*&quot;,10*/
{0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x7F,0x08,0x08,0x08,0x08,0x00,0x00,0x00},/*&quot;+&quot;,11*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x04,0x03},/*&quot;,&quot;,12*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;-&quot;,13*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x00,0x00},/*&quot;.&quot;,14*/
{0x00,0x00,0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x00},/*&quot;/&quot;,15*/
{0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00},/*&quot;0&quot;,16*/
{0x00,0x00,0x00,0x08,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/*&quot;1&quot;,17*/
{0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x20,0x20,0x10,0x08,0x04,0x42,0x7E,0x00,0x00},/*&quot;2&quot;,18*/
{0x00,0x00,0x00,0x3C,0x42,0x42,0x20,0x18,0x20,0x40,0x40,0x42,0x22,0x1C,0x00,0x00},/*&quot;3&quot;,19*/
{0x00,0x00,0x00,0x20,0x30,0x28,0x24,0x24,0x22,0x22,0x7E,0x20,0x20,0x78,0x00,0x00},/*&quot;4&quot;,20*/
{0x00,0x00,0x00,0x7E,0x02,0x02,0x02,0x1A,0x26,0x40,0x40,0x42,0x22,0x1C,0x00,0x00},/*&quot;5&quot;,21*/
{0x00,0x00,0x00,0x38,0x24,0x02,0x02,0x1A,0x26,0x42,0x42,0x42,0x24,0x18,0x00,0x00},/*&quot;6&quot;,22*/
{0x00,0x00,0x00,0x7E,0x22,0x22,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00},/*&quot;7&quot;,23*/     
{0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00},/*&quot;8&quot;,24*/
{0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x64,0x58,0x40,0x40,0x24,0x1C,0x00,0x00},/*&quot;9&quot;,25*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00},/*&quot;:&quot;,26*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x04},/*&quot;;&quot;,27*/
{0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x40,0x00,0x00},/*&quot;&amp;lt;&quot;,28*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00},/*&quot;=&quot;,29*/
{0x00,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x04,0x02,0x00,0x00},/*&quot;&amp;gt;&quot;,30*/
{0x00,0x00,0x00,0x3C,0x42,0x42,0x46,0x40,0x20,0x10,0x10,0x00,0x18,0x18,0x00,0x00},/*&quot;?&quot;,31*/
{0x00,0x00,0x00,0x1C,0x22,0x5A,0x55,0x55,0x55,0x55,0x2D,0x42,0x22,0x1C,0x00,0x00},/*&quot;@&quot;,32*/
{0x00,0x00,0x00,0x08,0x08,0x18,0x14,0x14,0x24,0x3C,0x22,0x42,0x42,0xE7,0x00,0x00},/*&quot;A&quot;,33*/
{0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x1E,0x22,0x42,0x42,0x42,0x22,0x1F,0x00,0x00},/*&quot;B&quot;,34*/
{0x00,0x00,0x00,0x7C,0x42,0x42,0x01,0x01,0x01,0x01,0x01,0x42,0x22,0x1C,0x00,0x00},/*&quot;C&quot;,35*/
{0x00,0x00,0x00,0x1F,0x22,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x1F,0x00,0x00},/*&quot;D&quot;,36*/
{0x00,0x00,0x00,0x3F,0x42,0x12,0x12,0x1E,0x12,0x12,0x02,0x42,0x42,0x3F,0x00,0x00},/*&quot;E&quot;,37*/
{0x00,0x00,0x00,0x3F,0x42,0x12,0x12,0x1E,0x12,0x12,0x02,0x02,0x02,0x07,0x00,0x00},/*&quot;F&quot;,38*/
{0x00,0x00,0x00,0x3C,0x22,0x22,0x01,0x01,0x01,0x71,0x21,0x22,0x22,0x1C,0x00,0x00},/*&quot;G&quot;,39*/
{0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/*&quot;H&quot;,40*/
{0x00,0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/*&quot;I&quot;,41*/
{0x00,0x00,0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x11,0x0F},/*&quot;J&quot;,42*/
{0x00,0x00,0x00,0x77,0x22,0x12,0x0A,0x0E,0x0A,0x12,0x12,0x22,0x22,0x77,0x00,0x00},/*&quot;K&quot;,43*/
{0x00,0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x42,0x7F,0x00,0x00},/*&quot;L&quot;,44*/
{0x00,0x00,0x00,0x77,0x36,0x36,0x36,0x36,0x2A,0x2A,0x2A,0x2A,0x2A,0x6B,0x00,0x00},/*&quot;M&quot;,45*/
{0x00,0x00,0x00,0xE3,0x46,0x46,0x4A,0x4A,0x52,0x52,0x52,0x62,0x62,0x47,0x00,0x00},/*&quot;N&quot;,46*/
{0x00,0x00,0x00,0x1C,0x22,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x22,0x1C,0x00,0x00},/*&quot;O&quot;,47*/
{0x00,0x00,0x00,0x3F,0x42,0x42,0x42,0x42,0x3E,0x02,0x02,0x02,0x02,0x07,0x00,0x00},/*&quot;P&quot;,48*/
{0x00,0x00,0x00,0x1C,0x22,0x41,0x41,0x41,0x41,0x41,0x4D,0x53,0x32,0x1C,0x60,0x00},/*&quot;Q&quot;,49*/
{0x00,0x00,0x00,0x3F,0x42,0x42,0x42,0x3E,0x12,0x12,0x22,0x22,0x42,0xC7,0x00,0x00},/*&quot;R&quot;,50*/
{0x00,0x00,0x00,0x7C,0x42,0x42,0x02,0x04,0x18,0x20,0x40,0x42,0x42,0x3E,0x00,0x00},/*&quot;S&quot;,51*/
{0x00,0x00,0x00,0x7F,0x49,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00},/*&quot;T&quot;,52*/
{0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00},/*&quot;U&quot;,53*/
{0x00,0x00,0x00,0xE7,0x42,0x42,0x22,0x24,0x24,0x14,0x14,0x18,0x08,0x08,0x00,0x00},/*&quot;V&quot;,54*/
{0x00,0x00,0x00,0x6B,0x49,0x49,0x49,0x49,0x55,0x55,0x36,0x22,0x22,0x22,0x00,0x00},/*&quot;W&quot;,55*/
{0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x18,0x18,0x18,0x24,0x24,0x42,0xE7,0x00,0x00},/*&quot;X&quot;,56*/
{0x00,0x00,0x00,0x77,0x22,0x22,0x14,0x14,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00},/*&quot;Y&quot;,57*/
{0x00,0x00,0x00,0x7E,0x21,0x20,0x10,0x10,0x08,0x04,0x04,0x42,0x42,0x3F,0x00,0x00},/*&quot;Z&quot;,58*/
{0x00,0x78,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x00},/*&quot;[&quot;,59*/
{0x00,0x00,0x02,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x10,0x20,0x20,0x20,0x40,0x40},/*&quot;\&quot;,60*/
{0x00,0x1E,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1E,0x00},/*&quot;]&quot;,61*/
{0x00,0x38,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;^&quot;,62*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},/*&quot;_&quot;,63*/
{0x00,0x06,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;</code>“,64<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x78,0x44,0x42,0x42,0xFC,0x00,0x00},/</em>“a”,65<em>/<br>{0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x1A,0x26,0x42,0x42,0x42,0x26,0x1A,0x00,0x00},/</em>“b”,66<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x44,0x02,0x02,0x02,0x44,0x38,0x00,0x00},/</em>“c”,67<em>/<br>{0x00,0x00,0x00,0x60,0x40,0x40,0x40,0x78,0x44,0x42,0x42,0x42,0x64,0xD8,0x00,0x00},/</em>“d”,68<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x7E,0x02,0x02,0x42,0x3C,0x00,0x00},/</em>“e”,69<em>/<br>{0x00,0x00,0x00,0xF0,0x88,0x08,0x08,0x7E,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/</em>“f”,70<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x22,0x22,0x1C,0x02,0x3C,0x42,0x42,0x3C},/</em>“g”,71<em>/<br>{0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x3A,0x46,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/</em>“h”,72<em>/<br>{0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/</em>“i”,73<em>/<br>{0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x38,0x20,0x20,0x20,0x20,0x20,0x20,0x22,0x1E},/</em>“j”,74<em>/<br>{0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x72,0x12,0x0A,0x16,0x12,0x22,0x77,0x00,0x00},/</em>“k”,75<em>/<br>{0x00,0x00,0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/</em>“l”,76<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x92,0x92,0x92,0x92,0x92,0xB7,0x00,0x00},/</em>“m”,77<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3B,0x46,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/</em>“n”,78<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00},/</em>“o”,79<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1B,0x26,0x42,0x42,0x42,0x22,0x1E,0x02,0x07},/</em>“p”,80<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x44,0x42,0x42,0x42,0x44,0x78,0x40,0xE0},/</em>“q”,81<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x4C,0x04,0x04,0x04,0x04,0x1F,0x00,0x00},/</em>“r”,82<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x42,0x02,0x3C,0x40,0x42,0x3E,0x00,0x00},/</em>“s”,83<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x3E,0x08,0x08,0x08,0x08,0x08,0x30,0x00,0x00},/</em>“t”,84<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x42,0x42,0x42,0x42,0x62,0xDC,0x00,0x00},/</em>“u”,85<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x14,0x08,0x08,0x00,0x00},/</em>“v”,86<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEB,0x49,0x49,0x55,0x55,0x22,0x22,0x00,0x00},/</em>“w”,87<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x24,0x18,0x18,0x18,0x24,0x6E,0x00,0x00},/</em>“x”,88<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x14,0x18,0x08,0x08,0x07},/</em>“y”,89<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x22,0x10,0x08,0x08,0x44,0x7E,0x00,0x00},/</em>“z”,90<em>/<br>{0x00,0xC0,0x20,0x20,0x20,0x20,0x20,0x10,0x20,0x20,0x20,0x20,0x20,0x20,0xC0,0x00},/</em>“{“,91<em>/<br>{0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10},/</em>“|”,92<em>/<br>{0x00,0x06,0x08,0x08,0x08,0x08,0x08,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x06,0x00},/</em>“}”,93<em>/<br>{0x0C,0x32,0xC2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/</em>“~”,94*/<br>};<br></pre></div><div>配置好相应的IO为推挽输出，硬件初始化即可。不过这里需要注意的是，这里使用GPIOB作为I80总线数据口，所以和Jtag口冲突（详见：<a href="http://www.ichanging.org/stm32-pcb.html" target="_blank" rel="noopener">stm32 最小系统</a>&nbsp;中jtag说明）。所以在配置IO时要将 jtag口的IO复用关闭：</div><div><pre class="brush:cpp;">在GPIO_Configuration()配置中：<br><br>GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);<br>// 改变指定管脚的映射 GPIO_Remap_SWJ_Disable SWJ 完全禁用（JTAG+SW-DP）;必须加上这句,否则会导致串口无法使用 被折腾了很久  原因不详<br>GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable , ENABLE);<br>// 改变指定管脚的映射 GPIO_Remap_SWJ_JTAGDisable ，JTAG-DP 禁用 + SW-DP 使能<br><br>注意：不要忘记在RCC_Configuration()中开启AFIO时钟，//AFIO时钟<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</pre></div><div> </div><div>在main.c中直接调用相关函数：</div><div><pre class="brush:cpp;">int main(void)<br>{<br>    //stm32 初始化<br>    RCC_Configuration();<br>    NVIC_Configuration();<br>    USART_Configuration();<br>    SPI_Configuration();<br>    GPIO_Configuration();<br><br>    LCD_Init();<br><br>    POINT_COLOR = BLACK;    //设置字体颜色<br><br>    LCD_ShowString(30,50,”Hello Dog .. “);<br><br>    printf(“\r\n test.. \r\n”);<br><br>    while(1);<br>}</pre></div><div><div>LCD显示效果：</div><div> </div><div><img src="/uploads/2012/09/2242973916.jpg" alt="lcd.jpg"></div></div><div> </div>
  </div>
</article>


    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/projects/">Projects</a></li>
         
          <li><a href="https://about.me/neilpan">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&text=stm32 驱动 TFT LCD"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&is_video=false&description=stm32 驱动 TFT LCD"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=stm32 驱动 TFT LCD&body=Check out this article: http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&title=stm32 驱动 TFT LCD"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/&name=stm32 驱动 TFT LCD&description=&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;LCD/LCM的基本概念&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;液晶显示器(Liquid Crystal Display: LCD)的构造是在两片平行的玻璃当中放置液态的晶体，两片玻璃中间有许多垂直和水平的细小电线，透过通电与否来控制杆状水晶分子改变方向，将光线折射出来产生画面。它包括了TFT,OLED,UFB,TFD,STN等类型的液晶显示屏.&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LCM(LCD Module)即LCD显示模组、液晶模块，是指将液晶显示器件，连接件，控制与驱动等外围电路，PCB电路板，背光源，结构件等装配在一起的组件。 购买相应的LCD Module时，会提供相关驱动IC资料，很多会有驱动代码。不过价格会比单买 LCD显示屏贵很多。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;LCD显示模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LCD的接口有多种，分类很细。主要看LCD的驱动方式和控制方式，目前手机上的彩色LCD的连接方式一般有这么几种：MCU模式，RGB模式，SPI模式，VSYNC模式，MDDI模式，DSI模式。MCU模式（也写成MPU模式的）。只有TFT模块才有RGB接口。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;MCU模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为主要针对单片机的领域在使用,因此得名.后在中低端手机大量使用,其主要特点是价格便宜的。MCU-LCD接口的标准术语是Intel提出的8080总线标准，因此在很多文档中用I80 来指MCU-LCD屏。主要又可以分为8080模式和6800模式，这两者之间主要是时序的区别。数据位传输有8位，9位，16位，18位，24位。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;MCU接口标准名称是I80，管脚的控制脚有5个：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;CS 片选信号&lt;/div&gt;&lt;div&gt;RS (置1为写数据,置0为写命令）&lt;/div&gt;&lt;div&gt;/WR （为0表示写数据) 数据命令区分信号&lt;/div&gt;&lt;div&gt;/RD （为0表示读数据）&lt;/div&gt;&lt;div&gt;RESET 复位LCD（ 用固定命令系列 0 1 0来复位)&lt;/div&gt;&lt;div&gt;数据总线 &amp;nbsp;DATA (8~24位)&amp;nbsp;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;RGB模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大屏采用较多的模式，数据位传输也有6位，16位和18位，24位之分。连线一般有：VSYNC，HSYNC，DOTCLK，CS，RESET，有的也需要RS，剩下就是数据线。它的优缺点正好和MCU模式相反。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MCU-LCD屏它与RGB-LCD屏主要区别在于显存的位置。RGB-LCD的显存是由系统内存充当的，因此其大小只受限于系统内存的大小，这样RGB-LCD可以做出较大尺寸，象现在4.3”只能算入门级，而MID中7”,10”的屏都开始大量使用。而MCU-LCD的设计之初只要考虑单片机的内存较小，因此都是把显存内置在LCD模块内部.然后软件通过专门显示命令来更新显存，因此MCU屏往往不能做得很大。同时显示更新速度也比RGB-LCD慢。显示数据传输模式也有差别。RGB屏只需显存组织好数据。启动显示后，LCD-DMA会自动把显存中的数据通过RGB接口送到LCM。而MCU屏则需要发送画点的命令来修改MCU内部的RAM（即不能直接写MCU屏的RAM）。所以RGB显示速度明显比MCU快，而且播放视频方面，MCU-LCD也比较慢。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于RGB接口的LCM，主机输出的直接是每个象素的RGB数据，不需要进行变换（GAMMA校正等除外），对于这种接口，需要在主机部分有个LCD控制器，以产生RGB数据和点、行、帧同步信号。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;MCU接口和RGB接口主要的区别是：&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MCU接口方式：显示数据写入DDRAM，常用于静止图片显示。控制简单方便，无需时钟和同步信号。要耗费GRAM，所以难以做到大屏（QVGA以上）。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RGB接口方式：显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。&lt;/div&gt;"><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2024 <a href="#">Neil Pan</a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/projects/">Projects</a></li>
         
          <li><a href="https://about.me/neilpan">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- Google Analytics -->

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-H068PLD02X"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-H068PLD02X');
    </script>


<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'neil-pan';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


