<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neil Pan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://neil-pan.com/"/>
  <updated>2024-07-11T12:49:21.221Z</updated>
  <id>http://neil-pan.com/</id>
  
  <author>
    <name>Neil Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>stm32 PVD 可编程电压监测器</title>
    <link href="http://neil-pan.com/2012/11/16/stm32-PVD-%E5%8F%AF%E7%BC%96%E7%A8%8B%E7%94%B5%E5%8E%8B%E7%9B%91%E6%B5%8B%E5%99%A8/"/>
    <id>http://neil-pan.com/2012/11/16/stm32-PVD-可编程电压监测器/</id>
    <published>2012-11-16T12:30:33.000Z</published>
    <updated>2024-07-11T12:49:21.221Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp; &nbsp; PVD (Programmable Votage Detector) ,即可编程电压监测器 。stm32库函数手册中没有细讲这个模块，只是在 PWM一章中列出了两个相关函数。但是这个功能在实际项目中会有较大的作用，</div><div>当电压过低时，对系统的一些数据使用掉电不丢失的 EEPROM 或&nbsp;Flash&nbsp;保存起来，同时对外设进行相应的保护操作。&nbsp;</div><div> </div><div>&nbsp; &nbsp; PVD的作用是监视供电电压，在供电电压下降到给定的阀值以下时，产生一个中断，通知软件做紧急处理。当供电电压又恢复到给定的阀值以上时，也会产生一个中断，通知软件供电恢复。供电下降的阀值与供电上升的PVD阀值有一个固定的差值，引入这个差值的目的是为了防止电压在阀值上下小幅抖动，而频繁地产生中断。</div><div> </div><div><div>&nbsp;&nbsp;&nbsp;&nbsp;用户在使用STM32时，可以利用其内部的PVD对VDD的电压进行监控，通过电源控制寄存器(PWR_CR)中的PLS[2:0]位来设定监控的电压值。</div><div> </div><div>&nbsp; &nbsp; PLS[2:0]位用于选择PVD监控电源的电压阀值：</div><div> </div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;000：2.2V</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;001：2.3V</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;010：2.4V</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;011：2.5V</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;100：2.6V</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;101：2.7V</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;110：2.8V</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;111：2.9V</div><div> </div><div>&nbsp; &nbsp; &nbsp;在电源控制/状态寄存器(PWR_CSR)中的PVDO标志用来表明VDD是高于还是低于PVD设定的电压阀值。该事件连接到外部中断的第16线，如果该中断在外部中断寄存器中被使能的，该事件就会产生中断。当VDD下降到PVD阀值以下和（或）当VDD上升到PVD阀值之上时，根据外部中断第16线的上升/下降边沿触发设置，就会产生PVD中断。</div><div> </div><div>&nbsp; &nbsp; 所以我做了一个实验，测试了stm32 的PVD功能。<strong>设定PVD监控阀值&nbsp;为2.8V,通过一个分压模块将5v电压通过一个可调电阻分压给stm32, 在PVD中断中设定点亮一个LED，调整可调电阻大小，校验PVD是否触发。</strong></div><a id="more"></a><div> </div><div>&nbsp; &nbsp; 实验结果如图：</div><div> </div><div>&nbsp; &nbsp; &nbsp;<img src="/uploads/2012/11/2368687438.jpg" alt="stm32-PVD.jpg"></div><div> </div><div><div>&nbsp; &nbsp; &nbsp;在供电只有2.02V时，触发了PVD的中断，点亮了LED。但是芯片一直处于复位中，检测电压不足后复位。</div><div> </div><div>stm32 PVD 代码:</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br><br>void RCC_Configuration(void);<br>void NVIC_Configuration(void);<br>void GPIO_Configuration(void);<br>void EXTI_Configuration(void);<br>void PVD_Configuration(void);<br><br>int main(void)<br>{<br><br>    //stm32 初始化<br>    RCC_Configuration();<br>    NVIC_Configuration();<br>    EXTI_Configuration();<br>    GPIO_Configuration();<br><br>    GPIO_SetBits(GPIOA,GPIO_Pin_8);<br><br>    PVD_Configuration();<br><br>    while(1);<br>}<br><br>void PVD_Configuration(void)<br>{<br>    PWR_PVDLevelConfig(PWR_PVDLevel_2V8);        // 设定监控阀值<br>    PWR_PVDCmd(ENABLE);<br><br>}<br><br>void EXTI_Configuration(void)<br>{<br>    EXTI_InitTypeDef EXTI_InitStructure;<br><br>    EXTI_InitStructure.EXTI_Line = EXTI_Line16;<br>    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<br>    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;   //表示电压从高电压下降到低于设定的电压阀值产生中断<br>    EXTI_InitStructure.EXTI_LineCmd = ENABLE;<br>    EXTI_Init(&amp;EXTI_InitStructure);<br>}<br><br>void NVIC_Configuration(void)<br>{<br>    NVIC_InitTypeDef NVIC_InitStructure;<br><br>#ifdef  VECT_TAB_RAM<br>    NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);<br>#else  /<em> VECT_TAB_FLASH  </em>/<br>    NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);<br>#endif<br><br>    /<em> Configure one bit for preemption priority </em>/<br>    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);<br><br>    NVIC_InitStructure.NVIC_IRQChannel =PVD_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>    NVIC_Init(&amp;NVIC_InitStructure);<br>}<br><br>void RCC_Configuration(void)<br>{<br>    ErrorStatus HSEStartUpStatus;<br><br>    //使能外部晶振<br>    RCC_HSEConfig(RCC_HSE_ON);<br>    //等待外部晶振稳定<br>    HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    //如果外部晶振启动成功，则进行下一步操作<br>    if (HSEStartUpStatus==SUCCESS)<br>    {<br>        //设置HCLK（AHB时钟）=SYSCLK<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br><br>        //PCLK1(APB1) = HCLK/2<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br><br>        //PCLK2(APB2) = HCLK<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br><br>        //FLASH时序控制<br>        //推荐值：SYSCLK = 0~24MHz   Latency=0<br>        //        SYSCLK = 24~48MHz  Latency=1<br>        //        SYSCLK = 48~72MHz  Latency=2<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        //开启FLASH预取指功能<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br><br>        //PLL设置 SYSCLK/1 <em> 9 = 8</em>1*9 = 72MHz<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        //启动PLL<br>        RCC_PLLCmd(ENABLE);<br>        //等待PLL稳定<br>        while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        //系统时钟SYSCLK来自PLL输出<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        //切换时钟后等待系统时钟稳定<br>        while (RCC_GetSYSCLKSource()!=0x08);<br>    }<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);        //开启PVD时钟<br><br>}<br><br>void GPIO_Configuration(void)<br>{<br>    GPIO_InitTypeDef GPIO_InitStructure;<br><br>    //LED<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br>}<br><br>//PVD中断程序<br>void PVD_IRQHandler(void)<br>{<br>    if(PWR_GetFlagStatus(PWR_FLAG_PVDO))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>    {<br>        GPIO_ResetBits(GPIOA,GPIO_Pin_8);<br>    }<br><br>    EXTI_ClearITPendingBit(EXTI_Line16);         //清除中断<br>}</pre><div> </div></div><div>在void EXTI_Configuration(void)中，对于</div><div>&nbsp;&nbsp;&nbsp;&nbsp;EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;</div><div>中的初始化值，根据你的需要进行修改，具体细节如下：</div><ul><li>&nbsp;&nbsp;&nbsp;&nbsp;EXTI_Trigger_Rising — 表示电压从高电压下降到低于设定的电压阀值产生中断；</li><li>&nbsp;&nbsp;&nbsp;&nbsp;EXTI_Trigger_Falling — 表示电压从低电压上升到高于设定的电压阀值产生中断；</li><li>&nbsp;&nbsp;&nbsp;&nbsp;EXTI_Trigger_Rising_Falling — 表示电压从高电压下降到低于设定的电压阀值、或从低电压上升到高于设定的电压阀值产生中断。<div> </div></li></ul></div></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp; &amp;nbsp; PVD (Programmable Votage Detector) ,即可编程电压监测器 。stm32库函数手册中没有细讲这个模块，只是在 PWM一章中列出了两个相关函数。但是这个功能在实际项目中会有较大的作用，&lt;/div&gt;&lt;div&gt;当电压过低时，对系统的一些数据使用掉电不丢失的 EEPROM 或&amp;nbsp;Flash&amp;nbsp;保存起来，同时对外设进行相应的保护操作。&amp;nbsp;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; PVD的作用是监视供电电压，在供电电压下降到给定的阀值以下时，产生一个中断，通知软件做紧急处理。当供电电压又恢复到给定的阀值以上时，也会产生一个中断，通知软件供电恢复。供电下降的阀值与供电上升的PVD阀值有一个固定的差值，引入这个差值的目的是为了防止电压在阀值上下小幅抖动，而频繁地产生中断。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;用户在使用STM32时，可以利用其内部的PVD对VDD的电压进行监控，通过电源控制寄存器(PWR_CR)中的PLS[2:0]位来设定监控的电压值。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; PLS[2:0]位用于选择PVD监控电源的电压阀值：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;000：2.2V&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;001：2.3V&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;010：2.4V&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;011：2.5V&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;100：2.6V&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;101：2.7V&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;110：2.8V&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;111：2.9V&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;在电源控制/状态寄存器(PWR_CSR)中的PVDO标志用来表明VDD是高于还是低于PVD设定的电压阀值。该事件连接到外部中断的第16线，如果该中断在外部中断寄存器中被使能的，该事件就会产生中断。当VDD下降到PVD阀值以下和（或）当VDD上升到PVD阀值之上时，根据外部中断第16线的上升/下降边沿触发设置，就会产生PVD中断。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 所以我做了一个实验，测试了stm32 的PVD功能。&lt;strong&gt;设定PVD监控阀值&amp;nbsp;为2.8V,通过一个分压模块将5v电压通过一个可调电阻分压给stm32, 在PVD中断中设定点亮一个LED，调整可调电阻大小，校验PVD是否触发。&lt;/strong&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Stm32 SWD 下载 调试配置</title>
    <link href="http://neil-pan.com/2012/09/19/Stm32-SWD-%E4%B8%8B%E8%BD%BD-%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://neil-pan.com/2012/09/19/Stm32-SWD-下载-调试配置/</id>
    <published>2012-09-19T09:24:14.000Z</published>
    <updated>2024-07-11T12:49:21.209Z</updated>
    
    <content type="html"><![CDATA[<div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;找到一篇比较好的 关于stm32 &nbsp;SWD模式 下载 调试 配置文章 整理如下：</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;我们比较常用的是Jlink下载器 ，这种下载器有一个缺点就是使用的Jtag 20PIN接口，太多的PIN会导致一些小型的PCB板很拥挤，也会增加布线的难度。 而使用SWD接口下载调试，只需要要使用4个PIN: &nbsp;GND, RST, SWDIO, SWDCLK ，而且下载速度可以达到10M/s，优势显而易见。</div><div> </div><div>&nbsp; &nbsp; 以下转自：<a href="http://www.openedv.com/posts/list/187.htm" target="_blank" rel="noopener">http://www.openedv.com/posts/list/187.htm</a></div><div>&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; 我们所使用的Jtag &nbsp;20PIN引脚图： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 相关原理图：</div><div> </div><div><img src="/uploads/2012/09/3300570723.jpg" alt="jtag IO定义.jpg">&nbsp;<img src="/uploads/2012/09/751556913.jpg" alt="Jtag 原理图.jpg"></div><div> </div><div><div> </div><div><strong>SWD 仿真模式概念简述</strong></div><div> </div><div>一、SWD 和传统的调试方式区别</div><ul><li><p>SWD 模式比 JTAG 在高速模式下面更加可靠。 在大数据量的情况下面 JTAG 下载程序会失败, 但是 SWD 发生的几率会小很多。基本使用 JTAG 仿真模式的情况下是可以直接使用 SWD 模式的, 只要你的仿真器支持。 所以推荐大家使用这个模式。<div> </div></p></li><li><p>在大家 GPIO 刚好缺一个的时候, 可以使用 SWD 仿真, 这种模式支持更少的引脚。<div> </div></p></li><li><p>在大家板子的体积有限的时候推荐使用 SWD 模式, 它需要的引脚少, 当然需要的 PCB 空间就小啦！ 比如你可以选择一个很小的 2.54 间距的 5 芯端子做仿真接口。<div> </div></p></li></ul><a id="more"></a><div> </div><div>二、仿真器对 SWD 模式支持情况</div><div> </div><div>1. 市面上的常用仿真器对 SWD 模式支持情况</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) JLINKV6 支持 SWD 仿真模式， 速度较慢。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) JLINKV7 比较好的支持 SWD 仿真模式, 速度有了明显的提高，速度是 JLINKV6 的 6 倍。&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) JLINKV8 非常好的支持 SWD 仿真模式, 速度可以到 10M。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4) ULINK1 不支持 SWD 模式。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5) 盗版 ULINK2 非常好的支持 SWD 模式， 速度可以达到 10M。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6) 正版 ULINK2 非常好的支持 SWD 模式， 速度可以达到 10M。</div><div> </div><div>2. SWD 硬件接口上的不同</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) JLINKV6 需要的硬件接口为: GND, RST, SWDIO, SWDCLK</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) JLINKV7 需要的硬件接口为: GND, RST, SWDIO, SWDCLK</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) JLINKV8 需要的硬件接口为: VCC, GND, RST, SWDIO, SWDCLK （注：下面有我自己用JLINKV8的实际连线及相应实验结果）</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4) ULINK1 不支持 SWD 模式</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5) 盗版 ULINK2 需要的硬件接口为: GND, RST, SWDIO, SWDCLK</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6) 正版 ULINK2 需要的硬件接口为: GND, RST, SWDIO, SWDCLK</div><div> </div><div>&nbsp; &nbsp; 由此可以看到只有 JLINKV8 需要 5 个引脚， 即多了一个VCC引脚，其好处是: 仿真器对目标板子的仿真需要用到 RST 引脚, 使用仿真器内部的 VCC 作这个功能其实并不是非常美妙。 因此，JLINKV8 选择了只和目标板共 GND, 但不共 VCC。 因此我觉得这种模式最合理, 当然通常情况下仿真器和目标板共 GND 和 VCC 是没有错的。</div><div> </div><div>三、在 MDK 中SWD 模式的设置</div><div> </div><div>&nbsp; &nbsp; 在调试仿真的时候用J-LINK的Cortex-M3方式已经足够，并且在MDK下他的功能已经做得非常的好，用标准20脚的JTAG下载，速度是非常的快，一般初学者都是这样做的。但是SWD方式似乎速度更快、更加方便、简捷、，对于项目中对板子空间要求严格、I/O口资源紧张的用户来说更加的有利，正常的JTAG需要20管脚，而J-Link 的SWD只需要2根线（PA13/JTMS/SWDIO、PA14/JTCK/SWCLK）就够了（加上电源线也就4根），这样就节省了3个I/O口（PA15/JTDI、PB3/JTDO、PB4/JNTRST）为其它所用，并且可节省一部分板子的空间(只需4个口就可以了)。</div><div> </div><div>&nbsp; &nbsp; 下面我说一下SWD两线仿真的一些步骤、注意事项及需要注意的问题。</div><div> </div><div>&nbsp; &nbsp; 接口的连接如下：将JLINK的1、7、9、20分别与自己的开发板上JTAG的VCC、JTMS、JTCK、GND用杜邦线相连即可！</div><div> </div><div>&nbsp; &nbsp; 接下来告诉大家怎么使用SWD设置：</div><div> </div><div>打开工程OPTION设置：</div><div> </div><div><img src="/uploads/2012/09/1957487761.jpg" alt="SWD 设置.jpg"></div><div> </div><div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设置中按照上图设置成 SWD 模式, 速度你可以按照你的实际需求来设置, 如果你的板子供电系统不是特别稳定, 纹波比较大或者仿真线比较长可以设置成 500K 或者 1M，如果环境很好当然可以选择 10M , 当然速度会飞起来。</div><div> </div><div>&nbsp; &nbsp; 记得不要忽略了左下方的那个USB还是 TCP 模式, 当然我们是 USB 模式, 因为有的时候默认是 TCP 模式, 这个时候我们忽略这个设置后会仿真常常连接不上的。</div><div> </div><div>按SW方式来调试，实际需要接1，7，9，15，20脚，某些资料上说的需要6个脚（第13脚SWO也需要连上）是不对的，SWO不需要连接。</div><div> </div><div>我的Jilnk 和 开发板 接线图：</div><div> </div><div><img src="/uploads/2012/09/103422703.jpg" alt="Jtag-Jlink-接法.jpg"></div><div> </div><ul><li>白色线 : 3.3v &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>黑色线 : GND &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>灰色线：SWIO</li><li>紫色线：SWCLK<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于是否要接上 Reset 引脚的问题 我测试时并没有接上 &nbsp;可以正常下载和调试 &nbsp;而且下载速度设置为 10Mhz &nbsp;仍然没有问题 &nbsp;速度的确快了很多 。。</div><div> </div></li></ul></div></div><div> </div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;找到一篇比较好的 关于stm32 &amp;nbsp;SWD模式 下载 调试 配置文章 整理如下：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们比较常用的是Jlink下载器 ，这种下载器有一个缺点就是使用的Jtag 20PIN接口，太多的PIN会导致一些小型的PCB板很拥挤，也会增加布线的难度。 而使用SWD接口下载调试，只需要要使用4个PIN: &amp;nbsp;GND, RST, SWDIO, SWDCLK ，而且下载速度可以达到10M/s，优势显而易见。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 以下转自：&lt;a href=&quot;http://www.openedv.com/posts/list/187.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.openedv.com/posts/list/187.htm&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 我们所使用的Jtag &amp;nbsp;20PIN引脚图： &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 相关原理图：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/09/3300570723.jpg&quot; alt=&quot;jtag IO定义.jpg&quot;&gt;&amp;nbsp;&lt;img src=&quot;/uploads/2012/09/751556913.jpg&quot; alt=&quot;Jtag 原理图.jpg&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;SWD 仿真模式概念简述&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;一、SWD 和传统的调试方式区别&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SWD 模式比 JTAG 在高速模式下面更加可靠。 在大数据量的情况下面 JTAG 下载程序会失败, 但是 SWD 发生的几率会小很多。基本使用 JTAG 仿真模式的情况下是可以直接使用 SWD 模式的, 只要你的仿真器支持。 所以推荐大家使用这个模式。&lt;div&gt; &lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在大家 GPIO 刚好缺一个的时候, 可以使用 SWD 仿真, 这种模式支持更少的引脚。&lt;div&gt; &lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在大家板子的体积有限的时候推荐使用 SWD 模式, 它需要的引脚少, 当然需要的 PCB 空间就小啦！ 比如你可以选择一个很小的 2.54 间距的 5 芯端子做仿真接口。&lt;div&gt; &lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 UCGUI 完美移植</title>
    <link href="http://neil-pan.com/2012/09/16/stm32-UCGUI-%E5%AE%8C%E7%BE%8E%E7%A7%BB%E6%A4%8D/"/>
    <id>http://neil-pan.com/2012/09/16/stm32-UCGUI-完美移植/</id>
    <published>2012-09-15T20:13:21.000Z</published>
    <updated>2024-07-11T12:49:21.227Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UCGUI是一种嵌入式应用中的图形支持系统。它设计用于为任何使用LCD图形显示的应用提供高效的独立于处理器及LCD控制器的图形用户接口，它适用单任务或是多任务系统环境, 并适用于任意LCD控制器和CPU下任何尺寸的真实显示或虚拟显示。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的设计架构是模块化的，由不同的模块中的不同层组成，由一个LCD驱动层来包含所有对LCD的具体图形操作。UCGUI可以在任何的CPU上运行，因为它是100%的标准C代码编写的。</div><div> </div><div>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;类似程序还有国产的一个MINIGUI （<a href="http://www.minigui.com/zhcn/" target="_blank" rel="noopener">http://www.minigui.com/zhcn/</a>），MiniGUI 是一个自由软件项目。其目标是提供一个快速、稳定、跨操作系统的图形用户界面（GUI）支持系统，尤其是基于 Linux/uClinux、eCos 以及其他传统 RTOS（如 VxWorks、ThreadX、uC/OS-II、Nucleus 等）的实时嵌入式操作系统。有机会尝试下，支持下国产，毕竟国内这样的公司不多。。</div><div> </div><div>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;这里移植的UCGUI3.90a版本，虽然已经有更新的版本，比如UCGUI3.98、甚至4.04版本。但是目前来说只有这个版本的代码是最全的，包括了JPEG , MULTILAYER , MEMDEV ,AntiAlias等模块。一直想尝试做一个数码相册，JEPG模块自然少不了，所以移植了这个版本。</div><div> </div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="/uploads/2012/09/3915051259.zip" title="UCGUI390a.zip">UCGUI390a 下载</a></div><a id="more"></a><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个移植过程，让LCD显示图案倒是没花多少时间，资料也比较多，但是在移植触摸屏的时候卡了好几天，然后又是 UCGUI 指针图标 移动有重影(LCD读取像素颜色函数有问题)。。。总之移植是个累人的活 &nbsp;</div><div> </div><div>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;首先需要保证你的LCD驱动和触摸屏驱动是有效的，如果你的LCD也是ili93xx 控制器 XPT2046控制器的触摸屏可以参考&nbsp;<a href="http://www.ichanging.org/stm32-lcd.html" target="_blank" rel="noopener">stm32 驱动 TFT LCD</a>&nbsp;&nbsp;<a href="http://www.ichanging.org/stm32-xpt2046.html" target="_blank" rel="noopener">stm32 驱动 触摸屏</a>&nbsp;两篇文章</div><div> </div><div>&nbsp; &nbsp; &nbsp; &nbsp; UCGUI的文件数量很大，主要用到UCGUI390a/Start/Config 和 UCGUI390a/Start/GUI两个文件夹下文件，不过文件数量也已经很多了 。。。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相关文件介绍如下：</div><div><img src="/uploads/2012/09/1767023912.png" alt="ucgui files.png"></div><div>&nbsp; &nbsp; 将Config和GUI下所有文件加入工程，MDK中新建工程需要划分好结构，这是UCGUI官方推荐的结构：</div><div>&nbsp;&nbsp;</div><div><img src="/uploads/2012/09/2583809479.png" alt="ucgui Project.png"></div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPEG, MemDev , MultiLayer ,&nbsp;Widget , Wm 这5 个文件夹的内容可以暂时不加入MDK工程。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这些文件起到的是扩展功能，在移植阶段可以先不添加，等到以后用到其中的功能时再选择添加。但是建议都添加进去，避免遇到各种无解问题。。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然前提是在配置时要把相应的功能开关关掉，在下面的步骤中会提到。&nbsp; &nbsp;</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConverMono , ConverColor ,Core ,Font 这四个目录下的文件是不用修改的。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要修改的文件在LCDDriver ，Config 这两个目录下。</div><div> </div><div>&nbsp; &nbsp; LCDDriver 是LCD的驱动接口函数文件，需要将自己的LCD驱动函数提供给UCGUI调用。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;需要提供3个LCD底层驱动函数：</div><ul><li>void LCD_L0_SetPixelIndex(int x, int y, int PixelIndex) &nbsp;LCD画点函数,&nbsp;用指定颜色填充一个像素</li><li>unsigned int LCD_L0_GetPixelIndex(int x, int y) &nbsp;LCD读取定点颜色函数，读取一个像素点的16位RGB颜色值</li><li>void LCD_L0_FillRect(int x0, int y0, int x1, int y1) &nbsp;矩形填充函数，用指定颜色填充一个矩形 。这个函数也可以不改 使用UCGUI的函数，用一个一个的像素点填充成一个矩形。也可以在底层驱动根据像素个数直接往GRAM 中写数据，封装成函数，供这个函数调用。速度会快很多。<div>&nbsp; &nbsp;其他的画线画图形函数，也可以同样优化。</div><div>&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp;LCDDriver&nbsp;下有三个文件，&nbsp;LCDDummy.c 、 LCDNull.c 和LCDWin.c。 这三个都是UCGUI LCD接口模板文件。功能一样，只是移植时修改的细节不一样。我们可以选用其中一个，稍作修改作为接口文件。以LCDDummy.c为例：</div><div><pre class="brush:cpp;">#include “LCD_Private.h”      /<em> private modul definitions &amp; config </em>/<br>#include “GUI_Private.h”<br>#include “GUIDebug.h”</pre></div></li></ul><p>/<em>#if (LCD_CONTROLLER == -1) \<br>    &amp;&amp; (!defined(WIN32) | defined(LCD_SIMCONTROLLER))</em>/    //必须注释，否则不会编译</p><p>#include “ili93xx.h”                //包含你的LCD驱动函数声明</p><p>#if (LCD_CONTROLLER == -1)       //这句对应Config/LCDConf.h</p><p>……..<br>……..</p><p>void LCD_L0_SetPixelIndex(int x, int y, int PixelIndex) {</p><pre><code>  POINT_COLOR = PixelIndex;      //我的画点函数使用了一个全局变量设定颜色LCD_DrawPoint(x,y);                    //画点函数</code></pre><p>}</p><p>……..<br>……..</p><p>unsigned int LCD_L0_GetPixelIndex(int x, int y) {</p><pre><code>return LCD_ReadPoint(x,y);     //我的读取像素颜色函数</code></pre><p>}<br>……..<br>……..</p><p>void LCD_L0_FillRect(int x0, int y0, int x1, int y1) {</p><p>  LCD_Fill(x0,y0,x1,y1,LCD_COLORINDEX);&nbsp;&nbsp;&nbsp;&nbsp;//填充矩形函数<br>  /<em>for (; y0 &lt;= y1; y0++) {<br>    LCD_L0_DrawHLine(x0, y0, x1);<br>  }</em>/<br>}<br><div>UCGUI提供了一些LCD控制器的驱动函数，但是这种配置方法，可以适用于任何控制IC。</div><div> </div><div>到这就算完成三分之一了，接下来修改Config文件夹下文件，Config下有三个文件：</div><div>&nbsp;&nbsp;&nbsp;&nbsp;GUIConf.h&nbsp;&nbsp;&nbsp;&nbsp; LCDConf.h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GUITouchConf.h &nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还需要加入一个GUI_X.c文件，要不然编译的时候会有错误。直接复制UCGUI390a\Sample\GUI_X\GUI_X.c即可。如果打开了触摸功能还需要加入一个UCGUI390a\Sample\GUI_X\GUI_X_Touch.c 。</div><div>&nbsp; &nbsp; 这三个文件是UCGUI的上层配置文件，也就是GUI 一些功能的开关。</div><div> </div><div>&nbsp; &nbsp; GUIConf.h:</div><div><pre class="brush:cpp;">#ifndef GUICONF_H</pre></div></p><p>#define GUICONF_H</p><p>#define GUI_OS                    (0)  /<em> 操作系统的支持，当用到ucos 时需要打开  Compile with multitasking support </em>/</p><p>#define GUI_SUPPORT_TOUCH         (1)  /<em> 触摸屏的支持        Support a touch screen (req. win-manager) </em>/</p><p>#define GUI_SUPPORT_UNICODE       (0)  /<em> 用汉字库时再打开 Support mixed ASCII/UNICODE strings </em>/</p><p>#define GUI_DEFAULT_FONT          &amp;GUI_Font6x8         /<em> 定义字体大小     </em>/</p><p>#define GUI_ALLOC_SIZE          12500      /<em>分配的动态内存空间  Size of dynamic memory … For WM and memory devices</em>/</p><p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>*</p><ul><li>Configuration of available packages<br>*/</li></ul><p>#define GUI_WINSUPPORT            1  /<em> 窗口功能支持  要使用指针图标 必须打开     Window manager package available </em>/</p><p>#define GUI_SUPPORT_MEMDEV        1  /<em> 内存管理     Memory devices available </em>/</p><p>#define GUI_SUPPORT_AA            1  /<em> 抗锯齿功能，打开后可以提高显示效果        Anti aliasing available </em>/</p><p>#endif  /<em> Avoid multiple inclusion </em>/<div>&nbsp; &nbsp; &nbsp; &nbsp; LCDConf.h</div><div><pre class="brush:cpp;">#ifndef LCDCONF_H</pre></div></p><p>#define LCDCONF_H</p><p>#define LCD_XSIZE      (240)   /<em> lcd 的水平分辨率  X-resolution of LCD, Logical coor. </em>/</p><p>#define LCD_YSIZE      (320)   /<em> lcd 的垂直分辨率  Y-resolution of LCD, Logical coor. </em>/</p><p>#define LCD_BITSPERPIXEL   (16)       /<em> 16位颜色RGB值 颜色深度</em>/</p><p>#define LCD_SWAP_RB        (1)     /<em>红蓝反色交换 </em>/</p><p>/<em> lcd 控制器的具体型号   </em></p><ul><li>设置为 -1时 会编译LCDDriver 下 LCDDummy.c   </li><li>设置为 -2时 会编译LCDDriver 下 LCDNull.c<br>*</li><li>还需要修改LCDDriver 下文件的宏定义 才可以被编译</li><li>eg. LCDDummy.c：<br>*</li><li>#if (LCD_CONTROLLER == -1) &amp;&amp; (!defined(WIN32) |defined(LCD_SIMCONTROLLER))</li><li>改为    </li><li>#if    (LCD_CONTROLLER == -1)<br>*/<br>#define LCD_CONTROLLER  -1        //设置为-1-2，因为UCGUI没有相应LCD 控制IC驱动</li></ul><p>#define LCD_INIT_CONTROLLER() LCD_Config();        //绑定相关LCD底层驱动的初始化函数<div>配置完这两个文件，如果不启用触摸屏的话，UCGUI已经可以正常运行。</div><div> </div><div>下面细讲下<strong>UCGUI触摸屏的配置，</strong>这个折腾了我好几天的“简单”问题。。</div><div> </div><div>首先配置GUIToucConf.h</div><div><pre class="brush:cpp;">#ifndef GUITOUCH_CONF_H</pre></div></p><p>#define GUITOUCH_CONF_H</p><p>/<em> 正点原子LCD相关参数,不同LCD值不同，需另测 </em>/</p><p>#define GUI_TOUCH_AD_LEFT          120     //最左边x轴的AD值,非坐标值</p><p>#define GUI_TOUCH_AD_RIGHT             1870    //最右边x轴的AD值</p><p>#define GUI_TOUCH_AD_TOP            90      //最上边y轴的AD值</p><p>#define GUI_TOUCH_AD_BOTTOM         1850    //最下边y轴的AD值</p><p>#define GUI_TOUCH_SWAP_XY    0    //不允许翻转</p><p>#define GUI_TOUCH_MIRROR_X   0</p><p>#define GUI_TOUCH_MIRROR_Y   0</p><p>#endif /<em> GUITOUCH_CONF_H </em>/<div>UCGUI 触摸屏驱动接口函数文件 GUI_X_Touch.c ：</div><div><pre class="brush:cpp;">#include “GUI.h”</pre></div></p><p>#include “GUI_X.h”</p><p>#include “xpt2046.h”<br>//#include “stdio.h”</p><p>void GUI_TOUCH_X_ActivateX(void) {    //不用配置<br>}</p><p>void GUI_TOUCH_X_ActivateY(void) {  //不用配置<br>}</p><p>int  GUI_TOUCH_X_MeasureX(void) {</p><pre><code>u16 var = ADS_Read_XY(CMD_RDX);  //读取X轴的AD转换值  不是坐标值//printf(&quot;\r\n MeasureX is %d \r\n&quot;,var);  return var;          </code></pre><p>}</p><p>int  GUI_TOUCH_X_MeasureY(void) {</p><pre><code>u16 var = ADS_Read_XY(CMD_RDY);   //读取Y轴的AD转换值//printf(&quot;\r\n MeasureY is %d \r\n&quot;,var);  return var;        </code></pre><p>}<div>还有最关键的一点就是，何时触发UCGUI调用这些函数，测量AD值，定位触摸点的坐标。很多文档都没清这个问题，可以使用两种方法来触发：</div></p><ul><li>&nbsp; &nbsp; 设定触摸屏的一个引脚为外部触发，触摸点击时，电平变化触发中断，在中断函数中调用GUI_TOUCH_Exec()函数，让UCGUI更新TOUCH时间数据。</li><li>&nbsp; &nbsp; 设定一个10ms的定时器中断不断查询，在中断函数中调用GUI_TOUCH_Exec()。<div>其实第一个方案，看似更为合适，不占用CPU，让CPU可以处理其他事情。但是UCGUI的触摸事件，一次触摸只会读取一个轴的AD值，也就是说一次读取X轴AD,下一次在读取Y轴AD值。这样导致获得的数据都是错误的。uCGUI 有处理的抖动的函数_StoreUnstable(x, y)，会将误差较大的数据过滤，两次点击事件时间很短的话，也至少会是一次正确坐标，一次错误坐标 ..</div><div>&nbsp; &nbsp; eg.&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;点击事件1： &nbsp;MeasureY AD is 736 &nbsp;, coordinate is &nbsp; &nbsp; X = 134261972 ,Y= 134261972&nbsp;</div><div> </div><div>&nbsp; &nbsp; &nbsp; &nbsp;点击事件2：&nbsp;MeasureX AD is 576 &nbsp; , coordinate is &nbsp; &nbsp; X = 62 ,Y= 117&nbsp;</div><div> </div><div>而且外部中断的方法，只能获得触摸点击的事件，无法获得触摸移动的事件。所以采用了查询的方法。。使用Stm32的滴答定时器 产生一个10ms的中断，在中断函数中调用UCGUI更新函数。。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;stm32f10x_it.c：</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<br>#include “GUI.h”</pre></div></li></ul><p>void SysTick_Handler(void)<br>{<br>    GUI_TOUCH_Exec();         //调用UCGUI TOUCH相关函数<br>    GUI_Exec();                 //GUI事件更新</p><p>}<br><div>这里还调用了GUI_Exec（）函数，让UCGUI更新,这个函数必须要加上，有文档说还需要修改GUI_TOUCH_DriverAnalog.c 下的一些函数 其实没必要 …</div><div> </div><div>配置完成后，在main.c中初始化GUI,调用相关函数<strong>实现显示一个指针鼠标，跟随触摸移动</strong>。。</div><div> </div><div>main.c:</div><div><pre class="brush:cpp;">#include “common.h”</pre></div></p><p>#include “GUI.h”</p><p>void Delay(u32 us)<br>{<br>    u32 time=100*us/7;<br>    while(–time);<br>}</p><p>int main(void)<br>{<br>    //stm32 初始化<br>    RCC_Configuration();<br>    NVIC_Configuration();<br>    USART_Configuration();<br>    SPI_Configuration();<br>    GPIO_Configuration();</p><pre><code>GUI_Init();Delay(100000);GUI_SetBkColor(GUI_RED); //设置背景颜色  GUI_SetColor(GUI_WHITE); //设置前景颜色，及字体和绘图的颜色GUI_Clear(); //按指定颜色清屏GUI_DispStringAt(&quot;Hello World ..&quot;,10,10); //显示字符GUI_CURSOR_Show();       //显示鼠标,测试触摸屏     必须打开窗口功能 GUI_WINSUPPORTDelay(1000000);              //必须稍加延时,否则会白屏    SysTick_Config(720000);    //10mswhile(1);</code></pre><p>}<div> </div><div>编译如果没出错，可能你就成功了。但往往没有那么简单,很可能还有第三步，也很可能是最耗时的一步——调试 。。</div><div> </div><div>这里再附上一份整理的UCGUI API函数列表：<a href="/uploads/2012/09/4242376293.pdf" title="UCGUI函数表 .pdf">UCGUI函数表 .pdf</a></div><div> </div><div>UCGUI 指针跟随效果: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UCGUI Xeye Demo 效果:</div><div> </div><div><img src="/uploads/2012/09/3295526051.png" alt="ucgui point.png"></div><div>&nbsp; &nbsp; &nbsp; &nbsp;<img src="/uploads/2012/09/1844886028.png" alt="ucgui xeye.png">&nbsp; &nbsp; &nbsp;&nbsp;</div><div> </div></p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;UCGUI是一种嵌入式应用中的图形支持系统。它设计用于为任何使用LCD图形显示的应用提供高效的独立于处理器及LCD控制器的图形用户接口，它适用单任务或是多任务系统环境, 并适用于任意LCD控制器和CPU下任何尺寸的真实显示或虚拟显示。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;它的设计架构是模块化的，由不同的模块中的不同层组成，由一个LCD驱动层来包含所有对LCD的具体图形操作。UCGUI可以在任何的CPU上运行，因为它是100%的标准C代码编写的。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;类似程序还有国产的一个MINIGUI （&lt;a href=&quot;http://www.minigui.com/zhcn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.minigui.com/zhcn/&lt;/a&gt;），MiniGUI 是一个自由软件项目。其目标是提供一个快速、稳定、跨操作系统的图形用户界面（GUI）支持系统，尤其是基于 Linux/uClinux、eCos 以及其他传统 RTOS（如 VxWorks、ThreadX、uC/OS-II、Nucleus 等）的实时嵌入式操作系统。有机会尝试下，支持下国产，毕竟国内这样的公司不多。。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这里移植的UCGUI3.90a版本，虽然已经有更新的版本，比如UCGUI3.98、甚至4.04版本。但是目前来说只有这个版本的代码是最全的，包括了JPEG , MULTILAYER , MEMDEV ,AntiAlias等模块。一直想尝试做一个数码相册，JEPG模块自然少不了，所以移植了这个版本。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;a href=&quot;/uploads/2012/09/3915051259.zip&quot; title=&quot;UCGUI390a.zip&quot;&gt;UCGUI390a 下载&lt;/a&gt;&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 DA 数模转换</title>
    <link href="http://neil-pan.com/2012/09/11/stm32-DA-%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2/"/>
    <id>http://neil-pan.com/2012/09/11/stm32-DA-数模转换/</id>
    <published>2012-09-11T14:34:30.000Z</published>
    <updated>2024-07-11T12:49:21.216Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp;&nbsp;&nbsp;&nbsp;stm32并不是所有的型号都有DAC功能，只有stm32f103xC/D/E系列 才有DAC转换功能。由于库函数手册中没有相关说明，所以只能通过在MDK提供的相关库文件 stm32f10x_dac.c 中找到相应的DAC函数，做了一番尝试。</div><div>&nbsp; &nbsp; 折腾了一天，实现了DAC的转换和三角波的输出。我使用的是 stm32rct6的芯片，有两个DAC通道，在PA4和PA5两个引脚上。</div><div> </div><div>&nbsp; &nbsp; DAC的库函数配置相关参数说明：</div><div><pre class="brush:cpp;">void DAC_Configuration(void)<br>{<br>    DAC_InitTypeDef    DAC_InitStructure;<br><br>     DAC_InitStructure.DAC_Trigger = DAC_Trigger_Software;     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //软件触发,不使用定时器 或者外部中断等触发<br>      DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;   //不产生三角波（DAC_Wave_Triangle） 或者 噪声波（DAC_Wave_Noise）<br>      DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;       //提高驱动能力可以打开缓冲<br>      DAC_Init(DAC_Channel_1, &amp;DAC_InitStructure);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DAC_DMACmd(DAC_Channel_1, DISABLE);        //不使用DMA<br>    DAC_Cmd(DAC_Channel_1, ENABLE);<br><br>}</pre><div>&nbsp; &nbsp;&nbsp;&nbsp;DAC_InitStructure.DAC_Trigger&nbsp;：触发方式。可选的外部触发源一共有八个。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;六个是定时器触发：TIM2，TIM4，TIM5，TIM6，TIM7和TIM8。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;剩下两个分别是：EXTI线路9和软件触发。</div><div> </div><div>&nbsp; &nbsp; &nbsp;DAC_InitStructure.DAC_WaveGeneration：波形发生器。STM32内部集成了两个幅度可调的波形发生器，可以产生三角波（DAC_Wave_Triangle）和噪声波（DAC_Wave_Noise）。如果我们使用自定义的缓冲区输出波形，就不需要配置这个参数或者使其为DAC_WaveGeneration_None.</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;DAC_InitStructure.DAC_OutputBuffer：即是否使用输出缓存。输出缓存的功能主要用来减小输出阻抗，是STM32的DAC无需外部运放就可以直接驱动负载。</div><div> </div><div>相关参数在stm32f10x_dac.h中可以找到。</div><div> </div><div>这里实现：</div><ul><li><strong>&nbsp; &nbsp;&nbsp;设置DAC输出固定电压</strong></li><li><strong>&nbsp; &nbsp;&nbsp;设置DAC输出三角波形</strong><div> </div></li></ul><a id="more"></a><div>stm32 DA 数模转换代码：</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br><br>#define  DAC_TEST_1 1          //设置DAC输出固定电压<br>#define  DAC_TEST_2 0            //设置DAC输出三角波形<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void USART_Configuration(void);<br>void DAC_Configuration(void);<br>void TIM_Configuration(void);<br><br>void Delay(u32 us);<br><br>int main(void)<br>{<br>      RCC_Configuration();<br>    USART_Configuration();<br>      GPIO_Configuration();<br>    DAC_Configuration();<br><br>#if DAC_TEST_1<br><br>    DAC_SetChannel1Data(DAC_Align_12b_R, 4095);        //刷新DA值,数据右对齐 取值范围 0~ 4095<br>                                                    //板子上接的参考电压时3.3v 所以4095时为3.3v<br>    DAC_SoftwareTriggerCmd(DAC_Channel_1,ENABLE);   //软件触发,DA值更新<br><br>    printf(“\r\n The Value is : %d \r\n”,DAC_GetDataOutputValue(DAC_Channel_1));  //读取DAC引脚输出的值<br><br>#elif DAC_TEST_2<br><br>       TIM_Configuration();<br><br>#endif<br><br>    while(1);<br><br>}<br><br>void DAC_Configuration(void)<br>{<br>    DAC_InitTypeDef    DAC_InitStructure;<br><br>#if DAC_TEST_1<br><br>     DAC_InitStructure.DAC_Trigger = DAC_Trigger_Software;               //软件触发,不使用定时器 或者外部中断等触发<br>      DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;   //不产生三角波（DAC_Wave_Triangle） 或者 噪声波（DAC_Wave_Noise）<br>      DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;       //提高驱动能力可以打开缓冲<br>      DAC_Init(DAC_Channel_1, &amp;DAC_InitStructure);<br><br>#elif DAC_TEST_2<br><br>    DAC_InitStructure.DAC_Trigger = DAC_Trigger_T2_TRGO;    //选择定时器2作外部触发源<br>      DAC_InitStructure.DAC_WaveGeneration =DAC_Wave_Triangle;   //产生三角波<br>    DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude = DAC_TriangleAmplitude_2047; //三角波的高为2047  最高可以为4095<br>      DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Disable;       //无输出缓冲 提高驱动能力可以打开缓冲<br>      DAC_Init(DAC_Channel_1, &amp;DAC_InitStructure);<br><br>#endif<br><br>    DAC_DMACmd(DAC_Channel_1, DISABLE);        //不使用DMA<br><br>    DAC_Cmd(DAC_Channel_1, ENABLE);<br><br>}<br><br>void TIM_Configuration(void)<br>{<br>    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;<br><br>    TIM_TimeBaseStructInit(&amp;TIM_TimeBaseStructure);<br><br>    TIM_TimeBaseStructure.TIM_Period = 72;          //初装值 72 每秒产生1 000 000次更新<br>    TIM_TimeBaseStructure.TIM_Prescaler = 0x0;<br>    TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;<br>    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);<br><br>    TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_Update); //使用更新事件作为触发输出<br><br>       TIM_Cmd(TIM2, ENABLE);<br>}<br><br>void Delay(u32 us)         //vu32 1us一次<br>{<br>    u32 time=100<em>us/7;<br>    while(–time);<br>}<br><br>void GPIO_Configuration(void)<br>{<br>      GPIO_InitTypeDef GPIO_InitStructure;<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;<br>      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br>}<br><br>void RCC_Configuration(void)<br>{<br>    /</em> 定义枚举类型变量 HSEStartUpStatus <em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /</em> 复位系统时钟设置<em>/<br>      RCC_DeInit();<br>      /</em> 开启HSE<em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /</em> 等待HSE起振并稳定<em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /</em> 判断HSE起是否振成功，是则进入if()内部 <em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /</em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 <em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /</em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 <em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /</em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 <em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /</em> 设置FLASH延时周期数为2 <em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /</em> 使能FLASH预取缓存 <em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /</em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz <em> 9 = 72MHz </em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /<em> 使能PLL </em>/<br>        RCC_PLLCmd(ENABLE);<br>        /<em> 等待PLL输出稳定 </em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /<em> 选择SYSCLK时钟源为PLL </em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /<em> 等待PLL成为SYSCLK时钟源 </em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /<em> 打开APB2总线上的GPIOA时钟</em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO|RCC_APB2Periph_USART1, ENABLE);<br><br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC|RCC_APB1Periph_TIM2 , ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>int fputc(int ch,FILE *f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br></pre><div> </div><div><div>&nbsp;我的板子上stm32输出三角波的效果不是很好，可能是板子的原因。这里使用詹小七同学的程序调试图片 &nbsp;</div><div>&nbsp;感谢詹小七同学的调试 符合标准的三角波形 效果如下：</div><div> </div><div><img src="/uploads/2012/09/3616089477.jpg" alt="dac.jpg"></div><div> </div></div></div><div> </div></div><div> </div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stm32并不是所有的型号都有DAC功能，只有stm32f103xC/D/E系列 才有DAC转换功能。由于库函数手册中没有相关说明，所以只能通过在MDK提供的相关库文件 stm32f10x_dac.c 中找到相应的DAC函数，做了一番尝试。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 折腾了一天，实现了DAC的转换和三角波的输出。我使用的是 stm32rct6的芯片，有两个DAC通道，在PA4和PA5两个引脚上。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; DAC的库函数配置相关参数说明：&lt;/div&gt;&lt;div&gt;&lt;pre class=&quot;brush:cpp;&quot;&gt;void DAC_Configuration(void)&lt;br&gt;{&lt;br&gt;    DAC_InitTypeDef    DAC_InitStructure;&lt;br&gt;&lt;br&gt;     DAC_InitStructure.DAC_Trigger = DAC_Trigger_Software;     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //软件触发,不使用定时器 或者外部中断等触发&lt;br&gt;      DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;   //不产生三角波（DAC_Wave_Triangle） 或者 噪声波（DAC_Wave_Noise）&lt;br&gt;      DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;       //提高驱动能力可以打开缓冲&lt;br&gt;      DAC_Init(DAC_Channel_1, &amp;amp;DAC_InitStructure);&lt;br&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DAC_DMACmd(DAC_Channel_1, DISABLE);        //不使用DMA&lt;br&gt;    DAC_Cmd(DAC_Channel_1, ENABLE);&lt;br&gt;&lt;br&gt;}&lt;/pre&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;DAC_InitStructure.DAC_Trigger&amp;nbsp;：触发方式。可选的外部触发源一共有八个。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;六个是定时器触发：TIM2，TIM4，TIM5，TIM6，TIM7和TIM8。&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;剩下两个分别是：EXTI线路9和软件触发。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;DAC_InitStructure.DAC_WaveGeneration：波形发生器。STM32内部集成了两个幅度可调的波形发生器，可以产生三角波（DAC_Wave_Triangle）和噪声波（DAC_Wave_Noise）。如果我们使用自定义的缓冲区输出波形，就不需要配置这个参数或者使其为DAC_WaveGeneration_None.&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DAC_InitStructure.DAC_OutputBuffer：即是否使用输出缓存。输出缓存的功能主要用来减小输出阻抗，是STM32的DAC无需外部运放就可以直接驱动负载。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;相关参数在stm32f10x_dac.h中可以找到。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;这里实现：&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;设置DAC输出固定电压&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;设置DAC输出三角波形&lt;/strong&gt;&lt;div&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 驱动 触摸屏</title>
    <link href="http://neil-pan.com/2012/09/11/stm32-%E9%A9%B1%E5%8A%A8-%E8%A7%A6%E6%91%B8%E5%B1%8F/"/>
    <id>http://neil-pan.com/2012/09/11/stm32-驱动-触摸屏/</id>
    <published>2012-09-10T18:18:09.000Z</published>
    <updated>2024-07-11T12:49:21.240Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于智能手机的发展和大屏幕的兴起，触摸屏已经得到了广泛的应用。触摸屏分为两种：电阻触屏 &nbsp; 俗称“软屏”；电容触屏俗称“硬屏”。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;电阻触摸屏的屏体部分是一块多层复合薄膜，由一层玻璃或有机玻璃作为基层，表面涂有一层透明的阻性材料组成的导电层(ITO膜)，上面再盖有一层外表面经过硬化处理、光滑防刮的塑料层。它的内表面也涂有一层ITO，在两层导电层之间有许多细小(小于千分之一英寸)的透明隔离点把它们隔开。当手指接触屏幕时，两层 ITO发生接触，电阻发生变化，控制器根据检测到的电阻变化来计算接触点的坐标，再依照这个坐标来进行相应的操作，因此这种技术必须是要施力到屏幕上，才能获得触摸效果。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;所有的电阻式触摸屏都采用分压器原理来产生代表X坐标和Y坐标的电压。</div><div> </div><div>&nbsp; &nbsp; &nbsp; &nbsp;<img src="/uploads/2012/09/4180482593.jpg" alt="8a95ad1cc0c1169586d6b644.jpg">&nbsp; 分压器是通过将两个电阻进行串联来实现的。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上面的电阻（R1）连接正参考电压（VREF），</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;下面的电阻（R2）接地。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;两个电阻连接点处的电压测量值与下面那个电阻的阻值成正比。　</div><div> </div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;所以电阻屏的定位是通过AD采样获取电压，来确定点击位置的。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;电容式触摸屏利用人体的电流感应进行工作，其触摸屏由一块四层复合玻璃屏构成。当手指触摸在触摸屏上时，由于人体电场、用户和触摸屏表面形成以一个耦合电容，对于高频电流来说，电容是直接导体，于是手指从接触点吸走一个很小的电流。这个电流分别从触摸屏四角上的电极中流出，并且流经这四个电极的电流与手指到四角的距离成正比，控制器通过对这四个电流比例的精确计算，得出触摸点的位置信息。</div><div> </div><div>电容触摸屏原理：</div><div>&nbsp; &nbsp;&nbsp;<img src="/uploads/2012/09/1526789542.jpg" alt="c_touch.jpg"><img src="/uploads/2012/09/4206485965.jpg" alt="touch.jpg"></div><div> </div><div>两种屏幕都有其优缺点。电阻屏价格低廉，精度较高。电容屏外层可以使用玻璃，抗损性好，不容易出现误操作，可以实现多点触控。</div><a id="more"></a><div> </div><div>&nbsp; &nbsp; 这里驱动的是驱动IC为XPT2046的4线电阻式触摸屏，触摸屏的控制芯片很多，包括ADS7843、ADS7846、TSC2046、AK4182等。这几款芯片的驱动程序基本上都是一样的，而且封装也有一样的。</div><div>&nbsp; &nbsp; XPT2046是一款4导线制触摸屏控制器，内含12位分辨率125Khz转换速率逐步逼近型A/D转换器。XPT2046支持从1.5V~5.25V的低电压I/O接口。XPT2046能通过执行两次A/D转换查出被按下的屏幕位置，还可以测量出加在屏幕上的压力大小。内部自带2.5V参考电压可以作为辅助输入，温度测量和电池检测模式之用。XPT2046片内还集成一个温度传感器。</div><div> </div><div><div>&nbsp; &nbsp;&nbsp;<strong>这里使用stm32驱动XPT2046和LCD**</strong>实现一个触摸检测和字符显示的功能，<strong>**当检测到特定位置” Click“按下后，显示一个hello world ..&nbsp;</strong></div><div> </div><div>XPT2046驱动: （LCD的驱动参见：<a href="http://www.ichanging.org/stm32-lcd.html" target="_blank" rel="noopener">stm32 驱动 TFT LCD</a>）:</div><div> </div><div><a href="/uploads/2012/09/3920782434.c" title="xpt2046.c">xpt2046.c</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="/uploads/2012/09/395521563.h" title="xpt2046.h">xpt2046.h</a></div><div> </div><div>触摸屏的触摸检测是通过连接XPT2046的引脚，映射为外部中断触发引脚，在有屏幕触摸时，触发外部中断，所以需要配置一个外部中断函数：</div><div>stm32f10x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<br>#include “xpt2046.h”<br><br>//中断,检测到PEN脚的一个下降沿.<br>//置位Pen_Point.Key_Sta为按下状态<br>//中断线0线上的中断检测<br>void EXTI1_IRQHandler(void)<br>{<br>    Pen_Point.Key_Sta=Key_Down;//按键按下<br><br>    EXTI-&gt;PR = 1&lt;&lt;1;    //清除中断标志位 使用库函数会出现问题,原因不详<br>    //EXTI_ClearITPendingBit(EXTI_Line1);        //这两句清除中断顺序不能颠倒<br>    //EXTI_ClearFlag(EXTI_Line1);//清除LINE1上的中断标志位<br>} </pre></div><div> </div><div>在mian()函数中调用相关函数：</div><div><pre class="brush:cpp;">int main(void)<br>{<br>    //stm32 初始化<br>    RCC_Configuration();<br>    NVIC_Configuration();<br>    USART_Configuration();<br>    SPI_Configuration();<br>    EXTI_Configuration();<br>    GPIO_Configuration();<br><br>    LCD_Init();<br>    Touch_Init();<br><br>    POINT_COLOR = BLACK;    //设置字体颜色<br><br>       Delay(100000);<br><br>    LCD_ShowString(180,0,”Click”);//显示”Click”字符按钮<br><br>    while(1){<br>        if(Pen_Point.Key_Sta==Key_Down)//触摸屏被按下<br>        {<br>            Pen_Int_Set(0);//关闭中断<br>            do<br>            {<br>                Convert_Pos();<br>                Pen_Point.Key_Sta=Key_Up;<br><br>                if(Pen_Point.X0&gt;180&amp;&amp;Pen_Point.Y0&lt;16)    //判定按下的是否是  “Click”字符按钮区域<br>                {<br>                    LCD_Clear(WHITE);<br>                    LCD_ShowString(30,50,”Hello Dog .. “);<br>                }<br>            }while(TOUCH_PEN==0);//如果PEN一直有效,则一直执行<br>            Pen_Int_Set(1);//开启中断<br>        }<br>    }<br><br>}</pre></div><div>显示效果：</div></div><div> </div><div><img src="/uploads/2012/09/1851466873.gif" alt="Image.gif"></div><div>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于智能手机的发展和大屏幕的兴起，触摸屏已经得到了广泛的应用。触摸屏分为两种：电阻触屏 &amp;nbsp; 俗称“软屏”；电容触屏俗称“硬屏”。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;电阻触摸屏的屏体部分是一块多层复合薄膜，由一层玻璃或有机玻璃作为基层，表面涂有一层透明的阻性材料组成的导电层(ITO膜)，上面再盖有一层外表面经过硬化处理、光滑防刮的塑料层。它的内表面也涂有一层ITO，在两层导电层之间有许多细小(小于千分之一英寸)的透明隔离点把它们隔开。当手指接触屏幕时，两层 ITO发生接触，电阻发生变化，控制器根据检测到的电阻变化来计算接触点的坐标，再依照这个坐标来进行相应的操作，因此这种技术必须是要施力到屏幕上，才能获得触摸效果。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;所有的电阻式触摸屏都采用分压器原理来产生代表X坐标和Y坐标的电压。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;img src=&quot;/uploads/2012/09/4180482593.jpg&quot; alt=&quot;8a95ad1cc0c1169586d6b644.jpg&quot;&gt;&amp;nbsp; 分压器是通过将两个电阻进行串联来实现的。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;上面的电阻（R1）连接正参考电压（VREF），&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;下面的电阻（R2）接地。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;两个电阻连接点处的电压测量值与下面那个电阻的阻值成正比。　&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;所以电阻屏的定位是通过AD采样获取电压，来确定点击位置的。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;电容式触摸屏利用人体的电流感应进行工作，其触摸屏由一块四层复合玻璃屏构成。当手指触摸在触摸屏上时，由于人体电场、用户和触摸屏表面形成以一个耦合电容，对于高频电流来说，电容是直接导体，于是手指从接触点吸走一个很小的电流。这个电流分别从触摸屏四角上的电极中流出，并且流经这四个电极的电流与手指到四角的距离成正比，控制器通过对这四个电流比例的精确计算，得出触摸点的位置信息。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;电容触摸屏原理：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;img src=&quot;/uploads/2012/09/1526789542.jpg&quot; alt=&quot;c_touch.jpg&quot;&gt;&lt;img src=&quot;/uploads/2012/09/4206485965.jpg&quot; alt=&quot;touch.jpg&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;两种屏幕都有其优缺点。电阻屏价格低廉，精度较高。电容屏外层可以使用玻璃，抗损性好，不容易出现误操作，可以实现多点触控。&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 驱动 TFT LCD</title>
    <link href="http://neil-pan.com/2012/09/09/stm32-%E9%A9%B1%E5%8A%A8-TFT-LCD/"/>
    <id>http://neil-pan.com/2012/09/09/stm32-驱动-TFT-LCD/</id>
    <published>2012-09-09T05:03:29.000Z</published>
    <updated>2024-07-11T12:49:21.239Z</updated>
    
    <content type="html"><![CDATA[<div> </div><div><strong>LCD/LCM的基本概念</strong></div><div>&nbsp;&nbsp;&nbsp;&nbsp;液晶显示器(Liquid Crystal Display: LCD)的构造是在两片平行的玻璃当中放置液态的晶体，两片玻璃中间有许多垂直和水平的细小电线，透过通电与否来控制杆状水晶分子改变方向，将光线折射出来产生画面。它包括了TFT,OLED,UFB,TFD,STN等类型的液晶显示屏.</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;LCM(LCD Module)即LCD显示模组、液晶模块，是指将液晶显示器件，连接件，控制与驱动等外围电路，PCB电路板，背光源，结构件等装配在一起的组件。 购买相应的LCD Module时，会提供相关驱动IC资料，很多会有驱动代码。不过价格会比单买 LCD显示屏贵很多。</div><div> </div><div><div><strong>LCD显示模式</strong></div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;LCD的接口有多种，分类很细。主要看LCD的驱动方式和控制方式，目前手机上的彩色LCD的连接方式一般有这么几种：MCU模式，RGB模式，SPI模式，VSYNC模式，MDDI模式，DSI模式。MCU模式（也写成MPU模式的）。只有TFT模块才有RGB接口。</div><div> </div><div>&nbsp; &nbsp;&nbsp;<strong>MCU模式</strong></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为主要针对单片机的领域在使用,因此得名.后在中低端手机大量使用,其主要特点是价格便宜的。MCU-LCD接口的标准术语是Intel提出的8080总线标准，因此在很多文档中用I80 来指MCU-LCD屏。主要又可以分为8080模式和6800模式，这两者之间主要是时序的区别。数据位传输有8位，9位，16位，18位，24位。</div><div> </div><div>MCU接口标准名称是I80，管脚的控制脚有5个：</div><div> </div><div>CS 片选信号</div><div>RS (置1为写数据,置0为写命令）</div><div>/WR （为0表示写数据) 数据命令区分信号</div><div>/RD （为0表示读数据）</div><div>RESET 复位LCD（ 用固定命令系列 0 1 0来复位)</div><div>数据总线 &nbsp;DATA (8~24位)&nbsp;</div><div> </div><div>&nbsp; &nbsp;&nbsp;<strong>RGB模式</strong></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大屏采用较多的模式，数据位传输也有6位，16位和18位，24位之分。连线一般有：VSYNC，HSYNC，DOTCLK，CS，RESET，有的也需要RS，剩下就是数据线。它的优缺点正好和MCU模式相反。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;MCU-LCD屏它与RGB-LCD屏主要区别在于显存的位置。RGB-LCD的显存是由系统内存充当的，因此其大小只受限于系统内存的大小，这样RGB-LCD可以做出较大尺寸，象现在4.3”只能算入门级，而MID中7”,10”的屏都开始大量使用。而MCU-LCD的设计之初只要考虑单片机的内存较小，因此都是把显存内置在LCD模块内部.然后软件通过专门显示命令来更新显存，因此MCU屏往往不能做得很大。同时显示更新速度也比RGB-LCD慢。显示数据传输模式也有差别。RGB屏只需显存组织好数据。启动显示后，LCD-DMA会自动把显存中的数据通过RGB接口送到LCM。而MCU屏则需要发送画点的命令来修改MCU内部的RAM（即不能直接写MCU屏的RAM）。所以RGB显示速度明显比MCU快，而且播放视频方面，MCU-LCD也比较慢。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;对于RGB接口的LCM，主机输出的直接是每个象素的RGB数据，不需要进行变换（GAMMA校正等除外），对于这种接口，需要在主机部分有个LCD控制器，以产生RGB数据和点、行、帧同步信号。</div><div> </div><div>&nbsp; &nbsp;&nbsp;<strong>MCU接口和RGB接口主要的区别是：</strong></div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MCU接口方式：显示数据写入DDRAM，常用于静止图片显示。控制简单方便，无需时钟和同步信号。要耗费GRAM，所以难以做到大屏（QVGA以上）。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; RGB接口方式：显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。</div><a id="more"></a><div> </div><div>&nbsp; &nbsp;&nbsp;<strong>VSYNC模式</strong></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该模式其实就是就是在MCU模式上加了一个VSYNC信号，应用于运动画面更新，这样就与上述两个接口有很大的区别。该模式支持直接进行动画显示的功能，它提供了一个对MCU接口最小的改动，实现动画显示的解决方案。</div><div> </div><div>其他还有 SPI模式 &nbsp;MDDI模式 &nbsp; DSI模式 采用较少 这里不一一介绍。</div><div> </div><div><div>&nbsp;&nbsp;&nbsp;&nbsp;显示屏的驱动IC采用Ili93xx 系列的居多，资料较多。我使用的是正点原子的开发板,显示屏驱动IC是xxxB505 ，不过驱动代码和ili9320类似，为i80接口。不过我一直有一个疑问，这块IC的具体位置在哪？ 显示屏由屏幕和排线构成，LCM上只有一块芯片 XPT2046是触摸屏的驱动IC？这样的问题Google也不会知道。。 拆开了一个废旧的显示屏，熟悉了一下显示屏的结构，询问了不少淘宝卖家后，总算弄明白了。这块芯片的封装和常见的芯片不同，以2cm<em>2mm左右的一块硅片封装在屏幕下和排线相连接。如图：</em></div><div> </div><div><img src="/uploads/2012/09/4270516043.jpg" alt="ili3920.jpg"></div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;这里对正点原子的相关代码进行了整理，<strong>使用库函数操作，并且整合和横竖屏的代码，实现横竖屏显示。</strong></div><div> </div><div>相关驱动代码如下:</div><div> </div><div>&nbsp; &nbsp; LCD/ili93xx.c&nbsp;</div><div><pre class="brush:cpp;">#include “ili93xx.h”<br>#include “font.h”<br><br>#define USE_HORIZONTAL  0 //定义是否使用横屏<br><br>//画笔颜色,背景颜色<br>u16 POINT_COLOR = 0x0000,BACK_COLOR = 0xFFFF;<br>u16 DeviceCode;<br><br>void LCD_Delay_Us(u32 us)<br>{<br>    u32 time=100us/7;<br>    while(–time);<br>}<br><br>//LCD延时函数 10MS<br>void LCD_Delay (u32 nCount)<br>{<br>    volatile int i;<br>    for (i=0;i&lt;nCount<em>100;i++);<br>}<br><br>//LCD_GPIO_DATA_PIN 模式设置<br>//u8 Mode :<br>//             1    推挽输出<br>//            0    上拉输出<br>void LCD_Data_Pin_Mode(u8 Mode){<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br><br>    GPIO_InitStructure.GPIO_Pin = LCD_GPIO_DATA_PIN;<br><br>    if(Mode == 1)<br>        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;      //推挽输出<br>    else<br>        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU ;        // 上拉输入<br><br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>    GPIO_Init(LCD_GPIO_DATA_PORT, &amp;GPIO_InitStructure);<br>}<br><br>//写寄存器函数<br>void LCD_WR_REG(u8 data)<br>{<br>    Clr_Rs;//写地址<br>    Clr_Cs;<br>    Write_Data(data);<br>    Clr_Wr;<br>    Set_Wr;<br>    Set_Cs;<br>}<br><br>//写寄存器<br>void LCD_WriteReg(u8 LCD_Reg, u16 LCD_RegValue)<br>{<br>    LCD_WR_REG(LCD_Reg);<br>    LCD_WR_DATA(LCD_RegValue);<br>}<br><br>//读寄存器<br>u16 LCD_ReadReg(u8 LCD_Reg)<br>{<br>    u16 t;<br>    LCD_WR_REG(LCD_Reg);   //写入要读的寄存器号<br><br>    LCD_Data_Pin_Mode(0);    //上拉模式<br><br>    Set_Rs;<br>    Clr_Cs;<br>                          //读取数据(读寄存器时,并不需要读2次)<br>    Clr_Rd;<br>    Set_Rd;<br>    t=Read_Data();<br>    Set_Cs;<br><br>    LCD_Data_Pin_Mode(1);    //推挽模式<br>    Write_Data(0xffff);<br>    return t;<br>}<br><br>//开始写GRAM<br>void LCD_WriteRAM_Prepare(void)<br>{<br>    LCD_WR_REG(R34);<br>}<br><br>//LCD写GRAM<br>void LCD_WriteRAM(u16 RGB_Code)<br>{<br>    LCD_WR_DATA(RGB_Code);//写十六位GRAM<br>}<br><br>//从ILI93xx读出的数据为GBR格式，而我们写入的时候为RGB格式。<br>//通过该函数转换<br>//c:GBR格式的颜色值<br>//返回值：RGB格式的颜色值<br>u16 LCD_BGR2RGB(u16 c)<br>{<br>    u16  r,g,b,rgb;<br>    b=(c&gt;&gt;0)&amp;0x1f;<br>    g=(c&gt;&gt;5)&amp;0x3f;<br>    r=(c&gt;&gt;11)&amp;0x1f;<br>    rgb=(b&lt;&lt;11)+(g&lt;&lt;5)+(r&lt;&lt;0);<br>    return(rgb);<br>}<br><br>//读取个某点的颜色值<br>//x:0~239<br>//y:0~319<br>//返回值:此点的颜色<br>u16 LCD_ReadPoint(u16 x,u16 y)<br>{<br>    u16 t;<br>    if(x&gt;=LCD_WIDTH||y&gt;=LCD_HEIGHT)return 0;//超过了范围,直接返回<br>    LCD_SetCursor(x,y);<br>    LCD_WR_REG(R34);       //选择GRAM地址<br><br>    LCD_Data_Pin_Mode(0);    //上拉模式<br><br>    Set_Rs;<br>    Clr_Cs;<br>    //读取数据(读GRAM时,需要读2次)<br>    Clr_Rd;<br>    Set_Rd;<br>    LCD_Delay_Us(2);<br>    //dummy READ<br>    Clr_Rd;<br>    LCD_Delay_Us(2);<br>    Set_Rd;<br><br>    t=Read_Data();<br>    Set_Cs;<br><br>    LCD_Data_Pin_Mode(1);    //推挽模式<br>    Write_Data(0xFFFF);<br><br>    if(DeviceCode==0X4531||DeviceCode==0X8989||DeviceCode==0XB505)<br>        return t;//4531驱动IC<br>    else<br>        return LCD_BGR2RGB(t);<br>}<br><br>//LCD开启显示<br>void LCD_DisplayOn(void)<br>{<br>    LCD_WriteReg(R7, 0x0173); //26万色显示开启<br>}<br><br>//LCD关闭显示<br>void LCD_DisplayOff(void)<br>{<br>    LCD_WriteReg(R7, 0x0);//关闭显示<br>}<br><br>//设置光标位置<br>//Xpos:横坐标<br>//Ypos:纵坐标<br>__inline void LCD_SetCursor(u8 Xpos, u16 Ypos)<br>{<br>    #if USE_HORIZONTAL<br>        LCD_WriteReg(R32, Ypos);<br>        LCD_WriteReg(R33, 319-Xpos);<br>    #else<br>        LCD_WriteReg(R32, Xpos);<br>        LCD_WriteReg(R33, Ypos);<br>    #endif<br>}<br><br>//画点<br>//x:0~239<br>//y:0~319<br>//POINT_COLOR:此点的颜色<br>void LCD_DrawPoint(u16 x,u16 y)<br>{<br>    LCD_SetCursor(x,y);//设置光标位置<br>    LCD_WR_REG(R34);//开始写入GRAM<br>    LCD_WR_DATA(POINT_COLOR);<br>}<br><br>//初始化lcd<br>void LCD_Config(void)<br>{<br>    /</em>Set_Cs;<br>    Set_Rs;<br>    Set_Wr;<br>    Set_Rd;     <em>/<br><br>    LCD_Delay(5); // LCD_Delay 50 ms<br>    LCD_WriteReg(0x0000,0x0001);<br>    LCD_Delay(5); // LCD_Delay 50 ms<br>    DeviceCode = LCD_ReadReg(0x0000);<br>    //printf(“ID:%d\n”,DeviceCode);<br><br>    if(DeviceCode==0x9325||DeviceCode==0x9328){            //ILI9325<br><br>        LCD_WriteReg(0x00e7,0x0010);<br>        LCD_WriteReg(0x0000,0x0001);//开启内部时钟<br>        LCD_WriteReg(0x0001,0x0100);<br>        LCD_WriteReg(0x0002,0x0700);//电源开启<br>        //LCD_WriteReg(0x0003,(1&lt;&lt;3)|(1&lt;&lt;4) );     //65K  RGB<br>        //DRIVE TABLE(寄存器 03H)<br>        //BIT3=AM BIT4:5=ID0:1<br>        //AM ID0 ID1   FUNCATION<br>        // 0  0   0       R-&gt;L D-&gt;U<br>        // 1  0   0       D-&gt;U    R-&gt;L<br>        // 0  1   0       L-&gt;R D-&gt;U<br>        // 1  1   0    D-&gt;U    L-&gt;R<br>        // 0  0   1       R-&gt;L U-&gt;D<br>        // 1  0   1    U-&gt;D    R-&gt;L<br>        // 0  1   1    L-&gt;R U-&gt;D 正常就用这个.<br>        // 1  1   1       U-&gt;D    L-&gt;R<br>        LCD_WriteReg(0x0003,(1&lt;&lt;12)|(3&lt;&lt;4)|(0&lt;&lt;3) );//65K<br>        LCD_WriteReg(0x0004,0x0000);<br>        LCD_WriteReg(0x0008,0x0207);<br>        LCD_WriteReg(0x0009,0x0000);<br>        LCD_WriteReg(0x000a,0x0000);//display setting<br>        LCD_WriteReg(0x000c,0x0001);//display setting<br>        LCD_WriteReg(0x000d,0x0000);//0f3c<br>        LCD_WriteReg(0x000f,0x0000);<br>        //电源配置<br>        LCD_WriteReg(0x0010,0x0000);<br>        LCD_WriteReg(0x0011,0x0007);<br>        LCD_WriteReg(0x0012,0x0000);<br>        LCD_WriteReg(0x0013,0x0000);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0010,0x1590);<br>        LCD_WriteReg(0x0011,0x0227);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0012,0x009c);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0013,0x1900);<br>        LCD_WriteReg(0x0029,0x0023);<br>        LCD_WriteReg(0x002b,0x000e);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0020,0x0000);<br>        LCD_WriteReg(0x0021,0x013f);<br>        LCD_Delay(5);<br>        //伽马校正<br>        LCD_WriteReg(0x0030,0x0007);<br>        LCD_WriteReg(0x0031,0x0707);<br>        LCD_WriteReg(0x0032,0x0006);<br>        LCD_WriteReg(0x0035,0x0704);<br>        LCD_WriteReg(0x0036,0x1f04);<br>        LCD_WriteReg(0x0037,0x0004);<br>        LCD_WriteReg(0x0038,0x0000);<br>        LCD_WriteReg(0x0039,0x0706);<br>        LCD_WriteReg(0x003c,0x0701);<br>        LCD_WriteReg(0x003d,0x000f);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0050,0x0000); //水平GRAM起始位置<br>        LCD_WriteReg(0x0051,(LCD_WIDTH-1)); //水平GRAM终止位置<br>        LCD_WriteReg(0x0052,0x0000); //垂直GRAM起始位置<br>        LCD_WriteReg(0x0053,(LCD_HEIGHT-1)); //垂直GRAM终止位置<br><br>        LCD_WriteReg(0x0060,0xa700);<br>        LCD_WriteReg(0x0061,0x0001);<br>        LCD_WriteReg(0x006a,0x0000);<br>        LCD_WriteReg(0x0080,0x0000);<br>        LCD_WriteReg(0x0081,0x0000);<br>        LCD_WriteReg(0x0082,0x0000);<br>        LCD_WriteReg(0x0083,0x0000);<br>        LCD_WriteReg(0x0084,0x0000);<br>        LCD_WriteReg(0x0085,0x0000);<br><br>        LCD_WriteReg(0x0090,0x0010);<br>        LCD_WriteReg(0x0092,0x0000);<br>        LCD_WriteReg(0x0093,0x0003);<br>        LCD_WriteReg(0x0095,0x0110);<br>        LCD_WriteReg(0x0097,0x0000);<br>        LCD_WriteReg(0x0098,0x0000);<br>        //开启显示设置<br>        LCD_WriteReg(0x0007,0x0133);<br>        LCD_WriteReg(0x0020,0x0000);<br>        LCD_WriteReg(0x0021,0x013f);<br><br>    }else if(DeviceCode==0x9320||DeviceCode==0x9300){<br><br>        LCD_WriteReg(0x00,0x0000);<br>        LCD_WriteReg(0x01,0x0100);    //Driver Output Contral.<br>        LCD_WriteReg(0x02,0x0700);    //LCD Driver Waveform Contral.<br>        LCD_WriteReg(0x03,0x1030);//Entry Mode Set.<br>        //LCD_WriteReg(0x03,0x1018);    //Entry Mode Set.<br><br>        LCD_WriteReg(0x04,0x0000);    //Scalling Contral.<br>        LCD_WriteReg(0x08,0x0202);    //Display Contral 2.(0x0207)<br>        LCD_WriteReg(0x09,0x0000);    //Display Contral 3.(0x0000)<br>        LCD_WriteReg(0x0a,0x0000);    //Frame Cycle Contal.(0x0000)<br>        LCD_WriteReg(0x0c,(1&lt;&lt;0));    //Extern Display Interface Contral 1.(0x0000)<br>        LCD_WriteReg(0x0d,0x0000);    //Frame Maker Position.<br>        LCD_WriteReg(0x0f,0x0000);    //Extern Display Interface Contral 2.<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x07,0x0101);    //Display Contral.<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x10,(1&lt;&lt;12)|(0&lt;&lt;8)|(1&lt;&lt;7)|(1&lt;&lt;6)|(0&lt;&lt;4));    //Power Control 1.(0x16b0)<br>        LCD_WriteReg(0x11,0x0007);                                //Power Control 2.(0x0001)<br>        LCD_WriteReg(0x12,(1&lt;&lt;8)|(1&lt;&lt;4)|(0&lt;&lt;0));                //Power Control 3.(0x0138)<br>        LCD_WriteReg(0x13,0x0b00);                                //Power Control 4.<br>        LCD_WriteReg(0x29,0x0000);                                //Power Control 7.<br><br>        LCD_WriteReg(0x2b,(1&lt;&lt;14)|(1&lt;&lt;4));<br>        LCD_WriteReg(0x50,0);    //Set X Star<br>        //水平GRAM终止位置Set X End.<br>        LCD_WriteReg(0x51,(LCD_WIDTH-1));    //Set Y Star<br>        LCD_WriteReg(0x52,0);    //Set Y End.t.<br>        LCD_WriteReg(0x53,(LCD_HEIGHT-1));    //<br><br>        LCD_WriteReg(0x60,0x2700);    //Driver Output Control.<br>        LCD_WriteReg(0x61,0x0001);    //Driver Output Control.<br>        LCD_WriteReg(0x6a,0x0000);    //Vertical Srcoll Control.<br><br>        LCD_WriteReg(0x80,0x0000);    //Display Position? Partial Display 1.<br>        LCD_WriteReg(0x81,0x0000);    //RAM Address Start? Partial Display 1.<br>        LCD_WriteReg(0x82,0x0000);    //RAM Address End-Partial Display 1.<br>        LCD_WriteReg(0x83,0x0000);    //Displsy Position? Partial Display 2.<br>        LCD_WriteReg(0x84,0x0000);    //RAM Address Start? Partial Display 2.<br>        LCD_WriteReg(0x85,0x0000);    //RAM Address End? Partial Display 2.<br><br>        LCD_WriteReg(0x90,(0&lt;&lt;7)|(16&lt;&lt;0));    //Frame Cycle Contral.(0x0013)<br>        LCD_WriteReg(0x92,0x0000);    //Panel Interface Contral 2.(0x0000)<br>        LCD_WriteReg(0x93,0x0001);    //Panel Interface Contral 3.<br>        LCD_WriteReg(0x95,0x0110);    //Frame Cycle Contral.(0x0110)<br>        LCD_WriteReg(0x97,(0&lt;&lt;8));    //<br>        LCD_WriteReg(0x98,0x0000);    //Frame Cycle Contral.<br>        LCD_WriteReg(0x07,0x0173);    //(0x0173)<br><br>    }else if(DeviceCode==0x1505){<br><br>        // second release on 3/5  ,luminance is acceptable,water wave appear during camera preview<br>        LCD_WriteReg(0x0007,0x0000);<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0012,0x011C);//0x011A   why need to set several times?<br>        LCD_WriteReg(0x00A4,0x0001);//NVM<br>        LCD_WriteReg(0x0008,0x000F);<br>        LCD_WriteReg(0x000A,0x0008);<br>        LCD_WriteReg(0x000D,0x0008);<br>        //伽马校正<br>        LCD_WriteReg(0x0030,0x0707);<br>        LCD_WriteReg(0x0031,0x0007); //0x0707<br>        LCD_WriteReg(0x0032,0x0603);<br>        LCD_WriteReg(0x0033,0x0700);<br>        LCD_WriteReg(0x0034,0x0202);<br>        LCD_WriteReg(0x0035,0x0002); //?0x0606<br>        LCD_WriteReg(0x0036,0x1F0F);<br>        LCD_WriteReg(0x0037,0x0707); //0x0f0f  0x0105<br>        LCD_WriteReg(0x0038,0x0000);<br>        LCD_WriteReg(0x0039,0x0000);<br>        LCD_WriteReg(0x003A,0x0707);<br>        LCD_WriteReg(0x003B,0x0000); //0x0303<br>        LCD_WriteReg(0x003C,0x0007); //?0x0707<br>        LCD_WriteReg(0x003D,0x0000); //0x1313//0x1f08<br>        LCD_Delay(5);<br>        LCD_WriteReg(0x0007,0x0001);<br>        LCD_WriteReg(0x0017,0x0001);//开启电源<br>        LCD_Delay(5);<br>        //电源配置<br>        LCD_WriteReg(0x0010,0x17A0);<br>        LCD_WriteReg(0x0011,0x0217);//reference voltage VC[2:0]   Vciout = 1.00</em>Vcivl<br>        LCD_WriteReg(0x0012,0x011E);//0x011c  //Vreg1out = Vcilvl<em>1.80   is it the same as Vgama1out ?<br>        LCD_WriteReg(0x0013,0x0F00);//VDV[4:0]–&gt;VCOM Amplitude VcomL = VcomH - Vcom Ampl<br>        LCD_WriteReg(0x002A,0x0000);<br>        LCD_WriteReg(0x0029,0x000A);//0x0001F  Vcomh = VCM1[4:0]</em>Vreg1out    gate source voltage??<br>        LCD_WriteReg(0x0012,0x013E);// 0x013C  power supply on<br>        //Coordinates Control//<br>        LCD_WriteReg(0x0050,0x0000);//0x0e00<br>        LCD_WriteReg(0x0051,(LCD_WIDTH-1));<br>        LCD_WriteReg(0x0052,0x0000);<br>        LCD_WriteReg(0x0053,(LCD_HEIGHT-1));<br>        //Pannel Image Control//<br>        LCD_WriteReg(0x0060,0x2700);<br>        LCD_WriteReg(0x0061,0x0001);<br>        LCD_WriteReg(0x006A,0x0000);<br>        LCD_WriteReg(0x0080,0x0000);<br>        //Partial Image Control//<br>        LCD_WriteReg(0x0081,0x0000);<br>        LCD_WriteReg(0x0082,0x0000);<br>        LCD_WriteReg(0x0083,0x0000);<br>        LCD_WriteReg(0x0084,0x0000);<br>        LCD_WriteReg(0x0085,0x0000);<br>        //Panel Interface Control//<br>        LCD_WriteReg(0x0090,0x0013);//0x0010 frenqucy<br>        LCD_WriteReg(0x0092,0x0300);<br>        LCD_WriteReg(0x0093,0x0005);<br>        LCD_WriteReg(0x0095,0x0000);<br>        LCD_WriteReg(0x0097,0x0000);<br>        LCD_WriteReg(0x0098,0x0000);<br><br>        LCD_WriteReg(0x0001,0x0100);<br>        LCD_WriteReg(0x0002,0x0700);<br>        LCD_WriteReg(0x0003,0x1030);<br>        LCD_WriteReg(0x0004,0x0000);<br>        LCD_WriteReg(0x000C,0x0000);<br>        LCD_WriteReg(0x000F,0x0000);<br>        LCD_WriteReg(0x0020,0x0000);<br>        LCD_WriteReg(0x0021,0x0000);<br>        LCD_WriteReg(0x0007,0x0021);<br>        LCD_Delay(20);<br>        LCD_WriteReg(0x0007,0x0061);<br>        LCD_Delay(20);<br>        LCD_WriteReg(0x0007,0x0173);<br>        LCD_Delay(20);<br><br>    }else if(DeviceCode==0xB505){                     //stm32 正点原子 LCD 驱动IC<br><br>        LCD_WriteReg(0x0000,0x0000);<br>        LCD_WriteReg(0x0000,0x0000);<br>        LCD_WriteReg(0x0000,0x0000);<br>        LCD_WriteReg(0x0000,0x0000);<br><br>        LCD_WriteReg(0x00a4,0x0001);<br>        LCD_Delay(20);<br>        LCD_WriteReg(0x0060,0x2700);<br>        LCD_WriteReg(0x0008,0x0202);<br><br>        LCD_WriteReg(0x0030,0x0214);<br>        LCD_WriteReg(0x0031,0x3715);<br>        LCD_WriteReg(0x0032,0x0604);<br>        LCD_WriteReg(0x0033,0x0e16);<br>        LCD_WriteReg(0x0034,0x2211);<br>        LCD_WriteReg(0x0035,0x1500);<br>        LCD_WriteReg(0x0036,0x8507);<br>        LCD_WriteReg(0x0037,0x1407);<br>        LCD_WriteReg(0x0038,0x1403);<br>        LCD_WriteReg(0x0039,0x0020);<br><br>        LCD_WriteReg(0x0090,0x001a);<br>        LCD_WriteReg(0x0010,0x0000);<br>        LCD_WriteReg(0x0011,0x0007);<br>        LCD_WriteReg(0x0012,0x0000);<br>        LCD_WriteReg(0x0013,0x0000);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0010,0x0730);<br>        LCD_WriteReg(0x0011,0x0137);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0012,0x01b8);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0013,0x0f00);<br>        LCD_WriteReg(0x002a,0x0080);<br>        LCD_WriteReg(0x0029,0x0048);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0001,0x0100);<br>        LCD_WriteReg(0x0002,0x0700);<br>        LCD_WriteReg(0x0003,0x1230);<br>        LCD_WriteReg(0x0008,0x0202);<br>        LCD_WriteReg(0x000a,0x0000);<br>        LCD_WriteReg(0x000c,0x0000);<br>        LCD_WriteReg(0x000d,0x0000);<br>        LCD_WriteReg(0x000e,0x0030);<br>        LCD_WriteReg(0x0050,0x0000);<br>        LCD_WriteReg(0x0051,0x00ef);<br>        LCD_WriteReg(0x0052,0x0000);<br>        LCD_WriteReg(0x0053,0x013f);<br>        LCD_WriteReg(0x0060,0x2700);<br>        LCD_WriteReg(0x0061,0x0001);<br>        LCD_WriteReg(0x006a,0x0000);<br>        //LCD_WriteReg(0x0080,0x0000);<br>        //LCD_WriteReg(0x0081,0x0000);<br>        LCD_WriteReg(0x0090,0X0011);<br>        LCD_WriteReg(0x0092,0x0600);<br>        LCD_WriteReg(0x0093,0x0402);<br>        LCD_WriteReg(0x0094,0x0002);<br>        LCD_Delay(20);<br><br>        LCD_WriteReg(0x0007,0x0001);<br>        LCD_Delay(20);<br>        LCD_WriteReg(0x0007,0x0061);<br>        LCD_WriteReg(0x0007,0x0173);<br><br>        LCD_WriteReg(0x0020,0x0000);<br>        LCD_WriteReg(0x0021,0x0000);<br>        LCD_WriteReg(0x00,0x22);<br><br>    }else if(DeviceCode==0x8989){<br><br>        LCD_WriteReg(0x0000,0x0001);LCD_Delay(5);//打开晶振<br>        LCD_WriteReg(0x0003,0xA8A4);LCD_Delay(5);//0xA8A4<br>        LCD_WriteReg(0x000C,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x000D,0x080C);LCD_Delay(5);<br>        LCD_WriteReg(0x000E,0x2B00);LCD_Delay(5);<br>        LCD_WriteReg(0x001E,0x00B0);LCD_Delay(5);<br>        LCD_WriteReg(0x0001,0x2B3F);LCD_Delay(5);//驱动输出控制320<em>240  0x6B3F<br>        LCD_WriteReg(0x0002,0x0600);LCD_Delay(5);<br>        LCD_WriteReg(0x0010,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0011,0x6070);LCD_Delay(5);//定义数据格式  16位色         横屏 0x6058<br>        LCD_WriteReg(0x0005,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0006,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0016,0xEF1C);LCD_Delay(5);<br>        LCD_WriteReg(0x0017,0x0003);LCD_Delay(5);<br>        LCD_WriteReg(0x0007,0x0233);LCD_Delay(5);//0x0233<br>        LCD_WriteReg(0x000B,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x000F,0x0000);LCD_Delay(5);//扫描开始地址<br>        LCD_WriteReg(0x0041,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0042,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0048,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0049,0x013F);LCD_Delay(5);<br>        LCD_WriteReg(0x004A,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x004B,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0044,0xEF00);LCD_Delay(5);<br>        LCD_WriteReg(0x0045,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0046,0x013F);LCD_Delay(5);<br>        LCD_WriteReg(0x0030,0x0707);LCD_Delay(5);<br>        LCD_WriteReg(0x0031,0x0204);LCD_Delay(5);<br>        LCD_WriteReg(0x0032,0x0204);LCD_Delay(5);<br>        LCD_WriteReg(0x0033,0x0502);LCD_Delay(5);<br>        LCD_WriteReg(0x0034,0x0507);LCD_Delay(5);<br>        LCD_WriteReg(0x0035,0x0204);LCD_Delay(5);<br>        LCD_WriteReg(0x0036,0x0204);LCD_Delay(5);<br>        LCD_WriteReg(0x0037,0x0502);LCD_Delay(5);<br>        LCD_WriteReg(0x003A,0x0302);LCD_Delay(5);<br>        LCD_WriteReg(0x003B,0x0302);LCD_Delay(5);<br>        LCD_WriteReg(0x0023,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0024,0x0000);LCD_Delay(5);<br>        LCD_WriteReg(0x0025,0x8000);LCD_Delay(5);<br>        LCD_WriteReg(0x004f,0);        //行首址0<br>        LCD_WriteReg(0x004e,0);        //列首址0<br><br>    }else if(DeviceCode==0x4531){<br><br>        LCD_WriteReg(0X00,0X0001);<br>        LCD_Delay(50);<br>        LCD_WriteReg(0X10,0X1628);<br>        LCD_WriteReg(0X12,0X000e);//0x0006<br>        LCD_WriteReg(0X13,0X0A39);<br>        LCD_Delay(10);<br>        LCD_WriteReg(0X11,0X0040);<br>        LCD_WriteReg(0X15,0X0050);<br>        LCD_Delay(40);<br>        LCD_WriteReg(0X12,0X001e);//16<br>        LCD_Delay(40);<br>        LCD_WriteReg(0X10,0X1620);<br>        LCD_WriteReg(0X13,0X2A39);<br>        LCD_Delay(10);<br>        LCD_WriteReg(0X01,0X0100);<br>        LCD_WriteReg(0X02,0X0300);<br>        LCD_WriteReg(0X03,0X1030);//改变方向的<br>        LCD_WriteReg(0X08,0X0202);<br>        LCD_WriteReg(0X0A,0X0008);<br>        LCD_WriteReg(0X30,0X0000);<br>        LCD_WriteReg(0X31,0X0402);<br>        LCD_WriteReg(0X32,0X0106);<br>        LCD_WriteReg(0X33,0X0503);<br>        LCD_WriteReg(0X34,0X0104);<br>        LCD_WriteReg(0X35,0X0301);<br>        LCD_WriteReg(0X36,0X0707);<br>        LCD_WriteReg(0X37,0X0305);<br>        LCD_WriteReg(0X38,0X0208);<br>        LCD_WriteReg(0X39,0X0F0B);<br>        LCD_WriteReg(0X41,0X0002);<br>        LCD_WriteReg(0X60,0X2700);<br>        LCD_WriteReg(0X61,0X0001);<br>        LCD_WriteReg(0X90,0X0210);<br>        LCD_WriteReg(0X92,0X010A);<br>        LCD_WriteReg(0X93,0X0004);<br>        LCD_WriteReg(0XA0,0X0100);<br>        LCD_WriteReg(0X07,0X0001);<br>        LCD_WriteReg(0X07,0X0021);<br>        LCD_WriteReg(0X07,0X0023);<br>        LCD_WriteReg(0X07,0X0033);<br>        LCD_WriteReg(0X07,0X0133);<br>        LCD_WriteReg(0XA0,0X0000);<br>    }<br><br>    LCD_Delay(5000);<br>    Set_LED;//点亮背光<br>    LCD_Clear(WHITE);<br>}<br><br>//清屏函数<br>//Color:要清屏的填充色<br>void LCD_Clear(u16 Color)<br>{<br>    u32 index=0;<br>    LCD_SetCursor(0x00,0x0000);//设置光标位置<br>    LCD_WriteRAM_Prepare();     //开始写入GRAM<br>    for(index=0;index&lt;76800;index++)<br>    {<br>        LCD_WR_DATA(Color);   //向每个GRAM写入数据<br>    }<br>}<br><br>//在指定区域内填充指定颜色<br>//区域大小:<br>//  (xend-xsta)</em>(yend-ysta)<br>void LCD_Fill(u8 xsta,u16 ysta,u8 xend,u16 yend,u16 color)<br>{<br><br>#if USE_HORIZONTAL         //横屏<br><br>    u16 colortemp=POINT_COLOR;<br>    u16 ytemp=ysta;<br>    POINT_COLOR=color;<br>    for(;xsta&lt;=xend;xsta++)<br>    {<br>        for(;ysta&lt;=yend;ysta++)LCD_DrawPoint(xsta,ysta);<br>        ysta=ytemp;<br>    }<br>    POINT_COLOR=colortemp;<br><br>#else                        //竖屏<br><br>    u32 n;<br>    //设置窗口<br>    LCD_WriteReg(R80, xsta); //水平方向GRAM起始地址<br>    LCD_WriteReg(R81, xend); //水平方向GRAM结束地址<br>    LCD_WriteReg(R82, ysta); //垂直方向GRAM起始地址<br>    LCD_WriteReg(R83, yend); //垂直方向GRAM结束地址<br>    LCD_SetCursor(xsta,ysta);//设置光标位置<br>    LCD_WriteRAM_Prepare();  //开始写入GRAM<br>    n=(u32)(yend-ysta+1)<em>(xend-xsta+1);<br>    while(n–){LCD_WR_DATA(color);}//显示所填充的颜色.<br>    //恢复设置<br>    LCD_WriteReg(R80, 0x0000); //水平方向GRAM起始地址<br>    LCD_WriteReg(R81, (LCD_WIDTH-1)); //水平方向GRAM结束地址<br>    LCD_WriteReg(R82, 0x0000); //垂直方向GRAM起始地址<br>    LCD_WriteReg(R83, (LCD_HEIGHT-1)); //垂直方向GRAM结束地址<br><br>#endif<br><br>}<br><br>//画线<br>//x1,y1:起点坐标<br>//x2,y2:终点坐标<br>void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)<br>{<br>    u16 t;<br>    int xerr=0,yerr=0,delta_x,delta_y,distance;<br>    int incx,incy,uRow,uCol;<br><br>    delta_x=x2-x1; //计算坐标增量<br>    delta_y=y2-y1;<br>    uRow=x1;<br>    uCol=y1;<br>    if(delta_x&gt;0)incx=1; //设置单步方向<br>    else if(delta_x==0)incx=0;//垂直线<br>    else {incx=-1;delta_x=-delta_x;}   //终点坐标小于起始坐标,反方向,将坐标重新定位为正坐标<br>    if(delta_y&gt;0)incy=1;<br>    else if(delta_y==0)incy=0;//水平线<br>    else{incy=-1;delta_y=-delta_y;}   //终点坐标小于起始坐标,反方向,将坐标重新定位为正坐标<br>    if( delta_x&gt;delta_y)distance=delta_x; //选取基本增量坐标轴<br>    else distance=delta_y;<br>    for(t=0;t&lt;=distance+1;t++ )//画线输出<br>    {<br>        LCD_DrawPoint(uRow,uCol);//根据坐标画点<br>        xerr+=delta_x ;  //X坐标增量<br>        yerr+=delta_y ;  //Y坐标增量<br>        if(xerr&gt;distance)<br>        {<br>            xerr-=distance;<br>            uRow+=incx;<br><br>        }<br>        if(yerr&gt;distance)<br>        {<br>            yerr-=distance;<br>            uCol+=incy;<br>        }<br>    }<br>}<br><br>//画矩形<br>void LCD_DrawRectangle(u8 x1, u16 y1, u8 x2, u16 y2)<br>{<br>    LCD_DrawLine(x1,y1,x2,y1);<br>    LCD_DrawLine(x1,y1,x1,y2);<br>    LCD_DrawLine(x1,y2,x2,y2);<br>    LCD_DrawLine(x2,y1,x2,y2);<br>}<br><br>//在指定位置画一个指定大小的圆<br>//(x,y):中心点<br>//r    :半径<br>void Draw_Circle(u8 x0,u16 y0,u8 r)<br>{<br>    int a,b;<br>    int di;<br>    a=0;b=r;<br>    di=3-(r&lt;&lt;1);             //判断下个点位置的标志<br>    while(a&lt;=b)<br>    {<br>        LCD_DrawPoint(x0-b,y0-a);             //3<br>        LCD_DrawPoint(x0+b,y0-a);             //0<br>        LCD_DrawPoint(x0-a,y0+b);             //1<br>        LCD_DrawPoint(x0-b,y0-a);             //7<br>        LCD_DrawPoint(x0-a,y0-b);             //2<br>        LCD_DrawPoint(x0+b,y0+a);             //4<br>        LCD_DrawPoint(x0+a,y0-b);             //5<br>        LCD_DrawPoint(x0+a,y0+b);             //6<br>        LCD_DrawPoint(x0-b,y0+a);<br><br>        a++;<br><br>        //使用Bresenham算法画圆<br>        if(di&lt;0){<br>            di +=4</em>a+6;<br>        }else{<br>            di+=10+4<em>(a-b);<br>            b–;<br>        }<br>        LCD_DrawPoint(x0+a,y0+b);<br>    }<br>}<br><br>//在指定位置显示一个字符<br>//x:0~234<br>//y:0~308<br>//num:要显示的字符:” “—&gt;”~”<br>//size:字体大小 12/16<br>//mode:叠加方式(1)还是非叠加方式(0)<br>void LCD_ShowChar(u8 x,u16 y,u8 num,u8 size,u8 mode)<br>{<br><br>#if USE_HORIZONTAL<br><br>    #define MAX_CHAR_POSX 312<br>    #define MAX_CHAR_POSY 232<br><br>    u8 temp;<br>    u8 pos,t;<br>    u16 x0=x;<br>    u16 colortemp=POINT_COLOR;<br>    if(x&gt;MAX_CHAR_POSX||y&gt;MAX_CHAR_POSY)return;<br>    //设置窗口<br>    num=num-‘ ‘;//得到偏移后的值<br>    if(!mode) //非叠加方式<br>    {<br>        for(pos=0;pos&lt;size;pos++)<br>        {<br>            if(size==12)<br>                temp=asc2_1206[num][pos];//调用1206字体<br>            else<br>                temp=asc2_1608[num][pos];         //调用1608字体<br><br>            for(t=0;t&lt;size/2;t++)<br>            {<br>                if(temp&amp;0x01)<br>                    POINT_COLOR=colortemp;<br>                else<br>                    POINT_COLOR=BACK_COLOR;<br><br>                LCD_DrawPoint(x,y);<br>                temp&gt;&gt;=1;<br>                x++;<br>            }<br>            x=x0;<br>            y++;<br>        }<br>    }else{                                            //叠加方式<br>        for(pos=0;pos&lt;size;pos++)<br>        {<br>            if(size==12)<br>                temp=asc2_1206[num][pos];//调用1206字体<br>            else<br>                temp=asc2_1608[num][pos];         //调用1608字体<br><br>            for(t=0;t&lt;size/2;t++)<br>            {<br>                if(temp&amp;0x01)LCD_DrawPoint(x+t,y+pos);//画一个点<br>                temp&gt;&gt;=1;<br>            }<br>        }<br>    }<br>    POINT_COLOR=colortemp;<br><br>#else<br>    #define MAX_CHAR_POSX 232<br>    #define MAX_CHAR_POSY 304<br><br>    u8 temp;<br>    u8 pos,t;<br><br>    if(x&gt;MAX_CHAR_POSX||y&gt;MAX_CHAR_POSY)return;<br>    //设置窗口<br><br>    LCD_WriteReg(R80,x);           //水平方向GRAM起始地址<br>    LCD_WriteReg(R81,x+(size/2-1));//水平方向GRAM结束地址<br>    LCD_WriteReg(R82,y);           //垂直方向GRAM起始地址<br>    LCD_WriteReg(R83,y+size-1);    //垂直方向GRAM结束地址<br>    LCD_SetCursor(x,y);            //设置光标位置<br>    LCD_WriteRAM_Prepare();        //开始写入GRAM<br>    num=num-‘ ‘;//得到偏移后的值<br>    if(!mode) //非叠加方式<br>    {<br>        for(pos=0;pos&lt;size;pos++)<br>        {<br>            if(size==12)<br>                temp=asc2_1206[num][pos];//调用1206字体<br>            else<br>                temp=asc2_1608[num][pos];         //调用1608字体<br><br>            for(t=0;t&lt;size/2;t++)<br>            {<br>                if(temp&amp;0x01){<br>                    LCD_WR_DATA(POINT_COLOR);<br>                }else{<br>                    LCD_WR_DATA(BACK_COLOR);<br>                }<br><br>                temp&gt;&gt;=1;<br>            }<br>        }<br>    }else{            //叠加方式<br><br>        for(pos=0;pos&lt;size;pos++)<br>        {<br>            if(size==12)<br>                temp=asc2_1206[num][pos];        //调用1206字体<br>            else<br>                temp=asc2_1608[num][pos];         //调用1608字体<br>            for(t=0;t&lt;size/2;t++)<br>            {<br>                if(temp&amp;0x01)<br>                    LCD_DrawPoint(x+t,y+pos);//画一个点<br>                temp&gt;&gt;=1;<br>            }<br>        }<br>    }<br>    //恢复窗体大小<br>    LCD_WriteReg(R80, 0x0000); //水平方向GRAM起始地址<br>    LCD_WriteReg(R81, (LCD_WIDTH-1)); //水平方向GRAM结束地址<br>    LCD_WriteReg(R82, 0x0000); //垂直方向GRAM起始地址<br>    LCD_WriteReg(R83, (LCD_HEIGHT-1)); //垂直方向GRAM结束地址<br><br>#endif<br><br>}<br><br>//m^n函数<br>u32 mypow(u8 m,u8 n)<br>{<br>    u32 result=1;<br>    while(n–)result</em>=m;<br>    return result;<br>}<br><br>//显示数字<br>//x,y :起点坐标<br>//len :数字的位数<br>//size:字体大小<br>//color:颜色<br>//num:数值(0~4294967295);<br>void LCD_ShowNum(u8 x,u16 y,u32 num,u8 len,u8 size)<br>{<br>    u8 t,temp;<br>    u8 enshow=0;<br>    for(t=0;t&lt;len;t++)<br>    {<br>        temp=(num/mypow(10,len-t-1))%10;<br>        if(enshow==0&amp;&amp;t&lt;(len-1))<br>        {<br>            if(temp==0)<br>            {<br>                LCD_ShowChar(x+(size/2)<em>t,y,’ ‘,size,0);<br>                continue;<br>            }else{<br>                enshow=1;<br>            }<br>        }<br>        LCD_ShowChar(x+(size/2)</em>t,y,temp+’0’,size,0);<br>    }<br>}<br><br>//显示字符串<br>//x,y:起点坐标<br>//<em>p:字符串起始地址<br>//用16字体<br>void LCD_ShowString(u8 x,u16 y,const u8 </em>p)<br>{<br>    while(<em>p!=’\0’)     //字符串到达结束<br>    {<br>        if(x&gt;MAX_CHAR_POSX){x=0;y+=16;}       //换行<br>        if(y&gt;MAX_CHAR_POSY){y=x=0;LCD_Clear(WHITE);}  //超出屏幕显示范围<br>        LCD_ShowChar(x,y,</em>p,16,0);<br>        x+=8;<br>        p++;<br>    }<br>}<br><br></pre></div></div></div><div>&nbsp; &nbsp; LCD/ili93xx.h (相关I/O操作在此文件中以宏定义的方式实现)</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br><br>//TFTLCD部分外要调用的函数<br>extern u16  POINT_COLOR;//默认红色<br>extern u16  BACK_COLOR; //背景颜色.默认为白色<br><br>//定义LCD的尺寸<br>#define LCD_WIDTH 240<br>#define LCD_HEIGHT 320<br><br>//9320/9325 LCD寄存器<br>#define R0             0x00<br>#define R1             0x01<br>#define R2             0x02<br>#define R3             0x03<br>#define R4             0x04<br>#define R5             0x05<br>#define R6             0x06<br>#define R7             0x07<br>#define R8             0x08<br>#define R9             0x09<br>#define R10            0x0A<br>#define R12            0x0C<br>#define R13            0x0D<br>#define R14            0x0E<br>#define R15            0x0F<br>#define R16            0x10<br>#define R17            0x11<br>#define R18            0x12<br>#define R19            0x13<br>#define R20            0x14<br>#define R21            0x15<br>#define R22            0x16<br>#define R23            0x17<br>#define R24            0x18<br>#define R25            0x19<br>#define R26            0x1A<br>#define R27            0x1B<br>#define R28            0x1C<br>#define R29            0x1D<br>#define R30            0x1E<br>#define R31            0x1F<br>#define R32            0x20<br>#define R33            0x21<br>#define R34            0x22<br>#define R36            0x24<br>#define R37            0x25<br>#define R40            0x28<br>#define R41            0x29<br>#define R43            0x2B<br>#define R45            0x2D<br>#define R48            0x30<br>#define R49            0x31<br>#define R50            0x32<br>#define R51            0x33<br>#define R52            0x34<br>#define R53            0x35<br>#define R54            0x36<br>#define R55            0x37<br>#define R56            0x38<br>#define R57            0x39<br>#define R59            0x3B<br>#define R60            0x3C<br>#define R61            0x3D<br>#define R62            0x3E<br>#define R63            0x3F<br>#define R64            0x40<br>#define R65            0x41<br>#define R66            0x42<br>#define R67            0x43<br>#define R68            0x44<br>#define R69            0x45<br>#define R70            0x46<br>#define R71            0x47<br>#define R72            0x48<br>#define R73            0x49<br>#define R74            0x4A<br>#define R75            0x4B<br>#define R76            0x4C<br>#define R77            0x4D<br>#define R78            0x4E<br>#define R79            0x4F<br>#define R80            0x50<br>#define R81            0x51<br>#define R82            0x52<br>#define R83            0x53<br>#define R96            0x60<br>#define R97            0x61<br>#define R106           0x6A<br>#define R118           0x76<br>#define R128           0x80<br>#define R129           0x81<br>#define R130           0x82<br>#define R131           0x83<br>#define R132           0x84<br>#define R133           0x85<br>#define R134           0x86<br>#define R135           0x87<br>#define R136           0x88<br>#define R137           0x89<br>#define R139           0x8B<br>#define R140           0x8C<br>#define R141           0x8D<br>#define R143           0x8F<br>#define R144           0x90<br>#define R145           0x91<br>#define R146           0x92<br>#define R147           0x93<br>#define R148           0x94<br>#define R149           0x95<br>#define R150           0x96<br>#define R151           0x97<br>#define R152           0x98<br>#define R153           0x99<br>#define R154           0x9A<br>#define R157           0x9D<br>#define R192           0xC0<br>#define R193           0xC1<br>#define R229           0xE5<br><br>/<em>硬件相关的宏定义</em>/<br>#define LCD_FAST_IO     1     //定义是否使用快速IO     建议使用快速IO,效率更高<br><br>//—————–LCD端口定义—————-<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><br>#define LCD_GPIO_LED_PORT              GPIOC<br>#define LCD_GPIO_LED_PIN               GPIO_Pin_10<br><br>#define LCD_GPIO_CS_PORT              GPIOC<br>#define LCD_GPIO_CS_PIN               GPIO_Pin_9<br><br>#define LCD_GPIO_RS_PORT              GPIOC<br>#define LCD_GPIO_RS_PIN               GPIO_Pin_8<br><br>#define LCD_GPIO_WR_PORT             GPIOC<br>#define LCD_GPIO_WR_PIN              GPIO_Pin_7<br><br>#define LCD_GPIO_RD_PORT              GPIOC<br>#define LCD_GPIO_RD_PIN               GPIO_Pin_6<br><br>//16位数据所在端口,PB0~15作为数据线<br>#define LCD_GPIO_DATA_PORT            GPIOB<br>#define LCD_GPIO_DATA_PIN             GPIO_Pin_All<br><br>#if LCD_FAST_IO == 1 //快速IO<br><br>#define    Set_Cs  GPIOC-&gt;BSRR=1&lt;&lt;9    //片选端口           PC9<br>#define    Set_Rs    GPIOC-&gt;BSRR=1&lt;&lt;8    //数据/命令          PC8<br>#define    Set_Wr    GPIOC-&gt;BSRR=1&lt;&lt;7    //写数据             PC7<br>#define    Set_Rd    GPIOC-&gt;BSRR=1&lt;&lt;6    //读数据             PC6<br><br>#define    Clr_Cs  GPIOC-&gt;BRR=1&lt;&lt;9     //片选端口           PC9<br>#define    Clr_Rs    GPIOC-&gt;BRR=1&lt;&lt;8     //数据/命令          PC8<br>#define    Clr_Wr    GPIOC-&gt;BRR=1&lt;&lt;7     //写数据             PC7<br>#define    Clr_Rd    GPIOC-&gt;BRR=1&lt;&lt;6     //读数据             PC6<br><br>#else<br><br>#define Set_Cs   {GPIO_SetBits(LCD_GPIO_CS_PORT,LCD_GPIO_CS_PIN);}<br>#define Clr_Cs   {GPIO_ResetBits(LCD_GPIO_CS_PORT,LCD_GPIO_CS_PIN);}<br>#define Set_Rs   {GPIO_SetBits(LCD_GPIO_RS_PORT,LCD_GPIO_RS_PIN);}<br>#define Clr_Rs   {GPIO_ResetBits(LCD_GPIO_RS_PORT,LCD_GPIO_RS_PIN);}<br>#define Set_Wr   {GPIO_SetBits(LCD_GPIO_WR_PORT,LCD_GPIO_WR_PIN);}<br>#define Clr_Wr   {GPIO_ResetBits(LCD_GPIO_WR_PORT,LCD_GPIO_WR_PIN);}<br>#define Set_Rd   {GPIO_SetBits(LCD_GPIO_RD_PORT,LCD_GPIO_RD_PIN);}<br>#define Clr_Rd   {GPIO_ResetBits(LCD_GPIO_RD_PORT,LCD_GPIO_RD_PIN);}<br><br>#endif<br><br>#define Set_LED  {GPIO_SetBits(LCD_GPIO_LED_PORT,LCD_GPIO_LED_PIN);}<br>#define Clr_LED  {GPIO_ResetBits(LCD_GPIO_LED_PORT,LCD_GPIO_LED_PIN);}<br><br>#define Write_Data(DataValue) {GPIO_Write(LCD_GPIO_DATA_PORT,DataValue);}<br><br>//直接操作寄存器读取,使用库函数读取I/O有问题,原因不详<br>#define Read_Data() (LCD_GPIO_DATA_PORT -&gt;IDR)                        //必须使用宏定义,写成函数会有问题<br>//#define Read_Data()  (GPIO_ReadInputData(LCD_GPIO_DATA_PORT))        //这句有问题<br><br>//写8位数据函数<br>//用宏定义,提高速度.<br>#define  LCD_WR_DATA(data){\<br>Set_Rs;\<br>Clr_Cs;\<br>Write_Data(data);\<br>Clr_Wr;\<br>Set_Wr;\<br>Set_Cs;\<br>}<br><br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><br>//画笔颜色<br>#define WHITE              0xFFFF<br>#define BLACK              0x0000<br>#define BLUE              0x001F<br>#define BRED             0XF81F<br>#define GRED              0XFFE0<br>#define GBLUE             0X07FF<br>#define RED                0xF800<br>#define MAGENTA            0xF81F<br>#define GREEN              0x07E0<br>#define CYAN               0x7FFF<br>#define YELLOW             0xFFE0<br>#define BROWN              0XBC40 //棕色<br>#define BRRED              0XFC07 //棕红色<br>#define GRAY               0X8430 //灰色<br>//GUI颜色<br><br>#define DARKBLUE           0X01CF    //深蓝色<br>#define LIGHTBLUE           0X7D7C    //浅蓝色<br>#define GRAYBLUE            0X5458 //灰蓝色<br>//以上三色为PANEL的颜色<br><br>#define LIGHTGREEN          0X841F //浅绿色<br>//#define LIGHTGRAY        0XEF5B //浅灰色(PANNEL)<br>#define LGRAY              0XC618 //浅灰色(PANNEL),窗体背景色<br>#define LGRAYBLUE        0XA651 //浅灰蓝色(中间层颜色)<br>#define LBBLUE           0X2B12 //浅棕蓝色(选择条目的反色)<br><br>void LCD_Delay(u32 nCount);<br>void LCD_Config(void);<br>void LCD_DisplayOn(void);<br>void LCD_DisplayOff(void);<br>void LCD_Clear(u16 Color);<br>void LCD_SetCursor(u8 Xpos, u16 Ypos);<br>void LCD_DrawPoint(u16 x,u16 y);//画点<br>u16 LCD_ReadPoint(u16 x,u16 y); //读点<br>void Draw_Circle(u8 x0,u16 y0,u8 r);<br>void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2);<br>void LCD_DrawRectangle(u8 x1, u16 y1, u8 x2, u16 y2);<br>void LCD_Fill(u8 xsta,u16 ysta,u8 xend,u16 yend,u16 color);<br>void LCD_ShowChar(u8 x,u16 y,u8 num,u8 size,u8 mode);//显示一个字符<br>void LCD_ShowNum(u8 x,u16 y,u32 num,u8 len,u8 size);  //显示一个数字<br>void LCD_ShowString(u8 x,u16 y,const u8 <em>p);         //显示一个字符串,16字体<br><br>void LCD_WriteReg(u8 LCD_Reg, u16 LCD_RegValue);<br>u16 LCD_ReadReg(u8 LCD_Reg);<br>void LCD_WriteRAM_Prepare(void);<br>void LCD_WriteRAM(u16 RGB_Code);<br>u16 LCD_ReadRAM(void);<br><br></em></pre></div><div>&nbsp;font.h （字库文件）</div><div><pre class="brush:cpp;"><br>//常用ASCII表<br>//偏移量32<br>//ASCII字符集<br>//偏移量32<br>//大小:126<br>const unsigned char asc2_1206[95][12]={<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“ “,0</em>/<br>{0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x04,0x00,0x00},/<em>“!”,1</em>/<br>{0x00,0x14,0x0A,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“””,2</em>/<br>{0x00,0x00,0x14,0x14,0x3F,0x14,0x0A,0x3F,0x0A,0x0A,0x00,0x00},/<em>“#”,3</em>/<br>{0x00,0x04,0x1E,0x15,0x05,0x06,0x0C,0x14,0x15,0x0F,0x04,0x00},/<em>“$”,4</em>/<br>{0x00,0x00,0x12,0x15,0x0D,0x0A,0x14,0x2C,0x2A,0x12,0x00,0x00},/<em>“%”,5</em>/<br>{0x00,0x00,0x04,0x0A,0x0A,0x1E,0x15,0x15,0x09,0x36,0x00,0x00},/<em>“&amp;”,6</em>/<br>{0x00,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/<em>“‘“,7</em>/<br>{0x00,0x20,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x20,0x00},/<em>“(“,8</em>/<br>{0x00,0x02,0x04,0x08,0x08,0x08,0x08,0x08,0x08,0x04,0x02,0x00},/<em>“)”,9</em>/<br>{0x00,0x00,0x00,0x04,0x15,0x0E,0x0E,0x15,0x04,0x00,0x00,0x00},/<em>“</em>“,10<em>/<br>{0x00,0x00,0x04,0x04,0x04,0x1F,0x04,0x04,0x04,0x00,0x00,0x00},/</em>“+”,11<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x01},/</em>“,”,12<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00},/</em>“-“,13<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00},/</em>“.”,14<em>/<br>{0x00,0x10,0x08,0x08,0x08,0x04,0x04,0x02,0x02,0x02,0x01,0x00},/</em>“/“,15<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x11,0x11,0x0E,0x00,0x00},/</em>“0”,16<em>/<br>{0x00,0x00,0x04,0x06,0x04,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/</em>“1”,17<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x08,0x04,0x02,0x01,0x1F,0x00,0x00},/</em>“2”,18<em>/<br>{0x00,0x00,0x0E,0x11,0x10,0x0C,0x10,0x10,0x11,0x0E,0x00,0x00},/</em>“3”,19<em>/<br>{0x00,0x00,0x08,0x0C,0x0A,0x0A,0x09,0x1E,0x08,0x18,0x00,0x00},/</em>“4”,20<em>/<br>{0x00,0x00,0x1F,0x01,0x01,0x0F,0x10,0x10,0x11,0x0E,0x00,0x00},/</em>“5”,21<em>/<br>{0x00,0x00,0x0E,0x09,0x01,0x0F,0x11,0x11,0x11,0x0E,0x00,0x00},/</em>“6”,22<em>/<br>{0x00,0x00,0x1F,0x09,0x08,0x04,0x04,0x04,0x04,0x04,0x00,0x00},/</em>“7”,23<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x0E,0x11,0x11,0x11,0x0E,0x00,0x00},/</em>“8”,24<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x11,0x1E,0x10,0x12,0x0E,0x00,0x00},/</em>“9”,25<em>/<br>{0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x04,0x00,0x00},/</em>“:”,26<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x04,0x00},/</em>“;”,27<em>/<br>{0x00,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x00,0x00},/</em>“&lt;”,28<em>/<br>{0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x1F,0x00,0x00,0x00,0x00},/</em>“=”,29<em>/<br>{0x00,0x02,0x04,0x08,0x10,0x20,0x10,0x08,0x04,0x02,0x00,0x00},/</em>“&gt;”,30<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x08,0x04,0x04,0x00,0x04,0x00,0x00},/</em>“?”,31<em>/<br>{0x00,0x00,0x0E,0x11,0x19,0x15,0x15,0x1D,0x01,0x1E,0x00,0x00},/</em>“@”,32<em>/<br>{0x00,0x00,0x04,0x04,0x0C,0x0A,0x0A,0x1E,0x12,0x33,0x00,0x00},/</em>“A”,33<em>/<br>{0x00,0x00,0x0F,0x12,0x12,0x0E,0x12,0x12,0x12,0x0F,0x00,0x00},/</em>“B”,34<em>/<br>{0x00,0x00,0x1E,0x11,0x01,0x01,0x01,0x01,0x11,0x0E,0x00,0x00},/</em>“C”,35<em>/<br>{0x00,0x00,0x0F,0x12,0x12,0x12,0x12,0x12,0x12,0x0F,0x00,0x00},/</em>“D”,36<em>/<br>{0x00,0x00,0x1F,0x12,0x0A,0x0E,0x0A,0x02,0x12,0x1F,0x00,0x00},/</em>“E”,37<em>/<br>{0x00,0x00,0x1F,0x12,0x0A,0x0E,0x0A,0x02,0x02,0x07,0x00,0x00},/</em>“F”,38<em>/<br>{0x00,0x00,0x1C,0x12,0x01,0x01,0x39,0x11,0x12,0x0C,0x00,0x00},/</em>“G”,39<em>/<br>{0x00,0x00,0x33,0x12,0x12,0x1E,0x12,0x12,0x12,0x33,0x00,0x00},/</em>“H”,40<em>/<br>{0x00,0x00,0x1F,0x04,0x04,0x04,0x04,0x04,0x04,0x1F,0x00,0x00},/</em>“I”,41<em>/<br>{0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x09,0x07,0x00},/</em>“J”,42<em>/<br>{0x00,0x00,0x37,0x12,0x0A,0x06,0x0A,0x0A,0x12,0x37,0x00,0x00},/</em>“K”,43<em>/<br>{0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x02,0x22,0x3F,0x00,0x00},/</em>“L”,44<em>/<br>{0x00,0x00,0x1B,0x1B,0x1B,0x1B,0x15,0x15,0x15,0x15,0x00,0x00},/</em>“M”,45<em>/<br>{0x00,0x00,0x3B,0x12,0x16,0x16,0x1A,0x1A,0x12,0x17,0x00,0x00},/</em>“N”,46<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x11,0x11,0x0E,0x00,0x00},/</em>“O”,47<em>/<br>{0x00,0x00,0x0F,0x12,0x12,0x0E,0x02,0x02,0x02,0x07,0x00,0x00},/</em>“P”,48<em>/<br>{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x17,0x19,0x0E,0x18,0x00},/</em>“Q”,49<em>/<br>{0x00,0x00,0x0F,0x12,0x12,0x0E,0x0A,0x12,0x12,0x37,0x00,0x00},/</em>“R”,50<em>/<br>{0x00,0x00,0x1E,0x11,0x01,0x06,0x08,0x10,0x11,0x0F,0x00,0x00},/</em>“S”,51<em>/<br>{0x00,0x00,0x1F,0x15,0x04,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/</em>“T”,52<em>/<br>{0x00,0x00,0x33,0x12,0x12,0x12,0x12,0x12,0x12,0x0C,0x00,0x00},/</em>“U”,53<em>/<br>{0x00,0x00,0x33,0x12,0x12,0x0A,0x0A,0x0C,0x04,0x04,0x00,0x00},/</em>“V”,54<em>/<br>{0x00,0x00,0x15,0x15,0x15,0x0E,0x0A,0x0A,0x0A,0x0A,0x00,0x00},/</em>“W”,55<em>/<br>{0x00,0x00,0x1B,0x0A,0x0A,0x04,0x04,0x0A,0x0A,0x1B,0x00,0x00},/</em>“X”,56<em>/<br>{0x00,0x00,0x1B,0x0A,0x0A,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/</em>“Y”,57<em>/<br>{0x00,0x00,0x1F,0x09,0x08,0x04,0x04,0x02,0x12,0x1F,0x00,0x00},/</em>“Z”,58<em>/<br>{0x00,0x1C,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x1C,0x00},/</em>“[“,59<em>/<br>{0x00,0x02,0x02,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x00,0x00},/</em>“\”,60<em>/<br>{0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0E,0x00},/</em>“]”,61<em>/<br>{0x00,0x04,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/</em>“^”,62<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F},/</em>“_”,63<em>/<br>{0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/</em>“<code>&quot;,64*/{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x1C,0x12,0x3C,0x00,0x00},/*&quot;a&quot;,65*/{0x00,0x00,0x03,0x02,0x02,0x0E,0x12,0x12,0x12,0x0E,0x00,0x00},/*&quot;b&quot;,66*/{0x00,0x00,0x00,0x00,0x00,0x1C,0x12,0x02,0x02,0x1C,0x00,0x00},/*&quot;c&quot;,67*/{0x00,0x00,0x18,0x10,0x10,0x1C,0x12,0x12,0x12,0x3C,0x00,0x00},/*&quot;d&quot;,68*/{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x1E,0x02,0x1C,0x00,0x00},/*&quot;e&quot;,69*/{0x00,0x00,0x38,0x04,0x04,0x1E,0x04,0x04,0x04,0x1E,0x00,0x00},/*&quot;f&quot;,70*/{0x00,0x00,0x00,0x00,0x00,0x3C,0x12,0x0C,0x02,0x1E,0x22,0x1C},/*&quot;g&quot;,71*/{0x00,0x00,0x03,0x02,0x02,0x0E,0x12,0x12,0x12,0x37,0x00,0x00},/*&quot;h&quot;,72*/{0x00,0x00,0x04,0x00,0x00,0x06,0x04,0x04,0x04,0x0E,0x00,0x00},/*&quot;i&quot;,73*/{0x00,0x00,0x08,0x00,0x00,0x0C,0x08,0x08,0x08,0x08,0x08,0x07},/*&quot;j&quot;,74*/{0x00,0x00,0x03,0x02,0x02,0x3A,0x0A,0x0E,0x12,0x37,0x00,0x00},/*&quot;k&quot;,75*/{0x00,0x00,0x07,0x04,0x04,0x04,0x04,0x04,0x04,0x1F,0x00,0x00},/*&quot;l&quot;,76*/{0x00,0x00,0x00,0x00,0x00,0x0F,0x15,0x15,0x15,0x15,0x00,0x00},/*&quot;m&quot;,77*/{0x00,0x00,0x00,0x00,0x00,0x0F,0x12,0x12,0x12,0x37,0x00,0x00},/*&quot;n&quot;,78*/{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x12,0x12,0x0C,0x00,0x00},/*&quot;o&quot;,79*/{0x00,0x00,0x00,0x00,0x00,0x0F,0x12,0x12,0x12,0x0E,0x02,0x07},/*&quot;p&quot;,80*/{0x00,0x00,0x00,0x00,0x00,0x1C,0x12,0x12,0x12,0x1C,0x10,0x38},/*&quot;q&quot;,81*/{0x00,0x00,0x00,0x00,0x00,0x1B,0x06,0x02,0x02,0x07,0x00,0x00},/*&quot;r&quot;,82*/{0x00,0x00,0x00,0x00,0x00,0x1E,0x02,0x0C,0x10,0x1E,0x00,0x00},/*&quot;s&quot;,83*/{0x00,0x00,0x00,0x04,0x04,0x0E,0x04,0x04,0x04,0x18,0x00,0x00},/*&quot;t&quot;,84*/{0x00,0x00,0x00,0x00,0x00,0x1B,0x12,0x12,0x12,0x3C,0x00,0x00},/*&quot;u&quot;,85*/{0x00,0x00,0x00,0x00,0x00,0x37,0x12,0x0A,0x0C,0x04,0x00,0x00},/*&quot;v&quot;,86*/{0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x0E,0x0A,0x0A,0x00,0x00},/*&quot;w&quot;,87*/{0x00,0x00,0x00,0x00,0x00,0x1B,0x0A,0x04,0x0A,0x1B,0x00,0x00},/*&quot;x&quot;,88*/{0x00,0x00,0x00,0x00,0x00,0x37,0x12,0x0A,0x0C,0x04,0x04,0x03},/*&quot;y&quot;,89*/{0x00,0x00,0x00,0x00,0x00,0x1E,0x08,0x04,0x04,0x1E,0x00,0x00},/*&quot;z&quot;,90*/{0x00,0x18,0x08,0x08,0x08,0x04,0x08,0x08,0x08,0x08,0x18,0x00},/*&quot;{&quot;,91*/{0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},/*&quot;|&quot;,92*/{0x00,0x06,0x04,0x04,0x04,0x08,0x04,0x04,0x04,0x04,0x06,0x00},/*&quot;}&quot;,93*/{0x02,0x25,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00} /*&quot;~&quot;,94*/}; const unsigned char asc2_1608[95][16]={{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot; &quot;,0*/{0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x18,0x18,0x00,0x00},/*&quot;!&quot;,1*/{0x00,0x48,0x6C,0x24,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;&quot;&quot;,2*/{0x00,0x00,0x00,0x24,0x24,0x24,0x7F,0x12,0x12,0x12,0x7F,0x12,0x12,0x12,0x00,0x00},/*&quot;#&quot;,3*/{0x00,0x00,0x08,0x1C,0x2A,0x2A,0x0A,0x0C,0x18,0x28,0x28,0x2A,0x2A,0x1C,0x08,0x08},/*&quot;$&quot;,4*/{0x00,0x00,0x00,0x22,0x25,0x15,0x15,0x15,0x2A,0x58,0x54,0x54,0x54,0x22,0x00,0x00},/*&quot;%&quot;,5*/{0x00,0x00,0x00,0x0C,0x12,0x12,0x12,0x0A,0x76,0x25,0x29,0x11,0x91,0x6E,0x00,0x00},/*&quot;&amp;amp;&quot;,6*/{0x00,0x06,0x06,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;&#39;&quot;,7*/{0x00,0x40,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x40,0x00},/*&quot;(&quot;,8*/{0x00,0x02,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x02,0x00},/*&quot;)&quot;,9*/{0x00,0x00,0x00,0x00,0x08,0x08,0x6B,0x1C,0x1C,0x6B,0x08,0x08,0x00,0x00,0x00,0x00},/*&quot;*&quot;,10*/{0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x7F,0x08,0x08,0x08,0x08,0x00,0x00,0x00},/*&quot;+&quot;,11*/{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x04,0x03},/*&quot;,&quot;,12*/{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;-&quot;,13*/{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x00,0x00},/*&quot;.&quot;,14*/{0x00,0x00,0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x00},/*&quot;/&quot;,15*/{0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00},/*&quot;0&quot;,16*/{0x00,0x00,0x00,0x08,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/*&quot;1&quot;,17*/{0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x20,0x20,0x10,0x08,0x04,0x42,0x7E,0x00,0x00},/*&quot;2&quot;,18*/{0x00,0x00,0x00,0x3C,0x42,0x42,0x20,0x18,0x20,0x40,0x40,0x42,0x22,0x1C,0x00,0x00},/*&quot;3&quot;,19*/{0x00,0x00,0x00,0x20,0x30,0x28,0x24,0x24,0x22,0x22,0x7E,0x20,0x20,0x78,0x00,0x00},/*&quot;4&quot;,20*/{0x00,0x00,0x00,0x7E,0x02,0x02,0x02,0x1A,0x26,0x40,0x40,0x42,0x22,0x1C,0x00,0x00},/*&quot;5&quot;,21*/{0x00,0x00,0x00,0x38,0x24,0x02,0x02,0x1A,0x26,0x42,0x42,0x42,0x24,0x18,0x00,0x00},/*&quot;6&quot;,22*/{0x00,0x00,0x00,0x7E,0x22,0x22,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00},/*&quot;7&quot;,23*/     {0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00},/*&quot;8&quot;,24*/{0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x64,0x58,0x40,0x40,0x24,0x1C,0x00,0x00},/*&quot;9&quot;,25*/{0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00},/*&quot;:&quot;,26*/{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x04},/*&quot;;&quot;,27*/{0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x40,0x00,0x00},/*&quot;&amp;lt;&quot;,28*/{0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00},/*&quot;=&quot;,29*/{0x00,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x04,0x02,0x00,0x00},/*&quot;&amp;gt;&quot;,30*/{0x00,0x00,0x00,0x3C,0x42,0x42,0x46,0x40,0x20,0x10,0x10,0x00,0x18,0x18,0x00,0x00},/*&quot;?&quot;,31*/{0x00,0x00,0x00,0x1C,0x22,0x5A,0x55,0x55,0x55,0x55,0x2D,0x42,0x22,0x1C,0x00,0x00},/*&quot;@&quot;,32*/{0x00,0x00,0x00,0x08,0x08,0x18,0x14,0x14,0x24,0x3C,0x22,0x42,0x42,0xE7,0x00,0x00},/*&quot;A&quot;,33*/{0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x1E,0x22,0x42,0x42,0x42,0x22,0x1F,0x00,0x00},/*&quot;B&quot;,34*/{0x00,0x00,0x00,0x7C,0x42,0x42,0x01,0x01,0x01,0x01,0x01,0x42,0x22,0x1C,0x00,0x00},/*&quot;C&quot;,35*/{0x00,0x00,0x00,0x1F,0x22,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x1F,0x00,0x00},/*&quot;D&quot;,36*/{0x00,0x00,0x00,0x3F,0x42,0x12,0x12,0x1E,0x12,0x12,0x02,0x42,0x42,0x3F,0x00,0x00},/*&quot;E&quot;,37*/{0x00,0x00,0x00,0x3F,0x42,0x12,0x12,0x1E,0x12,0x12,0x02,0x02,0x02,0x07,0x00,0x00},/*&quot;F&quot;,38*/{0x00,0x00,0x00,0x3C,0x22,0x22,0x01,0x01,0x01,0x71,0x21,0x22,0x22,0x1C,0x00,0x00},/*&quot;G&quot;,39*/{0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/*&quot;H&quot;,40*/{0x00,0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/*&quot;I&quot;,41*/{0x00,0x00,0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x11,0x0F},/*&quot;J&quot;,42*/{0x00,0x00,0x00,0x77,0x22,0x12,0x0A,0x0E,0x0A,0x12,0x12,0x22,0x22,0x77,0x00,0x00},/*&quot;K&quot;,43*/{0x00,0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x42,0x7F,0x00,0x00},/*&quot;L&quot;,44*/{0x00,0x00,0x00,0x77,0x36,0x36,0x36,0x36,0x2A,0x2A,0x2A,0x2A,0x2A,0x6B,0x00,0x00},/*&quot;M&quot;,45*/{0x00,0x00,0x00,0xE3,0x46,0x46,0x4A,0x4A,0x52,0x52,0x52,0x62,0x62,0x47,0x00,0x00},/*&quot;N&quot;,46*/{0x00,0x00,0x00,0x1C,0x22,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x22,0x1C,0x00,0x00},/*&quot;O&quot;,47*/{0x00,0x00,0x00,0x3F,0x42,0x42,0x42,0x42,0x3E,0x02,0x02,0x02,0x02,0x07,0x00,0x00},/*&quot;P&quot;,48*/{0x00,0x00,0x00,0x1C,0x22,0x41,0x41,0x41,0x41,0x41,0x4D,0x53,0x32,0x1C,0x60,0x00},/*&quot;Q&quot;,49*/{0x00,0x00,0x00,0x3F,0x42,0x42,0x42,0x3E,0x12,0x12,0x22,0x22,0x42,0xC7,0x00,0x00},/*&quot;R&quot;,50*/{0x00,0x00,0x00,0x7C,0x42,0x42,0x02,0x04,0x18,0x20,0x40,0x42,0x42,0x3E,0x00,0x00},/*&quot;S&quot;,51*/{0x00,0x00,0x00,0x7F,0x49,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00},/*&quot;T&quot;,52*/{0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00},/*&quot;U&quot;,53*/{0x00,0x00,0x00,0xE7,0x42,0x42,0x22,0x24,0x24,0x14,0x14,0x18,0x08,0x08,0x00,0x00},/*&quot;V&quot;,54*/{0x00,0x00,0x00,0x6B,0x49,0x49,0x49,0x49,0x55,0x55,0x36,0x22,0x22,0x22,0x00,0x00},/*&quot;W&quot;,55*/{0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x18,0x18,0x18,0x24,0x24,0x42,0xE7,0x00,0x00},/*&quot;X&quot;,56*/{0x00,0x00,0x00,0x77,0x22,0x22,0x14,0x14,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00},/*&quot;Y&quot;,57*/{0x00,0x00,0x00,0x7E,0x21,0x20,0x10,0x10,0x08,0x04,0x04,0x42,0x42,0x3F,0x00,0x00},/*&quot;Z&quot;,58*/{0x00,0x78,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x00},/*&quot;[&quot;,59*/{0x00,0x00,0x02,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x10,0x20,0x20,0x20,0x40,0x40},/*&quot;\&quot;,60*/{0x00,0x1E,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1E,0x00},/*&quot;]&quot;,61*/{0x00,0x38,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;^&quot;,62*/{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},/*&quot;_&quot;,63*/{0x00,0x06,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*&quot;</code>“,64<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x78,0x44,0x42,0x42,0xFC,0x00,0x00},/</em>“a”,65<em>/<br>{0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x1A,0x26,0x42,0x42,0x42,0x26,0x1A,0x00,0x00},/</em>“b”,66<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x44,0x02,0x02,0x02,0x44,0x38,0x00,0x00},/</em>“c”,67<em>/<br>{0x00,0x00,0x00,0x60,0x40,0x40,0x40,0x78,0x44,0x42,0x42,0x42,0x64,0xD8,0x00,0x00},/</em>“d”,68<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x7E,0x02,0x02,0x42,0x3C,0x00,0x00},/</em>“e”,69<em>/<br>{0x00,0x00,0x00,0xF0,0x88,0x08,0x08,0x7E,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/</em>“f”,70<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x22,0x22,0x1C,0x02,0x3C,0x42,0x42,0x3C},/</em>“g”,71<em>/<br>{0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x3A,0x46,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/</em>“h”,72<em>/<br>{0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/</em>“i”,73<em>/<br>{0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x38,0x20,0x20,0x20,0x20,0x20,0x20,0x22,0x1E},/</em>“j”,74<em>/<br>{0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x72,0x12,0x0A,0x16,0x12,0x22,0x77,0x00,0x00},/</em>“k”,75<em>/<br>{0x00,0x00,0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00},/</em>“l”,76<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x92,0x92,0x92,0x92,0x92,0xB7,0x00,0x00},/</em>“m”,77<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3B,0x46,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/</em>“n”,78<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00},/</em>“o”,79<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1B,0x26,0x42,0x42,0x42,0x22,0x1E,0x02,0x07},/</em>“p”,80<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x44,0x42,0x42,0x42,0x44,0x78,0x40,0xE0},/</em>“q”,81<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x4C,0x04,0x04,0x04,0x04,0x1F,0x00,0x00},/</em>“r”,82<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x42,0x02,0x3C,0x40,0x42,0x3E,0x00,0x00},/</em>“s”,83<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x3E,0x08,0x08,0x08,0x08,0x08,0x30,0x00,0x00},/</em>“t”,84<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x42,0x42,0x42,0x42,0x62,0xDC,0x00,0x00},/</em>“u”,85<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x14,0x08,0x08,0x00,0x00},/</em>“v”,86<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEB,0x49,0x49,0x55,0x55,0x22,0x22,0x00,0x00},/</em>“w”,87<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x24,0x18,0x18,0x18,0x24,0x6E,0x00,0x00},/</em>“x”,88<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x14,0x18,0x08,0x08,0x07},/</em>“y”,89<em>/<br>{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x22,0x10,0x08,0x08,0x44,0x7E,0x00,0x00},/</em>“z”,90<em>/<br>{0x00,0xC0,0x20,0x20,0x20,0x20,0x20,0x10,0x20,0x20,0x20,0x20,0x20,0x20,0xC0,0x00},/</em>“{“,91<em>/<br>{0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10},/</em>“|”,92<em>/<br>{0x00,0x06,0x08,0x08,0x08,0x08,0x08,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x06,0x00},/</em>“}”,93<em>/<br>{0x0C,0x32,0xC2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/</em>“~”,94*/<br>};<br></pre></div><div>配置好相应的IO为推挽输出，硬件初始化即可。不过这里需要注意的是，这里使用GPIOB作为I80总线数据口，所以和Jtag口冲突（详见：<a href="http://www.ichanging.org/stm32-pcb.html" target="_blank" rel="noopener">stm32 最小系统</a>&nbsp;中jtag说明）。所以在配置IO时要将 jtag口的IO复用关闭：</div><div><pre class="brush:cpp;">在GPIO_Configuration()配置中：<br><br>GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE);<br>// 改变指定管脚的映射 GPIO_Remap_SWJ_Disable SWJ 完全禁用（JTAG+SW-DP）;必须加上这句,否则会导致串口无法使用 被折腾了很久  原因不详<br>GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable , ENABLE);<br>// 改变指定管脚的映射 GPIO_Remap_SWJ_JTAGDisable ，JTAG-DP 禁用 + SW-DP 使能<br><br>注意：不要忘记在RCC_Configuration()中开启AFIO时钟，//AFIO时钟<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</pre></div><div> </div><div>在main.c中直接调用相关函数：</div><div><pre class="brush:cpp;">int main(void)<br>{<br>    //stm32 初始化<br>    RCC_Configuration();<br>    NVIC_Configuration();<br>    USART_Configuration();<br>    SPI_Configuration();<br>    GPIO_Configuration();<br><br>    LCD_Init();<br><br>    POINT_COLOR = BLACK;    //设置字体颜色<br><br>    LCD_ShowString(30,50,”Hello Dog .. “);<br><br>    printf(“\r\n test.. \r\n”);<br><br>    while(1);<br>}</pre></div><div><div>LCD显示效果：</div><div> </div><div><img src="/uploads/2012/09/2242973916.jpg" alt="lcd.jpg"></div></div><div> </div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;LCD/LCM的基本概念&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;液晶显示器(Liquid Crystal Display: LCD)的构造是在两片平行的玻璃当中放置液态的晶体，两片玻璃中间有许多垂直和水平的细小电线，透过通电与否来控制杆状水晶分子改变方向，将光线折射出来产生画面。它包括了TFT,OLED,UFB,TFD,STN等类型的液晶显示屏.&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LCM(LCD Module)即LCD显示模组、液晶模块，是指将液晶显示器件，连接件，控制与驱动等外围电路，PCB电路板，背光源，结构件等装配在一起的组件。 购买相应的LCD Module时，会提供相关驱动IC资料，很多会有驱动代码。不过价格会比单买 LCD显示屏贵很多。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;LCD显示模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LCD的接口有多种，分类很细。主要看LCD的驱动方式和控制方式，目前手机上的彩色LCD的连接方式一般有这么几种：MCU模式，RGB模式，SPI模式，VSYNC模式，MDDI模式，DSI模式。MCU模式（也写成MPU模式的）。只有TFT模块才有RGB接口。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;MCU模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为主要针对单片机的领域在使用,因此得名.后在中低端手机大量使用,其主要特点是价格便宜的。MCU-LCD接口的标准术语是Intel提出的8080总线标准，因此在很多文档中用I80 来指MCU-LCD屏。主要又可以分为8080模式和6800模式，这两者之间主要是时序的区别。数据位传输有8位，9位，16位，18位，24位。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;MCU接口标准名称是I80，管脚的控制脚有5个：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;CS 片选信号&lt;/div&gt;&lt;div&gt;RS (置1为写数据,置0为写命令）&lt;/div&gt;&lt;div&gt;/WR （为0表示写数据) 数据命令区分信号&lt;/div&gt;&lt;div&gt;/RD （为0表示读数据）&lt;/div&gt;&lt;div&gt;RESET 复位LCD（ 用固定命令系列 0 1 0来复位)&lt;/div&gt;&lt;div&gt;数据总线 &amp;nbsp;DATA (8~24位)&amp;nbsp;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;RGB模式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大屏采用较多的模式，数据位传输也有6位，16位和18位，24位之分。连线一般有：VSYNC，HSYNC，DOTCLK，CS，RESET，有的也需要RS，剩下就是数据线。它的优缺点正好和MCU模式相反。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MCU-LCD屏它与RGB-LCD屏主要区别在于显存的位置。RGB-LCD的显存是由系统内存充当的，因此其大小只受限于系统内存的大小，这样RGB-LCD可以做出较大尺寸，象现在4.3”只能算入门级，而MID中7”,10”的屏都开始大量使用。而MCU-LCD的设计之初只要考虑单片机的内存较小，因此都是把显存内置在LCD模块内部.然后软件通过专门显示命令来更新显存，因此MCU屏往往不能做得很大。同时显示更新速度也比RGB-LCD慢。显示数据传输模式也有差别。RGB屏只需显存组织好数据。启动显示后，LCD-DMA会自动把显存中的数据通过RGB接口送到LCM。而MCU屏则需要发送画点的命令来修改MCU内部的RAM（即不能直接写MCU屏的RAM）。所以RGB显示速度明显比MCU快，而且播放视频方面，MCU-LCD也比较慢。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于RGB接口的LCM，主机输出的直接是每个象素的RGB数据，不需要进行变换（GAMMA校正等除外），对于这种接口，需要在主机部分有个LCD控制器，以产生RGB数据和点、行、帧同步信号。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;strong&gt;MCU接口和RGB接口主要的区别是：&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MCU接口方式：显示数据写入DDRAM，常用于静止图片显示。控制简单方便，无需时钟和同步信号。要耗费GRAM，所以难以做到大屏（QVGA以上）。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RGB接口方式：显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 Fatfs 读写SD卡</title>
    <link href="http://neil-pan.com/2012/08/25/stm32-Fatfs-%E8%AF%BB%E5%86%99SD%E5%8D%A1/"/>
    <id>http://neil-pan.com/2012/08/25/stm32-Fatfs-读写SD卡/</id>
    <published>2012-08-24T20:06:50.000Z</published>
    <updated>2024-07-11T12:49:21.218Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp;&nbsp;&nbsp;&nbsp;读写SD是嵌入式系统中一个比较基础的功能，在很多应用中都可以用得上SD卡。折腾了几天，总算移植成功了 最新版Fatfs（Fatfs R0.09） ，成功读写SD卡下文件。</div><div> </div><div>&nbsp; &nbsp;&nbsp;<img src="/uploads/2012/08/3282268549.png" alt="QQ截图20120825031714.png"></div><div> </div><div>&nbsp; &nbsp; FatFs (<a href="http://elm-chan.org/fsw/ff/00index_e.html" target="_blank" rel="noopener">http://elm-chan.org/fsw/ff/00index_e.html</a>)是一个通用的文件系统模块，用于在小型嵌入式系统中实现FAT文件系统。 FatFs 的编写遵循ANSI C，因此不依赖于硬件平台。它可以嵌入到便宜的微控制器中，如 8051, PIC, AVR, SH, Z80, H8, ARM 等等，不需要做任何修改。</div><div> </div><div>1. SD卡/TF卡 硬件接口</div><div> </div><div>SD卡有两种操作接口，SDIO和SPI。 使用SDIO口的速度比较快,SPI的速度比较慢 。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;SD卡引脚描述如下： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SD卡SPI接法如下：</div><div><img src="/uploads/2012/08/2602045677.png" alt="sd引脚定义.png">&nbsp;<img src="/uploads/2012/08/2998887021.png" alt="stm32_sd.png"></div><div>&nbsp;我使用的是正点原子的开发板，所以采用的是SPI接口的模式。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;TF卡SDIO 模式和SPI模式 引脚定义：</div><div> </div><div><img src="/uploads/2012/08/3359893836.png" alt="spi-tf.png"></div><div> </div><div>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;可以发现Micro SD卡只有8个引脚是因为比SD卡少了一个Vss。使用TF转SD的卡套套在Micro SD卡上，这样一来大小就和SD卡一样大，这时候卡套上的9个引脚就和SD卡一样了，你可以完全当做SD卡来操作。</div><div> </div><div>2. SD卡底层驱动</div><div> </div><div>SD卡的操作比较复杂，需要多看看一些文档 。 这里附上SD底层驱动代码，代码说明详见注释</div><div> </div><div>Sd卡SPi操作底层代码 ：&nbsp;<a href="/uploads/2012/08/1162003597.c" title="sdcard.c">sdcard.c</a>&nbsp;&nbsp;<a href="/uploads/2012/08/2794809198.h" title="sdcard.h">sdcard.h</a></div><div><a id="more"></a></div><div><div>3. Fatfs 移植</div><div> </div><div><div>FatFs 软件包中相关文件：</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ffconf.h&nbsp;&nbsp;&nbsp;&nbsp; FatFs 模块配置文件</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ff.h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FatFs 和应用模块公用的包含文件</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ff.c &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;FatFs 模块</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diskio.h &nbsp; &nbsp; FatFs and disk I/O 模块公用的包含文件</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer.h &nbsp; 数据类型定义</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;option &nbsp; &nbsp; &nbsp;可选的外部功能</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diskio.c &nbsp;&nbsp;&nbsp;&nbsp;FatFs 与disk I/O 模块接口层文件(不属于 FatFs 需要由用户提供)</div><div> </div><div><div>FatFs 配置，文件系统的配置项都在 ffconf.h 文件之中：</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) _FS_TINY ：这个选项在R0.07 版本之中开始出现，在之前的版本都是以独立的文件出现，现在通过一个宏来修改使用起来更方便；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) _FS_MINIMIZE、_FS_READONLY、_USE_STRFUNC、_USE_MKFS、_USE_FORWARD 这些宏是用来对文件系统进行裁剪</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) _CODE_PAGE ：本选项用于设置语言码的类型</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4) _USE_LFN ：取值为0~3，主要用于长文件名的支持及缓冲区的动态分配：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;0：不支持长文件名；</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;1：支持长文件名存储的静态分配，一般是存储在BSS 段；</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2：支持长文件名存储的动态分配，存储在栈上；</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;3：支持长文件名存储的动态分配，存储在堆上。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5) _MAX_LFN ：可存储长文件的最大长度，其值一般为（12~255），但是缓冲区一般占(_MAX_LFN + 1) <em> 2 bytes；</em></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(6) _LFN_UNICODE ：为1 时才支持unicode 码；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(7) _FS_RPATH ：R0.08a 版本改动配置项，取值范围0~2：</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0：去除相对路径支持和函数；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1：开启相对路径并且开启f_chdrive()和f_chdir()两个函数；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2：在1 的基础上添加f_getcwd()函数。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(8) _VOLUMES ：支持的逻辑设备数目；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(9) _MAX_SS ：扇区缓冲的最大值，其值一般为512；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(10) _MULTI_PARTITION：定义为1 时，支持磁盘多个分区；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(11) _USE_ERASE ：R0.08a 新加入的配置项，设置为1 时，支持扇区擦除；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(12) _WORD_ACCESS ：如果定义为1，则可以使用word 访问；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(13) _FS_REENTRANT ：定义为1 时，文件系统支持重入，但是需要加上跟操作系统信号量相关的几个函数，函数在syscall.c 文件中；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(14) _FS_SHARE ：文件支持的共享数目。</div></div><div> </div><div><div>Fatfs 开源文件系统 从R0.07e 之后 版本开始就不再提供底层接口文件 diskio.c 模板，这里附上根据</div><div>以上SD卡底层驱动对应的 diskio.c 源码：</div><div> </div><div><pre class="brush:cpp;">#include “common.h”<br>/———————————————————————–<em>/<br>/</em> Inidialize a Drive                                                    <em>/<br><br>DSTATUS disk_initialize (<br>    BYTE drv                /</em> Physical drive nmuber (0..) <em>/<br>)<br>{<br>    u8 state;<br><br>    if(drv)<br>    {<br>        return STA_NOINIT;  //仅支持磁盘0的操作<br>    }<br><br>    state = SD_Init();<br>    if(state == STA_NODISK)<br>    {<br>        return STA_NODISK;<br>    }<br>    else if(state != 0)<br>    {<br>        return STA_NOINIT;  //其他错误：初始化失败<br>    }<br>    else<br>    {<br>        return 0;           //初始化成功<br>    }<br>}<br><br>/</em>———————————————————————–<em>/<br>/</em> Return Disk Status                                                    <em>/<br><br>DSTATUS disk_status (<br>    BYTE drv        /</em> Physical drive nmuber (0..) <em>/<br>)<br>{<br>    if(drv)<br>    {<br>        return STA_NOINIT;  //仅支持磁盘0操作<br>    }<br><br>    //检查SD卡是否插入<br>    if(!SD_DET())<br>    {<br>        return STA_NODISK;<br>    }<br>    return 0;<br>}<br><br>/</em>———————————————————————–<em>/<br>/</em> Read Sector(s)                                                        <em>/<br><br>DRESULT disk_read (<br>    BYTE drv,        /</em> Physical drive nmuber (0..) <em>/<br>    BYTE </em>buff,        /<em> Data buffer to store read data </em>/<br>    DWORD sector,    /<em> Sector address (LBA) </em>/<br>    BYTE count        /<em> Number of sectors to read (1..255) </em>/<br>)<br>{<br>    u8 res=0;<br>    if (drv || !count)<br>    {<br>        return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误<br>    }<br>    if(!SD_DET())<br>    {<br>        return RES_NOTRDY;  //没有检测到SD卡，报NOT READY错误<br>    }<br><br>    if(count==1)            //1个sector的读操作<br>    {<br>        res = SD_ReadSingleBlock(sector, buff);<br>    }<br>    else                    //多个sector的读操作<br>    {<br>        res = SD_ReadMultiBlock(sector, buff, count);<br>    }<br>    /<em><br>    do<br>    {<br>        if(SD_ReadSingleBlock(sector, buff)!=0)<br>        {<br>            res = 1;<br>            break;<br>        }<br>        buff+=512;<br>    }while(–count);                                             </em>/<br>    //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值<br>    if(res == 0x00)<br>    {<br>        return RES_OK;<br>    }<br>    else<br>    {<br>        return RES_ERROR;<br>    }<br>}<br><br>/<em>———————————————————————–</em>/<br>/<em> Write Sector(s)                                                       </em>/<br><br>#if _READONLY == 0<br>DRESULT disk_write (<br>    BYTE drv,            /<em> Physical drive nmuber (0..) </em>/<br>    const BYTE <em>buff,    /</em> Data to be written <em>/<br>    DWORD sector,        /</em> Sector address (LBA) <em>/<br>    BYTE count            /</em> Number of sectors to write (1..255) <em>/<br>)<br>{<br>    u8 res;<br><br>    if (drv || !count)<br>    {<br>        return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误<br>    }<br>    if(!SD_DET())<br>    {<br>        return RES_NOTRDY;  //没有检测到SD卡，报NOT READY错误<br>    }<br><br>    // 读写操作<br>    if(count == 1)<br>    {<br>        res = SD_WriteSingleBlock(sector, buff);<br>    }<br>    else<br>    {<br>        res = SD_WriteMultiBlock(sector, buff, count);<br>    }<br>    // 返回值转换<br>    if(res == 0)<br>    {<br>        return RES_OK;<br>    }<br>    else<br>    {<br>        return RES_ERROR;<br>    }<br>}<br>#endif /</em> _READONLY <em>/<br><br>/</em>———————————————————————–<em>/<br>/</em> Miscellaneous Functions                                               <em>/<br><br>DRESULT disk_ioctl (<br>    BYTE drv,        /</em> Physical drive nmuber (0..) <em>/<br>    BYTE ctrl,        /</em> Control code <em>/<br>    void </em>buff        /<em> Buffer to send/receive control data </em>/<br>)<br>{<br>    DRESULT res;<br><br>    if (drv)<br>    {<br>        return RES_PARERR;  //仅支持单磁盘操作，否则返回参数错误<br>    }<br><br>    //FATFS目前版本仅需处理CTRL_SYNC，GET_SECTOR_COUNT，GET_BLOCK_SIZ三个命令<br>    switch(ctrl)<br>    {<br>    case CTRL_SYNC:<br>        SD_CS_ENABLE();<br>        if(SD_WaitReady()==0)<br>        {<br>            res = RES_OK;<br>        }<br>        else<br>        {<br>            res = RES_ERROR;<br>        }<br>        SD_CS_DISABLE();<br>        break;<br><br>    case GET_BLOCK_SIZE:<br>        <em>(WORD</em>)buff = 512;<br>        res = RES_OK;<br>        break;<br><br>    case GET_SECTOR_COUNT:<br>        <em>(DWORD</em>)buff = SD_GetCapacity();<br>        res = RES_OK;<br>        break;<br>    default:<br>        res = RES_PARERR;<br>        break;<br>    }<br><br>    return res;<br>}<br><br>/<em>———————————————————————–</em>/<br>/<em> User defined function to give a current time to fatfs module          </em>/<br>/<em> 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) </em>/<br>/<em> 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 </em>2) <em>/<br>DWORD get_fattime (void)<br>{<br>  return 0;<br>}</em></pre></div></div></div><div>这里的结构函数为Fatfs提供和SD卡的通信接口。 在 最新版本的Fatfs中还加入了对中文文件名的支持，需要修改 &nbsp;ffconf.h &nbsp; &nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#define _CODE_PAGE &nbsp; &nbsp;936 &nbsp; //- Simplified Chinese GBK (DBCS, OEM, Windows)&nbsp;</div><div>同时应该添加 &nbsp;option/cc936.c文件。但是这个文件有700多K占相当大的ROM， 像stm32F103RBT6这种小FLASH的MCU根本不行 ，加入当前工程文件中代码将增加160KB 左右。</div><div> </div><div>配置好Stm32的串口和SPI等IO口设置后，就可以使用Fatfs做一些文件操作了。</div><div> </div><div>4. Fatfs 文件操作</div><div> </div><div>文件分配表FAT(File AllocationTable)用来记录文件所在位置的表格.它对于硬盘的使用是非常重要的，假若丢失文件分配表，那么硬盘上的数据就会因无法定位而不能使用了。&nbsp;</div><div> </div><div>Fatfs 文件系统减轻了操作SD卡的工作量，调用其提供的函数就可以方便的操作文件，读写删改等。</div><div>这里提供一个main.c 示例：</div><div><pre class="brush:cpp;">#include “common.h”<br>#include &lt;string.h&gt;<br><br>FRESULT scan_files (char path);<br><br>#define  F_PUTS         1        //测试向文件写入字符串<br>#define  F_READ         1       //测试从文件中读出数据<br>#define  F_UNLINK       0       //测试删除文件<br>#define  SCAN_FILES     1       //测试目录扫描<br><br>FATFS fs;<br>FRESULT res;<br>FIL file;<br>UINT br;<br>BYTE buffer[4096];                //以上变量作为全局变量 可以避免一些Bug<br><br>int main(void)<br>{<br>    u16 i,n;<br><br>    //stm32 初始化<br>    RCC_Configuration();<br>    NVIC_Configuration();<br>    USART_Configuration();<br>    SPI_Configuration();<br>    GPIO_Configuration();<br><br>    //fatfs 操作<br><br>    f_mount(0, &amp;fs);<br><br>    //如果data.txt存在，则打开；否则，创建一个新文件<br>    res = f_open(&amp;file, “0:/data.txt”,FA_OPEN_ALWAYS|FA_READ|FA_WRITE );<br><br>    if(res!=FR_OK)<br>    {<br>        printf(“\r\n f_open() fail .. \r\n”);<br>    }else{<br>        printf(“\r\n f_open() success .. \r\n”);<br>    }<br><br>#if F_READ<br><br>    while(1){                                     //使用f_read读文件<br>        res = f_read(&amp;file, buffer, 1, &amp;br);     //一次读一个字节知道读完全部文件信息<br><br>        if (res == FR_OK )<br>        {<br>            printf(“%s”,buffer);<br>        }else{<br>            printf(“\r\n f_read() fail .. \r\n”);<br>        }<br><br>        if(f_eof(&amp;file)) {break;}<br>    }<br><br>    /<em>if( f_gets(buffer,sizeof(buffer),&amp;file) != NULL)     //使用f_gets读文件    ,存在 Bugs 待调试<br>    {<br>        printf(“%s”,buffer);<br>    }else{<br>        printf(“\r\n f_gets() fail .. \r\n”);<br>    } </em>/<br><br>#endif<br><br>#if F_PUTS<br><br>    //将指针指向文件末<br>    //res = f_lseek(&amp;file,(&amp;file)-&gt;fsize);<br>    res = f_lseek(&amp;file,file.fsize);<br><br>    n = f_puts(“\r\n hello dog ..\r\n”, &amp;file) ;  //向文件末写入字符串<br><br>    if(n&lt;1)  //判断写是否成功<br>    {<br>        printf(“\r\n f_puts() fail .. \r\n”);<br>    }else{<br>        printf(“\r\n f_puts() success .. \r\n”);<br>    }<br><br>#endif<br><br>#if F_UNLINK<br><br>    res = f_unlink(“test.jpg”);       //前提SD下存在一个test.jpg<br><br>    if(res!=FR_OK)<br>    {<br>        printf(“\r\n f_unlink() fail .. \r\n”);<br>    }else{<br>        printf(“\r\n f_unlink() success .. \r\n”);<br>    }<br><br>#endif<br><br>#if SCAN_FILES<br><br>    printf(“\r\n the directory files : \r\n”);<br>    scan_files(“/“);          //扫描根目录<br><br>#endif<br><br>       f_close(&amp;file);<br>    f_mount(0, NULL);<br><br>      while(1);<br>}<br><br>FRESULT scan_files (<br>    char<em> path        /</em> Start node to be scanned (also used as work area) <em>/<br>)<br>{<br>    FRESULT res;<br>    FILINFO fno;<br>    DIR dir;<br>    int i;<br>    char </em>fn;   /<em> This function is assuming non-Unicode cfg. </em>/<br>#if _USE_LFN<br>    static char lfn[_MAX_LFN + 1];<br>    fno.lfname = lfn;<br>    fno.lfsize = sizeof lfn;<br>#endif<br><br>    res = f_opendir(&amp;dir, path);                       /<em> Open the directory </em>/<br>    if (res == FR_OK) {<br>        i = strlen(path);<br>        for (;;) {<br>            res = f_readdir(&amp;dir, &amp;fno);                   /<em> Read a directory item </em>/<br>            if (res != FR_OK || fno.fname[0] == 0) break;  /<em> Break on error or end of dir </em>/<br>            if (fno.fname[0] == ‘.’) continue;             /<em> Ignore dot entry </em>/<br>#if _USE_LFN<br>            fn = <em>fno.lfname ? fno.lfname : fno.fname;<br>#else<br>            fn = fno.fname;<br>#endif<br>            if (fno.fattrib &amp; AM_DIR) {                    /</em> It is a directory <em>/<br>                sprintf(&amp;path[i], “/%s”, fn);<br>                res = scan_files(path);<br>                if (res != FR_OK) break;<br>                path[i] = 0;<br>            } else {                                       /</em> It is a file. <em>/<br>                printf(“\r\n %s/%s \r\n”, path, fn);<br>            }<br>        }<br>    }<br><br>    return res;<br>}<br></em></pre></div></div><div>其中 目录扫描函数 scan_files( char  path) 参数格式如下：</div><div> </div><div><img src="/uploads/2012/08/1222938971.png" alt="QQ截图20120824202000.png"></div><div> </div><div>这里使用到了f_puts()函数，所以必须在ffconf.h 中修改 #define _USE_STRFUNC &nbsp;1</div><div> </div><div> </div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;读写SD是嵌入式系统中一个比较基础的功能，在很多应用中都可以用得上SD卡。折腾了几天，总算移植成功了 最新版Fatfs（Fatfs R0.09） ，成功读写SD卡下文件。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;img src=&quot;/uploads/2012/08/3282268549.png&quot; alt=&quot;QQ截图20120825031714.png&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; FatFs (&lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://elm-chan.org/fsw/ff/00index_e.html&lt;/a&gt;)是一个通用的文件系统模块，用于在小型嵌入式系统中实现FAT文件系统。 FatFs 的编写遵循ANSI C，因此不依赖于硬件平台。它可以嵌入到便宜的微控制器中，如 8051, PIC, AVR, SH, Z80, H8, ARM 等等，不需要做任何修改。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;1. SD卡/TF卡 硬件接口&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;SD卡有两种操作接口，SDIO和SPI。 使用SDIO口的速度比较快,SPI的速度比较慢 。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SD卡引脚描述如下： &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;SD卡SPI接法如下：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/08/2602045677.png&quot; alt=&quot;sd引脚定义.png&quot;&gt;&amp;nbsp;&lt;img src=&quot;/uploads/2012/08/2998887021.png&quot; alt=&quot;stm32_sd.png&quot;&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;我使用的是正点原子的开发板，所以采用的是SPI接口的模式。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TF卡SDIO 模式和SPI模式 引脚定义：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/08/3359893836.png&quot; alt=&quot;spi-tf.png&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可以发现Micro SD卡只有8个引脚是因为比SD卡少了一个Vss。使用TF转SD的卡套套在Micro SD卡上，这样一来大小就和SD卡一样大，这时候卡套上的9个引脚就和SD卡一样了，你可以完全当做SD卡来操作。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;2. SD卡底层驱动&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;SD卡的操作比较复杂，需要多看看一些文档 。 这里附上SD底层驱动代码，代码说明详见注释&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;Sd卡SPi操作底层代码 ：&amp;nbsp;&lt;a href=&quot;/uploads/2012/08/1162003597.c&quot; title=&quot;sdcard.c&quot;&gt;sdcard.c&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;/uploads/2012/08/2794809198.h&quot; title=&quot;sdcard.h&quot;&gt;sdcard.h&lt;/a&gt;&lt;/div&gt;&lt;div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 最小系统</title>
    <link href="http://neil-pan.com/2012/07/27/stm32-%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://neil-pan.com/2012/07/27/stm32-最小系统/</id>
    <published>2012-07-27T11:22:58.000Z</published>
    <updated>2024-07-11T12:49:21.235Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp; &nbsp;这里使用的stm32型号为 stm32f103c8te，只有GPIOA、B两组通用I/O口，共48个引脚。引脚图如下：</div><div><img src="/uploads/2012/07/1889639279.png" alt="stm32f103c8t6.png"></div><div> </div><div><div> </div><div>1. VDDA引脚</div><div> </div><div>VDDA用于模拟电路（ADC采样）.VDD若直接与之连接,数字电路的干扰会窜入模拟电路的,如果想保证ADC采样的精度可以在VDD和VDDA间加入滤波电路。</div><div> </div><div><img src="/uploads/2012/07/450395061.png" alt="vdda.png"></div><div> </div><div>很多开发板都是直接和VDD连接，也可以运行。</div><div> </div><div>由于STM32F103 系列单片机的内部高速RC 振荡器（HSI）由VDDA、VSSA 供电，故即使不使用单片机自带的A/D 转换器，也必须保证VDDA、VSSA 的供电，否则STM32F103不能正常启动。</div><div> </div><a id="more"></a><div>2.VBAT引脚</div><div> </div><div>备用电源引脚，当VDD关闭时，实时时钟（RTC）和 备用寄存器可以从VBAT引脚获得电压。</div><div> </div><div> </div><div>3.Boot 选择</div><div>通过 Boot0 和 Boot1两个引脚可以选择stm32启动模式，参见下图：</div><div><img src="/uploads/2012/07/3455029096.png" alt="stm32_boot.png"></div><div> </div><div>3.Jtag引脚接法如下：</div><div> </div><div><img src="/uploads/2012/07/77275299.png" alt="jtag.png"></div><div> </div><div> </div><div> </div><div>4.电压转换</div><div> </div><div>单片机系统中常用 5V和3.3V电压，可以通过电压调节器实现电压转换。</div><div> </div><div>LM1117是一个低压差电压调节器系列。其压差在1.2V输出，负载电流为800mA时为1.2V。它与国家半导体的工业标准器件LM317有相同的管脚排列。LM1117有可调电压的版本，通过2个外部电阻可实现1.25～13.8V输出电压范围。另外还有5个固定电压输出（1.8V、2.5V、2.85V、3.3V和5V）的型号。输出端需要一个至少10uF的钽电容来改善瞬态响应和稳定性。</div><div> </div><div>Lm1117电路如下：</div><div> </div><div><img src="/uploads/2012/07/3577142099.png" alt="lm1117.png"></div><div> </div><div> </div><div>Stm32f103c8t6 最小系统原理图：&nbsp;<a href="/uploads/2012/07/3144815126.pdf" title="Stm32f103CBT6_SCH.pdf">Stm32f103CBT6_SCH.pdf</a></div><div> </div></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp; &amp;nbsp;这里使用的stm32型号为 stm32f103c8te，只有GPIOA、B两组通用I/O口，共48个引脚。引脚图如下：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/1889639279.png&quot; alt=&quot;stm32f103c8t6.png&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;1. VDDA引脚&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;VDDA用于模拟电路（ADC采样）.VDD若直接与之连接,数字电路的干扰会窜入模拟电路的,如果想保证ADC采样的精度可以在VDD和VDDA间加入滤波电路。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/450395061.png&quot; alt=&quot;vdda.png&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;很多开发板都是直接和VDD连接，也可以运行。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;由于STM32F103 系列单片机的内部高速RC 振荡器（HSI）由VDDA、VSSA 供电，故即使不使用单片机自带的A/D 转换器，也必须保证VDDA、VSSA 的供电，否则STM32F103不能正常启动。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Uip WebServer 实现</title>
    <link href="http://neil-pan.com/2012/07/27/Uip-WebServer-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://neil-pan.com/2012/07/27/Uip-WebServer-实现/</id>
    <published>2012-07-26T17:10:38.000Z</published>
    <updated>2024-07-11T12:49:21.212Z</updated>
    
    <content type="html"><![CDATA[<div>Uip的Webserver比较复杂，用c语言实现一个简单服务器的所有功能，路由功能，GET传参，动态页面生成等。</div><div> </div><div>要运行Uip的WebServer 只需要:</div><div>1. 修改uip-con.h 里的#inlcude “webserver.h” &nbsp;去除其注释</div><div>2. 在User/main.c 里加入&nbsp;&nbsp; &nbsp; &nbsp;httpd_init(); &nbsp; //初始化服务器</div><div> </div><div>Uip+ stm32移植参见&nbsp;<a href="http://www.ichanging.org/uip-stm32.html" target="_blank" rel="noopener">Uip + Stm32移植问题总结</a><span style="text-align: left; ">&nbsp;</span></div><div> </div><div>浏览器访问 Uip WebServer 页面：</div><div> </div><div><img src="/uploads/2012/07/2241307800.jpg" alt="6581bcdegw1dv93b6puvhj.jpg"></div><div> </div><div>分析下 Uip Webserver 的运行过程,Uip WebServer使用到相关文件如下：</div><div> </div><div>httpd.c &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</div><div>httpd.c中定义了一些字符阿斯克码，含义如下</div><div><br>        #define ISO_nl      0x0a     // 换行<br>        #define ISO_space   0x20     // 空格<br>        #define ISO_bang    0x21     // !<br>        #define ISO_percent 0x25     // %<br>        #define ISO_period  0x2e   // .<br>        #define ISO_slash   0x2f     // /<br>        #define ISO_colon   0x3a     // :<br><br></div><div>当Uip接收到Uip接收到底层传递的数据,将接收到的数据通过调用http_appcall(),传递给Webserver处理，再通过handle_connection(）先后调用handle_input(）函数和handle_output()函数</div><a id="more"></a><div>handle_input(）主要作用是分析http数据流：</div><pre><code>static  PT_THREAD(handle_input(struct httpd_state *s))        //分析http数据流, http数据流格式(eg. &quot;GET /6?user=123 HTTP/ ...&quot;){char * ptr;PSOCK_BEGIN(&amp;s-&gt;sin);//取出到下一个空格号之前的数据PSOCK_READTO(&amp;s-&gt;sin, ISO_space);                   //Uip使用这个函数从http数据流中剥离数据if(strncmp(s-&gt;inputbuf, http_get, 4) != 0) {             //判断数据流前4位字符是否为&quot;GET &quot;，判断是否为GET传参    PSOCK_CLOSE_EXIT(&amp;s-&gt;sin);}PSOCK_READTO(&amp;s-&gt;sin, ISO_space);if(s-&gt;inputbuf[0] != ISO_slash) {                      PSOCK_CLOSE_EXIT(&amp;s-&gt;sin);}if(s-&gt;inputbuf[1] == ISO_space) {                     //请求路径为 &quot;/ &quot; (eg. 192.168.1.15/ ) 更新请求页面filename 为/index.html    strncpy(s-&gt;filename, http_index_html, sizeof(s-&gt;filename));} else {                                          //根据请求路径,更新结构体中filename为相应页面名称    s-&gt;inputbuf[PSOCK_DATALEN(&amp;s-&gt;sin) - 1] = 0;    strncpy(s-&gt;filename, &amp;s-&gt;inputbuf[0], sizeof(s-&gt;filename));       }/*  httpd_log_file(uip_conn-&gt;ripaddr, s-&gt;filename);*/s-&gt;state = STATE_OUTPUT;while(1) {    PSOCK_READTO(&amp;s-&gt;sin, ISO_nl);    if(strncmp(s-&gt;inputbuf, http_referer, 8) == 0) {        s-&gt;inputbuf[PSOCK_DATALEN(&amp;s-&gt;sin) - 2] = 0;        /*      httpd_log(&amp;s-&gt;inputbuf[9]);*/    }}PSOCK_END(&amp;s-&gt;sin);}</code></pre><div>分析数据得出访问页面的名字,存入一个全局的结构体中，handle_output()函数根据这个结构体获得要输出的页面名字，做相应处理：</div><pre><code>static PT_THREAD(handle_output(struct httpd_state *s)){    char *ptr;    PT_BEGIN(&amp;s-&gt;outputpt);    if(!httpd_fs_open(s-&gt;filename, &amp;s-&gt;file)) {            //没有此页面,打开404页面        httpd_fs_open(http_404_html, &amp;s-&gt;file);        strcpy(s-&gt;filename, http_404_html);        PT_WAIT_THREAD(&amp;s-&gt;outputpt,                send_headers(s,                http_header_404));        PT_WAIT_THREAD(&amp;s-&gt;outputpt,                send_file(s));    } else {                                 //正常打印相应页面        PT_WAIT_THREAD(&amp;s-&gt;outputpt,                                         send_headers(s,                http_header_200));        ptr = strchr(s-&gt;filename, ISO_period);                //查找字符串s-&gt;filename中首次出现字符ISO_period的位置,返回首次出现c的位置的指针        if(ptr != NULL &amp;&amp; strncmp(ptr, http_shtml, 6) == 0) {     //判断是否为 .shtml网页文件                PT_INIT(&amp;s-&gt;scriptpt);            PT_WAIT_THREAD(&amp;s-&gt;outputpt, handle_script(s));    //若为 .shtml页面,则调用handle_script()生成动态网页        } else {                            //不是 .shtml(eg.  /index.html),输出该页面数据            PT_WAIT_THREAD(&amp;s-&gt;outputpt,                    send_file(s));        }    }    PSOCK_CLOSE(&amp;s-&gt;sout);    PT_END(&amp;s-&gt;outputpt);}</code></pre><p>httpd_fs_open(）定义于httpd-fs.c,用于读取相应页面的数据，将页面数据存入全局结构体中，是实现路由遍历的关键函数：</p><pre><code>int  httpd_fs_open(const char *name, struct httpd_fs_file *file){#if HTTPD_FS_STATISTICS  u16_t i = 0;#endif /* HTTPD_FS_STATISTICS */  struct httpd_fsdata_file_noconst *f;  //遍历所有的页面数据, 方便校验是否存在该页面for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;        //HTTPD_FS_ROOT 定义于httpd-fsdata.c, 定义了遍历入口     f != NULL;     f = (struct httpd_fsdata_file_noconst *)f-&gt;next) {             //加载下一个页面数据 ,遍历顺序由httpd_fsdata_file结构体中 next决定(见 httpd-fsdata.c)                                                                  if(httpd_fs_strcmp(name, f-&gt;name) == 0) {                  //校验请求的页面是否为此页面             file-&gt;data = f-&gt;data;             file-&gt;len = f-&gt;len;         #if HTTPD_FS_STATISTICS                 ++count[i];         #endif /* HTTPD_FS_STATISTICS */             return 1;         }     #if HTTPD_FS_STATISTICS         ++i;     #endif /* HTTPD_FS_STATISTICS */ } return 0; }</code></pre><p>http-fsdata.c 中包含了所有页面的数据。这里的页面数据都转换为ACAll存在数组中，还包括了层叠样式表 （.css文件) 和图片。其数组结构如下：</p><pre><code>static const unsigned char data_404_html[] = {/* /404.html */0x2f, 0x34, 0x30, 0x34, 0x2e, 0x68, 0x74, 0x6d, 0x6c, 0,//文件名  /404.html0x3c, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0xa, 0x20, 0x20, 0x3c,            //html文件转码为16进制数据(ASCLL)0x62, 0x6f, 0x64, 0x79, 0x20, 0x62, 0x67, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x3d, 0x22, 0x77, 0x68, 0x69, 0x74, 0x65, 0x22, 0x3e, 0xa, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x63, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x3e, 0xa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x68, 0x31, 0x3e, 0x34, 0x30, 0x34, 0x20, 0x2d, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x3c, 0x2f, 0x68, 0x31, 0x3e, 0xa, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x68, 0x33, 0x3e, 0x47, 0x6f, 0x20, 0x3c, 0x61, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3d, 0x22, 0x2f, 0x22, 0x3e, 0x68, 0x65, 0x72, 0x65, 0x3c, 0x2f, 0x61, 0x3e, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2e, 0x3c, 0x2f, 0x68, 0x33, 0x3e, 0xa, 0x20, 0x20, 0x20, 0x20, 0x3c, 0x2f, 0x63, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x3e, 0xa, 0x20, 0x20, 0x3c, 0x2f, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0xa, 0x3c, 0x2f, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0};</code></pre><p>需要注意的是以下的一段程序：<br></p><pre><code>//结构体格式说明:      下一个页面地址(用于遍历网页)    ,网页name地址      ,html数据起始地址          ,html数据长度//其中的加减操作是为了去除文件名的长度const struct httpd_fsdata_file file_processes_shtml[] = {{NULL, data_processes_shtml, data_processes_shtml + 17, sizeof(data_processes_shtml) - 17}};const struct httpd_fsdata_file file_404_html[] = {{file_processes_shtml, data_404_html, data_404_html + 10, sizeof(data_404_html) - 10}};const struct httpd_fsdata_file file_files_shtml[] = {{file_404_html, data_files_shtml, data_files_shtml + 13, sizeof(data_files_shtml) - 13}};const struct httpd_fsdata_file file_footer_html[] = {{file_files_shtml, data_footer_html, data_footer_html + 13, sizeof(data_footer_html) - 13}};const struct httpd_fsdata_file file_header_html[] = {{file_footer_html, data_header_html, data_header_html + 13, sizeof(data_header_html) - 13}};const struct httpd_fsdata_file file_index_html[] = {{file_header_html, data_index_html, data_index_html + 12, sizeof(data_index_html) - 12}};const struct httpd_fsdata_file file_style_css[] = {{file_index_html, data_style_css, data_style_css + 11, sizeof(data_style_css) - 11}};const struct httpd_fsdata_file file_tcp_shtml[] = {{file_style_css, data_tcp_shtml, data_tcp_shtml + 11, sizeof(data_tcp_shtml) - 11}};const struct httpd_fsdata_file file_fade_png[] = {{file_tcp_shtml, data_fade_png, data_fade_png + 10, sizeof(data_fade_png) - 10}};const struct httpd_fsdata_file file_stats_shtml[] = {{file_fade_png, data_stats_shtml, data_stats_shtml + 13, sizeof(data_stats_shtml) - 13}};#define HTTPD_FS_ROOT file_stats_shtml      //设定路由遍历入口页面,一定要保证所有页面都遍历过一次#define HTTPD_FS_NUMFILES 10                //设定页面数量</code></pre><p>在 httpd_fs_open() 首先加载 file_stats_shtml页面数据 再加载file_stats_shtml结构体中下一个网页的数据 也就是file_fade_png的数据，同理 file_fade_png加载后一个页面数据  即 file_tcp_shtml数据 。。。 这样循环一次 就会加载所有的页面，实现里有遍历</p><p>Uip WebServer的动态网页生成</p><p>在uip/apps/Webserver/http-fs/下有Webserver 页面未转码的html文件，其中有很多 %！ 和 %!: 字符 ：</p><pre><code>%!: /header.html&lt;h1&gt;Network statistics&lt;/h1&gt;&lt;center&gt;&lt;table width=&quot;300&quot; border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;IP           Packets received             Packets sent         Packets droppedIP errors    IP version/header length             IP length, high byte             IP length, low byte             IP fragments             Header checksum             Wrong protocolICMP         Packets received             Packets sent             Packets dropped             Type errorsTCP          Packets received             Packets sent             Packets dropped             Checksum errors             Data packets without ACKs             Resets             Retransmissions         No connection avaliable         Connection attempts to closed ports&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;%! net-stats&lt;/pre&gt;&lt;/table&gt;&lt;/center&gt;%!: /footer.html</code></pre><div>这是实现动态页面的关键。</div><div> </div><div>handle_output(）函数中，找到相应页面数据后，若页面为.shtml，则会调用handle_script(）函数：</div><pre><code>    static  PT_THREAD(handle_script(struct httpd_state *s))                                       {    char *ptr;    PT_BEGIN(&amp;s-&gt;scriptpt);    while(s-&gt;file.len &gt; 0) {/* Check if we should start executing a script. */        //检测当前html数据(定义于httpd-fsdata.c)中是否存在字符 %! 和 %!:if(*s-&gt;file.data == ISO_percent &amp;&amp;   *(s-&gt;file.data + 1) == ISO_bang) {                      s-&gt;scriptptr = s-&gt;file.data + 3;                          s-&gt;scriptlen = s-&gt;file.len - 3;  if(*(s-&gt;scriptptr - 1) == ISO_colon) {                //若为 %!:  根据其后变量名,打开并输出相应文件 httpd_fs_open(s-&gt;scriptptr + 1, &amp;s-&gt;file);                //eg.  %!: /header.html  打印/header.htmlPT_WAIT_THREAD(&amp;s-&gt;scriptpt, send_file(s));  } else {                                    //若为 %!   根据其后变量名,调用相应处理程序(定义于httpd-cgi.c)PT_WAIT_THREAD(&amp;s-&gt;scriptpt,                        //eg. %! file-stats        调用file-stats 绑定的file_stats()函数,打印出相关数据,实现动态网页           httpd_cgi(s-&gt;scriptptr)(s, s-&gt;scriptptr));  }  next_scriptstate(s);  /* The script is over, so we reset the pointers and continue sending the rest of the file. */  s-&gt;file.data = s-&gt;scriptptr;  s-&gt;file.len = s-&gt;scriptlen;} else {                                                //当前html数据不存在 %! 和 %!  /* See if we find the start of script marker in the block of HTML to be sent. */...略去</code></pre><p>uip 载入html数据的方法类似网页里的模板引擎的实现方法。当页面输出时，检测到有字符串 %! 和 %！: 时，则调用相应的cgi程序（httpd-cgi.c）处理，在httpd-cgi.c中做相应的数据处理，实现动态网页。</p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;Uip的Webserver比较复杂，用c语言实现一个简单服务器的所有功能，路由功能，GET传参，动态页面生成等。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;要运行Uip的WebServer 只需要:&lt;/div&gt;&lt;div&gt;1. 修改uip-con.h 里的#inlcude “webserver.h” &amp;nbsp;去除其注释&lt;/div&gt;&lt;div&gt;2. 在User/main.c 里加入&amp;nbsp;&amp;nbsp; &amp;nbsp; &amp;nbsp;httpd_init(); &amp;nbsp; //初始化服务器&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;Uip+ stm32移植参见&amp;nbsp;&lt;a href=&quot;http://www.ichanging.org/uip-stm32.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Uip + Stm32移植问题总结&lt;/a&gt;&lt;span style=&quot;text-align: left; &quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;浏览器访问 Uip WebServer 页面：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/2241307800.jpg&quot; alt=&quot;6581bcdegw1dv93b6puvhj.jpg&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;分析下 Uip Webserver 的运行过程,Uip WebServer使用到相关文件如下：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;httpd.c &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/div&gt;&lt;div&gt;httpd.c中定义了一些字符阿斯克码，含义如下&lt;/div&gt;&lt;div&gt;&lt;br&gt;        #define ISO_nl      0x0a     // 换行&lt;br&gt;        #define ISO_space   0x20     // 空格&lt;br&gt;        #define ISO_bang    0x21     // !&lt;br&gt;        #define ISO_percent 0x25     // %&lt;br&gt;        #define ISO_period  0x2e   // .&lt;br&gt;        #define ISO_slash   0x2f     // /&lt;br&gt;        #define ISO_colon   0x3a     // :&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;当Uip接收到Uip接收到底层传递的数据,将接收到的数据通过调用http_appcall(),传递给Webserver处理，再通过handle_connection(）先后调用handle_input(）函数和handle_output()函数&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Uip WebClient 实现</title>
    <link href="http://neil-pan.com/2012/07/27/Uip-WebClient-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://neil-pan.com/2012/07/27/Uip-WebClient-实现/</id>
    <published>2012-07-26T16:42:25.000Z</published>
    <updated>2024-07-11T12:49:21.211Z</updated>
    
    <content type="html"><![CDATA[<div>Uip WebClient 实现的功能是接入互联网，通过http协议访问某个网站。HTTP是一种应用层协议。基于TCP/IP。&nbsp;&nbsp;TCP/IP作为传输层协议解决数据如何在网络中传输，HTTP作为应用层协议，解决如何包装数据。默认的HTTP访问端口为80端口。</div><div> </div><div>Uip + stm32 的移植参见&nbsp;<a href="http://www.ichanging.org/uip-stm32.html" target="_blank" rel="noopener">Uip + Stm32移植问题总结</a><span style="text-align: left; ">&nbsp;</span></div><div> </div><div>相关文件：</div><div>Apps/resolv.c 文件实现的是DNS，动态域名解析等。</div><div>Apps/webclient.c主要实现HTTP的协议的解析。</div><div> </div><div>首先需要修改User/uip-con.h配置文件：</div><div><pre class="brush:cpp;">#define UIP_CONF_LOGGING         0                //logging off<br><br>//typedef int uip_tcp_appstate_t;            //出错可注释<br>typedef int uip_udp_appstate_t;            //出错可注释<br><br>/<em>#include “smtp.h”</em>/<br>/<em>#include “hello-world.h”</em>/<br>/<em>#include “telnetd.h”</em>/<br>/<em>#include “webserver.h”</em>/<br>/<em>#include “dhcpc.h”</em>/<br>/<em>#include “resolv.h”</em>/<br>#include “webclient.h”                  //包含WebClient 文件<br><br>#include “app_call.h”                    //加入一个Uip的数据接口文件</pre><div>修改User/mainc &nbsp;调用相关WebClient函数 配置DNS以及设定页面地址</div><a id="more"></a><div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br>#include “string.h”<br><br>#include “uip.h”<br>#include “uip_arp.h”<br>#include “tapdev.h”<br>#include “timer.h”<br>#include “ENC28J60.h”<br>#include “SPI.h”<br><br>#define     PRINTF_ON  1<br><br>#define BUF ((struct uip_eth_hdr <em>)&amp;uip_buf[0])<br><br>#ifndef NULL<br>#define NULL (void </em>)0<br>#endif /<em> NULL </em>/<br><br>static unsigned char mymac[6] = {0x04,0x02,0x35,0x00,0x00,0x01};<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void USART_Configuration(void);<br><br>int main(void)<br>{<br>    int i;<br>    uip_ipaddr_t ipaddr;<br>    struct timer periodic_timer, arp_timer;<br><br>      RCC_Configuration();<br>      GPIO_Configuration();<br>    USART_Configuration();<br>    SPInet_Init();<br><br>    timer_set(&amp;periodic_timer, CLOCK_SECOND / 2);<br>    timer_set(&amp;arp_timer, CLOCK_SECOND <em> 10);<br><br>    SysTick_Config(72000);<br><br>      //以太网控制器驱动初始化<br>    tapdev_init(mymac);<br><br>      //Uip 协议栈初始化<br>      uip_init();<br></em></pre><pre class="brush:cpp;">    uip_ipaddr(ipaddr, 192, 168, 1, 15);     //配置Ip<br>    uip_sethostaddr(ipaddr);<br>    uip_ipaddr(ipaddr, 192, 168, 1, 1);     //配置网关<br>    uip_setdraddr(ipaddr);<br>    uip_ipaddr(ipaddr, 255, 255, 255, 0);   //配置子网掩码<br>    uip_setnetmask(ipaddr);<br><br>    webclient_init();<br>    resolv_init();<br>    uip_ipaddr(ipaddr, 8,8,8,8); //DNS server ,Google DNS Server<br>    resolv_conf(ipaddr);<br>       resolv_query(“<a href="http://www.ichanging.org&quot;)" target="_blank" rel="noopener">www.ichanging.org&quot;)</a>;<br><br>      while(1){<br><br>        uip_len = tapdev_read();                                 //从网卡读取数据<br><br>        if(uip_len &gt; 0)<br>        {                                                        //如果数据存在则按协议处理<br>            if(BUF-&gt;type == htons(UIP_ETHTYPE_IP)) {            //如果收到的是IP数据，调用uip_input()处理<br><br>                uip_arp_ipin();<br>                uip_input();<br><br>                / If the above function invocation resulted in data that<br>                   should be sent out on the network, the global variable uip_len is set to a value &gt; 0. <em>/<br><br>                if(uip_len &gt; 0)<br>                {<br>                  uip_arp_out();<br>                  tapdev_send();<br>                }<br><br>              }else if(BUF-&gt;type == htons(UIP_ETHTYPE_ARP)){     //如果收到的是ARP数据，调用uip_arp_arpin处理<br><br>                uip_arp_arpin();<br><br>                /</em> If the above function invocation resulted in data that<br>                   should be sent out on the network, the global variable uip_len is set to a value &gt; 0. <em>/<br><br>                if(uip_len &gt; 0)<br>                {<br>                  tapdev_send();<br>                }<br>            }<br><br>        }else if(timer_expired(&amp;periodic_timer)){            //查看0.5s是否到了，调用uip_periodic处理TCP超时程序<br><br>              timer_reset(&amp;periodic_timer);<br>              for(i = 0; i &lt; UIP_CONNS; i++) {<br><br>                    uip_periodic(i);<br><br>                    /</em> If the above function invocation resulted in data that<br>                       should be sent out on the network, the global variable uip_len is set to a value &gt; 0. <em>/<br><br>                    if(uip_len &gt; 0)<br>                    {<br>                      uip_arp_out();<br>                      tapdev_send();<br>                    }<br>              }<br><br>                for(i = 0; i &lt; UIP_UDP_CONNS; i++)<br>              {<br><br>                    uip_udp_periodic(i);                                //处理udp超时程序<br><br>                    /</em> If the above function invocation resulted in data that<br>                       should be sent out on the network, the global variable uip_len is set to a value &gt; 0. <em>/<br><br>                    if(uip_len &gt; 0)<br>                    {<br>                      uip_arp_out();<br>                      tapdev_send();<br>                    }<br>              }<br><br>              /</em> Call the ARP timer function every 10 seconds. <em>/             //10s到了就处理ARP<br>              if(timer_expired(&amp;arp_timer))<br>              {<br>                    timer_reset(&amp;arp_timer);<br>                    uip_arp_timer();<br>              }<br>        }<br>    }<br><br>}<br><br>/<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></em>WebClient Set<strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><br>void resolv_found(char <em>name, u16_t </em>ipaddr)            //DNS 找到对应服务器IP<br>{<br>      //u16_t <em>ipaddr2;<br><br>    if(ipaddr == NULL) {<br>        printf(“Host ‘%s’ not found.\n”, name);<br>    } else {<br>        printf(“Found name ‘%s’ = %d.%d.%d.%d\n”, name,<br>           htons(ipaddr[0]) &gt;&gt; 8,<br>           htons(ipaddr[0]) &amp; 0xff,<br>           htons(ipaddr[1]) &gt;&gt; 8,<br>           htons(ipaddr[1]) &amp; 0xff);<br>          if(webclient_get(“<a href="http://www.ichanging.org&quot;" target="_blank" rel="noopener">www.ichanging.org&quot;</a>, 80, “/index.php”))<br>          {<br>              printf(“the connection was initiated”);<br>          }else{<br>              printf(“the host name could not be found in the cache  or TCP connection could not be created.”);<br>          }<br>    }<br>}<br><br>void webclient_closed(void)<br>{<br>  //printf(“Webclient: connection closed\n”);<br>}<br>void webclient_aborted(void)<br>{<br>  //printf(“Webclient: connection aborted\n”);<br>}<br>void webclient_timedout(void)<br>{<br>  //printf(“Webclient: connection timed out\n”);<br>}<br>void webclient_connected(void)<br>{<br>  //printf(“Webclient: connected, waiting for data…\n”);<br>}<br>void webclient_datahandler(char </em>data, u16_t len)<br>{<br>  //printf(“Webclient: got %d bytes of data.\n”, len);<br>}<br><br>/<strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong>Stm32 Set<strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><br>void GPIO_Configuration(void)<br>{<br>      GPIO_InitTypeDef GPIO_InitStructure;<br>       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>}<br><br>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /<em> 复位系统时钟设置</em>/<br>      RCC_DeInit();<br>      /<em> 开启HSE</em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /<em> 等待HSE起振并稳定</em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /<em> 判断HSE起是否振成功，是则进入if()内部 </em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /<em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 </em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /<em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 </em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /<em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 </em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /<em> 设置FLASH延时周期数为2 </em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /<em> 使能FLASH预取缓存 </em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /<em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz </em> 9 = 72MHz <em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /</em> 使能PLL <em>/<br>        RCC_PLLCmd(ENABLE);<br>        /</em> 等待PLL输出稳定 <em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /</em> 选择SYSCLK时钟源为PLL <em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /</em> 等待PLL成为SYSCLK时钟源 <em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /</em> 打开APB2总线上的GPIOA时钟<em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>#if     PRINTF_ON<br><br>int fputc(int ch,FILE </em>f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br><br>#endif<br></pre></div></div><div><span style="line-height: 25.91666603088379px;">——————————————————</span><br>    <span style="line-height: 25.91666603088379px;">2012 11 17 更新</span><br>    <span style="line-height: 25.91666603088379px;">——————————————————</span><br>    <span style="line-height: 25.883333206176758px;">一直不知道如何给一个嵌入式设备通过公网直接发送信息，因为嵌入式设备没有一个固定的公网IP, 其实可以通过一种逆向的方法来解决，嵌入式设备可以定时向服务器主动提交请求，服务器可以再返回数据或指令，嵌入式设备获取后再分析处理。&nbsp;</span></div><div> </div><div>这样使用webclient 就可以实现更多的功能，webclient 定时向服务器请求页面，并获取页面返回的代码，就可以分析返回的代码，执行相应程序。</div><div> </div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;Uip WebClient 实现的功能是接入互联网，通过http协议访问某个网站。HTTP是一种应用层协议。基于TCP/IP。&amp;nbsp;&amp;nbsp;TCP/IP作为传输层协议解决数据如何在网络中传输，HTTP作为应用层协议，解决如何包装数据。默认的HTTP访问端口为80端口。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;Uip + stm32 的移植参见&amp;nbsp;&lt;a href=&quot;http://www.ichanging.org/uip-stm32.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Uip + Stm32移植问题总结&lt;/a&gt;&lt;span style=&quot;text-align: left; &quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;相关文件：&lt;/div&gt;&lt;div&gt;Apps/resolv.c 文件实现的是DNS，动态域名解析等。&lt;/div&gt;&lt;div&gt;Apps/webclient.c主要实现HTTP的协议的解析。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;首先需要修改User/uip-con.h配置文件：&lt;/div&gt;&lt;div&gt;&lt;pre class=&quot;brush:cpp;&quot;&gt;#define UIP_CONF_LOGGING         0                //logging off&lt;br&gt;&lt;br&gt;//typedef int uip_tcp_appstate_t;            //出错可注释&lt;br&gt;typedef int uip_udp_appstate_t;            //出错可注释&lt;br&gt;&lt;br&gt;/&lt;em&gt;#include “smtp.h”&lt;/em&gt;/&lt;br&gt;/&lt;em&gt;#include “hello-world.h”&lt;/em&gt;/&lt;br&gt;/&lt;em&gt;#include “telnetd.h”&lt;/em&gt;/&lt;br&gt;/&lt;em&gt;#include “webserver.h”&lt;/em&gt;/&lt;br&gt;/&lt;em&gt;#include “dhcpc.h”&lt;/em&gt;/&lt;br&gt;/&lt;em&gt;#include “resolv.h”&lt;/em&gt;/&lt;br&gt;#include “webclient.h”                  //包含WebClient 文件&lt;br&gt;&lt;br&gt;#include “app_call.h”                    //加入一个Uip的数据接口文件&lt;/pre&gt;&lt;div&gt;修改User/mainc &amp;nbsp;调用相关WebClient函数 配置DNS以及设定页面地址&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Uip + Stm32移植问题总结</title>
    <link href="http://neil-pan.com/2012/07/26/Uip-Stm32%E7%A7%BB%E6%A4%8D%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://neil-pan.com/2012/07/26/Uip-Stm32移植问题总结/</id>
    <published>2012-07-26T13:37:49.000Z</published>
    <updated>2024-07-11T12:49:21.210Z</updated>
    
    <content type="html"><![CDATA[<div>uIP 由瑞典计算机科学学院(网络嵌入式系统小组)的Adam Dunkels （<a href="http://dunkels.com/adam/uip/）开发。其源代码由C" target="_blank" rel="noopener">http://dunkels.com/adam/uip/）开发。其源代码由C</a> 语言编写，并完全公开，有了这个TCP/IP协议栈，让嵌入式可以实现的功能更为丰富。可以作为<a href="http://www.ichanging.org/uip-webclient.html" target="_blank" rel="noopener">WebClient</a> 向指定网站提交数据，可以作为<a href="http://www.ichanging.org/uip-webserver.html" target="_blank" rel="noopener">WebServer</a>作为网页服务器，提供一个小型的动态页面访问功能。由于是开源的免费协议栈，据说Uip没有考虑协议安全的问题。</div><div> </div><div>首先介绍下移植的环境： stm32 +&nbsp;ENC28J60网络模块&nbsp;</div><div> </div><div><img src="/uploads/2012/07/1880526909.jpg" alt="IMG_20100101_103506.jpg"></div><div> </div><div>Enc28j60是带SPI 接口的独立以太网控制器，可以用mcu控制spi来实现tcp/ip数据流的收发，所以要先完成Enc28j60的驱动程序，再整合Uip。Uip是用标准的C语言实现，所以移植Uip在51单片机和stm32上类似。</div><div> </div><div>经过几天的琢磨，已经将Uip的几个示例稳定运行。Uip中apps下的例子相互之间存在冲突，源程序中也有一些Error 要修改，我将Uip的文件结构做了一些调整。</div><a id="more"></a><div> </div><div><strong>Uip文件结构</strong></div><div> </div><div>先介绍下Uip下各个目录文件的功能：</div><div> </div><div><span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">├─apps</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apps目录 下为uip提供的一些应用示例<br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp; ├─dhcpc</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp; ├─hello-world</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp; ├─resolv</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp; ├─smtp</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp; ├─telnetd</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp; ├─webclient</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp; └─webserver</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; └─httpd-fs</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">├─doc</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; doc下放置的为说明文档，程序中用不上 &nbsp;<br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">│&nbsp; └─html</span><br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">├─lib</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lib下为内存块管理函数源码<br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">├─uip</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;uip下为uip和核心实现源码&nbsp;<br>    <span style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.44444465637207px; letter-spacing: normal; line-height: 25.55555534362793px; text-align: left; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">└─unix</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unix环境里的uip应用例子,可以参照这个例子实现应用</div><div> </div><div><strong>Uip+stm32 MDK下工程建立</strong></div><div> </div><div><img src="/uploads/2012/07/563037952.png" alt="QQ截图20120726204704.png"></div><div>stm32的目录结构建立可以参考&nbsp;<a href="http://www.ichanging.org/mdk-stm32lib-set.html" target="_blank" rel="noopener">stm32 开发环境MDK+库文件配置</a><span style="text-align: left; ">&nbsp;</span></div><div> </div><div>User 放置 stm32 SPI配置以及Uip配置和Enc28j60和Uip的接口函数</div><div> </div><div> </div><div> </div><div> </div><div>uip下为uip的核心实现源码以及内存管理源码（即为Uip/uip+Uip/lib）</div><div>dev下为Enc28j60的驱动函数源码</div><div>apps为uip的各个示例应用源码（Uip/apps下的文件）包括smtp,rsolve,dhcp，telnetd,以及webclient</div><div> </div><div>webserver 的文件结构较为复杂，独立一个文件夹</div><div> </div><div> </div><div><strong>Uip移**</strong>植<strong></strong></div><div> </div><div>Uip的移植可以参考uip的unix的文件结构。</div><div> </div><div>1. Uip的数据通过网卡Enc28j60从物理层剥离，所以需要先配置Uip和Enc28j60的数据交互。这个部分在tapdev.c文件中：</div><div><pre class="brush:cpp;">#include “uip.h”<br>#include “ENC28J60.h”<br><br>/<em>—————————————————————————</em>/<br>void<br>tapdev_init(unsigned char <em>my_mac)<br>{<br>    enc28j60Init(my_mac);<br>}<br>/</em>—————————————————————————<em>/<br>unsigned int<br>tapdev_read(void)<br>{<br>    return enc28j60PacketReceive(UIP_CONF_BUFFER_SIZE,uip_buf);<br>}<br>/</em>—————————————————————————<em>/<br>void<br>tapdev_send(void)<br>{<br>    enc28j60PacketSend(uip_len,uip_buf);<br>}<br>/</em>—————————————————————————<em>/</em></pre><div><div>写网卡驱动程序，与具体硬件相关。这一步比较费点时间，不过好在大部分网卡芯片的驱动程序都有代码借鉴或移植。驱动需要提供三个函数，以Enc28j60 驱动为例。</div><div>tapdev_init（）：网卡初始化函数，初始化网卡的工作模式。</div><div>tapdev_read(void)：读包函数。将网卡收到的数据放入全局缓存区uip_buf 中，返回包的长度，赋给uip_len。</div><div>void tapdev_send(void)：发包函数。将全局缓存区uip_buf 里的数据（长度放在uip_len 中）发送出去。</div><div> </div></div><div>2.由于uIP 协议栈需要使用时钟，为TCP 和ARP 的定时器服务。因此使用单片机的定时器或是stm32的滴答定时器用作时钟，每20ms 让计数tick_cnt 加1，这样，25 次计数（0.5S）满了后可以调用TCP 的定时处理程序。10S 后可以调用ARP 老化程序。uIP1.0 版本，增加了timer.c/timer.h，专门用来管理时钟，修改clock-arch.c如下：</div><div><pre class="brush:cpp;">#include “clock-arch.h”<br>#include “stm32f10x.h”<br><br>extern __IO int32_t g_RunTime;<br>/—————————————————————————<em>/<br>clock_time_t<br>clock_time(void)<br>{<br>    return g_RunTime;<br>}<br>/</em>—————————————————————————<em>/</em></pre><div>使用stm32 滴答定时器中断代码：</div><div> </div><div>User/stm32f10x_it.c</div><div><pre class="brush:cpp;">__IO int32_t g_RunTime = 0;<br>void SysTick_Handler(void)<br>{<br>    static uint8_t s_count = 0;<br>    if (++s_count &gt;= 10)<br>    {<br>        s_count = 0;<br><br>        g_RunTime++;    / 全局运行时间每10ms增1 <em>/<br>        if (g_RunTime == 0x80000000)<br>        {<br>            g_RunTime = 0;<br>        }<br>    }<br>}</em></pre></div><div>3.uipopt.h/uip-conf.h 是配置文件，用来设置本地的IP 地址、网关地址、MAC 地址、全局缓冲区的大小、支持的最大连接数、侦听数、ARP 表大小等。可以根据需要配置。</div><div> </div><div><div>#define UIP_FIXEDADDR 1</div><div>决定uIP是否使用一个固定的IP地址。</div><div>如果uIP使用一个固定的IP地址，应该置位（set）这些uipopt.h中的选项。如果不的话，则应该使用宏uip_sethostaddr(),uip_setdraddr() 和 uip_setnetmask()。</div><div> </div><div>#define UIP_PINGADDRCONF 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ping IP地址赋值。</div><div>#define UIP_FIXEDETHADDR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指明uIP ARP模块是否在编译时使用一个固定的以太网MAC地址。</div><div>#define UIP_TTL 255&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uIP发送的IP packets的IP TTL (time to live)。</div><div>#define UIP_REASSEMBLY 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uIP支持IP packets的分片和重组。</div><div>#define UIP_REASS_MAXAGE 40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;一个IP fragment在被丢弃之前可以在重组缓冲区中存在的最大时间。</div><div>#define UIP_UDP 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是否编译UDP的开关。</div><div>#define UIP_ACTIVE_OPEN 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;决定是否支持uIP打开一个连接。</div><div>#define UIP_CONNS 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时可以打开的TCP连接的最大数目。由于TCP连接是静态分配的，减小这个数目将占用更少的RAM。每一个TCP连接需要大约30字节的内存。</div><div>#define UIP_LISTENPORTS 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;同时监听的TCP端口的最大数目。每一个TCP监听端口需要2个字节的内存。</div><div>#define UIP_RECEIVE_WINDOW 32768 &nbsp;&nbsp;建议的接收窗口的大小。如果应用程序处理到来的数据比较慢，那么应该设置的小一点（即，相对与uip_buf缓冲区的大小来说），相反如果应用程序处理数据很快，可以设置的大一点（32768字节）。</div><div>#define UIP_URGDATA 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;决定是否支持TCP urgent data notification。</div><div>#define UIP_RTO 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The initial retransmission timeout counted in timer pulses.不要改变</div><div>#define UIP_MAXRTX 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在中止连接之前，应该重发一个段的最大次数。不要改变</div><div>#define UIP_TCP_MSS (UIP_BUFSIZE – UIP_LLH_LEN – 40) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP段的最大长度。它不能大于UIP_BUFSIZE – UIP_LLH_LEN – 40.</div><div>#define UIP_TIME_WAIT_TIMEOUT 120&nbsp;&nbsp;&nbsp;&nbsp;一个连接应该在TIME_WAIT状态等待多长。不要改变</div><div>#define UIP_ARPTAB_SIZE 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ARP表的大小。如果本地网络中有许多到这个uIP节点的连接，那么这个选项应该设置为一个比较大的值。</div><div>#define UIP_BUFSIZE 1500&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uIP packet缓冲区不能小于60字节，但也不必大于1500字节。</div><div>#define UIP_STATISTICS 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;决定是否支持统计数字。统计数字对调试很有帮助，并展示给用户。</div><div>#define UIP_LOGGING 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;输出uIP登陆信息。</div><div>#define UIP_LLH_LEN 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;链接层头部长度。对于SLIP，应该设置成0。</div></div><div> </div><div>uip-conf.h&nbsp;中增加几个主要结构体定义，不include任何应用</div><div> </div><div><pre class="brush:cpp;">#define UIP_CONF_LOGGING         0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//logging off<br><br>typedef int uip_tcp_appstate_t;            //出错可注释<br>typedef int uip_udp_appstate_t;            //出错可注释<br><br>/#include “smtp.h”<em>/<br>/</em>#include “hello-world.h”<em>/<br>/</em>#include “telnetd.h”<em>/<br>/</em>#include “webserver.h”<em>/<br>/</em>#include “dhcpc.h”<em>/<br>/</em>#include “resolv.h”<em>/<br>/</em>#include “webclient.h”<em>/<br><br>#include “app_call.h”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//加入一个Uip的数据接口文件<br></em></pre></div><div><div>uIP 在接受到底层传来的数据包后，调用UIP_APPCALL( )，将数据送到上层应用程序处理。</div></div><div>User/app_call.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br><br>#ifndef UIP_APPCALL<br>    #define UIP_APPCALL                    Uip_Appcall<br>#endif<br><br>#ifndef UIP_UDP_APPCALL<br>    #define UIP_UDP_APPCALL                Udp_Appcall<br>#endif<br><br>void Uip_Appcall(void);<br>void Udp_Appcall(void);<br><br>void Uip_Appcall(void)<br>{<br><br>}<br><br>void Udp_Appcall(void)<br>{<br><br>}<br></pre></div><div> </div><div>4.加入uIP 的的主循环代码架构</div><div>User/main.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br>#include “string.h”<br><br>#include “uip.h”<br>#include “uip_arp.h”<br>#include “tapdev.h”<br>#include “timer.h”<br>#include “ENC28J60.h”<br>#include “SPI.h”<br><br>#define     PRINTF_ON  1<br><br>#define BUF ((struct uip_eth_hdr )&amp;uip_buf[0])<br><br>#ifndef NULL<br>#define NULL (void <em>)0<br>#endif /</em> NULL <em>/<br><br>static unsigned char mymac[6] = {0x04,0x02,0x35,0x00,0x00,0x01};<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void USART_Configuration(void);<br><br>int main(void)<br>{<br>    int i;<br>    uip_ipaddr_t ipaddr;<br>    struct timer periodic_timer, arp_timer;<br><br>      RCC_Configuration();<br>      GPIO_Configuration();<br>    USART_Configuration();<br>    SPInet_Init();<br><br>    timer_set(&amp;periodic_timer, CLOCK_SECOND / 2);<br>    timer_set(&amp;arp_timer, CLOCK_SECOND </em> 10);<br><br>    SysTick_Config(72000);            //配置滴答计时器<br><br>      //以太网控制器驱动初始化<br>    tapdev_init(mymac);<br><br>      //Uip 协议栈初始化<br>      uip_init();<br><br>    uip_ipaddr(ipaddr, 192, 168, 1, 15);     //配置Ip<br>    uip_sethostaddr(ipaddr);<br>    uip_ipaddr(ipaddr, 192, 168, 1, 1);     //配置网关<br>    uip_setdraddr(ipaddr);<br>    uip_ipaddr(ipaddr, 255, 255, 255, 0);   //配置子网掩码<br>    uip_setnetmask(ipaddr);<br><br>      while(1){<br><br>        uip_len = tapdev_read();                                 //从网卡读取数据<br><br>        if(uip_len &gt; 0)<br>        {                                                        //如果数据存在则按协议处理<br>            if(BUF-&gt;type == htons(UIP_ETHTYPE_IP)) {            //如果收到的是IP数据，调用uip_input()处理<br><br>                uip_arp_ipin();<br>                uip_input();<br><br>                /<em> If the above function invocation resulted in data that<br>                   should be sent out on the network, the global variable uip_len is set to a value &gt; 0. </em>/<br><br>                if(uip_len &gt; 0)<br>                {<br>                  uip_arp_out();<br>                  tapdev_send();<br>                }<br><br>              }else if(BUF-&gt;type == htons(UIP_ETHTYPE_ARP)){     //如果收到的是ARP数据，调用uip_arp_arpin处理<br><br>                uip_arp_arpin();<br><br>                /<em> If the above function invocation resulted in data that<br>                   should be sent out on the network, the global variable uip_len is set to a value &gt; 0. </em>/<br><br>                if(uip_len &gt; 0)<br>                {<br>                  tapdev_send();<br>                }<br>            }<br><br>        }else if(timer_expired(&amp;periodic_timer)){            //查看0.5s是否到了，调用uip_periodic处理TCP超时程序<br><br>              timer_reset(&amp;periodic_timer);<br>              for(i = 0; i &lt; UIP_CONNS; i++) {<br><br>                    uip_periodic(i);<br><br>                    /<em> If the above function invocation resulted in data that<br>                       should be sent out on the network, the global variable uip_len is set to a value &gt; 0. </em>/<br><br>                    if(uip_len &gt; 0)<br>                    {<br>                      uip_arp_out();<br>                      tapdev_send();<br>                    }<br>              }<br><br>                for(i = 0; i &lt; UIP_UDP_CONNS; i++)<br>              {<br><br>                    uip_udp_periodic(i);                                //处理udp超时程序<br><br>                    /<em> If the above function invocation resulted in data that<br>                       should be sent out on the network, the global variable uip_len is set to a value &gt; 0. </em>/<br><br>                    if(uip_len &gt; 0)<br>                    {<br>                      uip_arp_out();<br>                      tapdev_send();<br>                    }<br>              }<br><br>              /<em> Call the ARP timer function every 10 seconds. </em>/             //10s到了就处理ARP<br>              if(timer_expired(&amp;arp_timer))<br>              {<br>                    timer_reset(&amp;arp_timer);<br>                    uip_arp_timer();<br>              }<br>        }<br>    }<br><br>}<br>/<strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong>Stm32 Set<strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br><br>void GPIO_Configuration(void)<br>{<br>      GPIO_InitTypeDef GPIO_InitStructure;<br>      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br>}<br><br>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /<em> 复位系统时钟设置</em>/<br>      RCC_DeInit();<br>      /<em> 开启HSE</em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /<em> 等待HSE起振并稳定</em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /<em> 判断HSE起是否振成功，是则进入if()内部 </em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /<em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 </em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /<em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 </em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /<em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 </em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /<em> 设置FLASH延时周期数为2 </em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /<em> 使能FLASH预取缓存 </em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /<em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz </em> 9 = 72MHz <em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /</em> 使能PLL <em>/<br>        RCC_PLLCmd(ENABLE);<br>        /</em> 等待PLL输出稳定 <em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /</em> 选择SYSCLK时钟源为PLL <em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /</em> 等待PLL成为SYSCLK时钟源 <em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /</em> 打开APB2总线上的GPIOA时钟<em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>#if     PRINTF_ON<br><br>int fputc(int ch,FILE </em>f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br><br>#endif</pre></div><div> </div><div>5.解决编译过程中的错误。归总如下：</div><ul><li>Uip/uip-split.c &nbsp;注释所有的 tcpip_output()函数 &nbsp;消除uip_fw_output()函数的注释</li><li>Uip/memb.c 中 memb_free()函数 返回值 return -1 改为 return 1</li><li>Apps/resolv.c 中resolv_conf() 中&nbsp;<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;//resolv_conn = uip_udp_new(dnsserver, HTONS(53));</div><div>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolv_conn = uip_udp_new((uip_ipaddr_t*)dnsserver, HTONS(53));<span class="Apple-tab-span" style="white-space:pre"></span></div><div> </div><div>解决完所有问题后，编译成功后下载到stm32，ping 测试。。</div><div> </div><div><img src="/uploads/2012/07/1953523001.png" alt="QQ截图20120726201101.png"></div><div> </div><div> </div></li></ul></div></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;uIP 由瑞典计算机科学学院(网络嵌入式系统小组)的Adam Dunkels （&lt;a href=&quot;http://dunkels.com/adam/uip/）开发。其源代码由C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dunkels.com/adam/uip/）开发。其源代码由C&lt;/a&gt; 语言编写，并完全公开，有了这个TCP/IP协议栈，让嵌入式可以实现的功能更为丰富。可以作为&lt;a href=&quot;http://www.ichanging.org/uip-webclient.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebClient&lt;/a&gt; 向指定网站提交数据，可以作为&lt;a href=&quot;http://www.ichanging.org/uip-webserver.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebServer&lt;/a&gt;作为网页服务器，提供一个小型的动态页面访问功能。由于是开源的免费协议栈，据说Uip没有考虑协议安全的问题。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;首先介绍下移植的环境： stm32 +&amp;nbsp;ENC28J60网络模块&amp;nbsp;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/1880526909.jpg&quot; alt=&quot;IMG_20100101_103506.jpg&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;Enc28j60是带SPI 接口的独立以太网控制器，可以用mcu控制spi来实现tcp/ip数据流的收发，所以要先完成Enc28j60的驱动程序，再整合Uip。Uip是用标准的C语言实现，所以移植Uip在51单片机和stm32上类似。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;经过几天的琢磨，已经将Uip的几个示例稳定运行。Uip中apps下的例子相互之间存在冲突，源程序中也有一些Error 要修改，我将Uip的文件结构做了一些调整。&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 SPI通信[操作寄存器+库函数]</title>
    <link href="http://neil-pan.com/2012/07/14/stm32-SPI%E9%80%9A%E4%BF%A1-%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/14/stm32-SPI通信-操作寄存器-库函数/</id>
    <published>2012-07-14T09:57:31.000Z</published>
    <updated>2024-07-11T12:49:21.224Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp;&nbsp;&nbsp;&nbsp;SPI(Serial Peripheral Interface–串行外设接口) 总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。 SPI是Freescale(原 Motorola)公司首先在其处理器上定义的。</div><div>&nbsp; &nbsp; SPI是一种高速、主从式、全双工、同步传输的通信总线，SPI总线在物理层体现为四根传输线：</div><div><br><br><em>   MOSI (Master Output Slaver Input) – 主器件数据输出，从器件数据输入</em>   MISO (Master Input Slaver Output)&nbsp;&nbsp;– 主器件数据输入，从器件数据输出<br><em>   SCLK – 时钟信号，由主器件产生</em>   NSS – 从器件使能信号，由主器件控制,有的IC会标注为CS(Chip select)<div>&nbsp;&nbsp;&nbsp;&nbsp;CS线用于控制片选信号，当一个SPI从设备的CS线识别到了预先规定的片选电平，则该设备被选中。显然可以通过CS线，完成“一主多从”的SPI网络架设，在进行“一主一从”的SPI通信时，SPI并不是必须的。</div><div>&nbsp; &nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;SPI总线传输数据时，由主机的SCLK线提供时钟脉冲，从机被动的接收时钟脉冲。主机在数据发送前，将数据写入数据寄存器，等待时钟脉冲移位输出，每个脉冲周期传输1位数据。 从机在主机的数据发送中，依靠主机的时钟，将从机的数据寄存器内容移位发送。所以<strong>要实现主从数据交换，在时钟信号前，主机 从机都必须先将数据写入数据寄存器，并且从机必须在主机前写入，然后由主机的SCLK时钟驱动发送</strong>。 不注意这个问题很容易造成SPI接收的数据错位。</div><div> </div><div>&nbsp; &nbsp; 这样的全双工、同步传输完全依赖于 主机控制的时钟线SCLK，而且SCLK上只有数据传输的时候才有时钟信号。主机向从机发送数据不会有问题，但是如果从机主动向主机发送数据呢？&nbsp;</div><div>&nbsp; &nbsp; 从机要发送数据，必须要有SCLK的时钟，所以只能主机发送一个DUMMY（哑巴）字节，产生时钟，来实现和从机的数据交换。 从设备只能被动发送数据，无法主动发送数据。</div><div> </div><div><strong>&nbsp; &nbsp; 本例实现 通过将STM32上的2个SPI接口对接，进行一个简单的数据交换。使用SPI1作为主设备，SPI2作为从设备，通过串口查看数据通信的情况。</strong></div><div></div><div>实现结果如下：</div><div><img src="/uploads/2012/07/4257083322.png" alt="spi.png"></div><div> </div><a id="more"></a><div> </div><div><strong>直接操作寄存器</strong></div><div> </div><div>首先配置SPI主机的频率</div><div>SPI1设备属于高速设备，隶属APB2总线，最大时钟72Mhz;</div><div>SPI2属于低速设备，隶属APB1总线，最大36Mhz。</div><div> </div><div>在控制寄存器中设置时钟分频值，设置时钟极性和相位等。程序中有注释，详见代码：</div><div> </div><div>User/main.c &nbsp;<span style="text-align: left; ">（system.h 和&nbsp;</span><span style="text-align: left; ">stm32f10x_it.h</span><span style="text-align: left; ">&nbsp;等相关代码参照&nbsp;</span><a href="http://www.ichanging.org/mdk-stm32Register-set.html" target="_blank" rel="noopener">stm32 直接操作寄存器开发环境配置</a><span style="text-align: left; ">）</span></div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br>#include “system.h”<br>#include “usart.h”<br>#include “spi.h”<br><br>#define LED1 PAout(4)<br>#define LED2 PAout(5)<br>#define LED3 PAout(6)<br>#define LED4 PAout(7)<br><br>void Gpio_Init(void);<br><br>#define BufferSize 32<br><br>u8 SPI1_Buffer_Tx[BufferSize] =<br>{<br>    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,<br>    0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,<br>    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,<br>    0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20<br>};<br><br>u8 SPI2_Buffer_Tx[BufferSize] =<br>{<br>    0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,<br>    0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,<br>    0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,<br>    0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70<br>};<br><br>u8 SPI1_Buffer_Rx[BufferSize] = {0xFF};<br>u8 SPI2_Buffer_Rx[BufferSize] = {0xFF};<br>u8 Tx_Counter = 0;<br>u8 Rx_Counter = 0;<br><br>int main(void)<br>{<br>      u8 k=0;<br><br>    Rcc_Init(9);                            //系统时钟设置<br><br>    Usart1_Init(72,9600);<br><br>    Nvic_Init(1,0,SPI1_IRQChannel,4);      //设置抢占优先级为1，响应优先级为0，中断分组为4<br>    Nvic_Init(1,1,SPI2_IRQChannel,4);      //设置抢占优先级为1，响应优先级为1，中断分组为4<br><br>    Gpio_Init();<br><br>    Spi_Init(SPI1);<br>    Spi_Init(SPI2);<br><br>     while(Tx_Counter &lt; BufferSize)<br>    {<br><br>        Spi_Write(SPI2,SPI2_Buffer_Tx[Tx_Counter]);            //必须先将从设备数据写入数据寄存器，等待时钟同步<br><br>        Spi_Write(SPI1,SPI1_Buffer_Tx[Tx_Counter]);              //主设备将数据写入数据寄存器，触发同步时钟，让主从数据寄存器由此时钟发送<br><br>        SPI2_Buffer_Rx[Rx_Counter] = Spi_Read(SPI2);<br><br>        SPI1_Buffer_Rx[Rx_Counter] = Spi_Read(SPI1);<br><br>        Tx_Counter++;<br>        Rx_Counter++;<br><br>    }<br><br>    printf(“\r\n The SPI1 has sended data below : \r\n”);<br><br>    while(k&lt;BufferSize)<br>    {<br>        printf(“ %0.2d \r “,SPI1_Buffer_Tx[k]);<br>        k++;<br>    }<br><br>    printf(“\r\n The SPI2 has received data below : \r\n”);<br><br>    k=0;<br><br>    while(k&lt;BufferSize)<br>    {<br>        printf(“ %0.2d \r “,SPI2_Buffer_Rx[k]);<br>        k++;<br>    }<br><br>    k=0;<br><br>    printf(“\r\n The SPI2 has sended data below : \r\n”);<br><br>    while(k&lt;BufferSize)<br>    {<br>        printf(“ %0.2d \r “,SPI2_Buffer_Tx[k]);<br>        k++;<br>    }<br><br>    printf(“\r\n The SPI1 has received data below : \r\n”);<br><br>    k=0;<br><br>    while(k&lt;BufferSize)<br>    {<br>        printf(“ %0.2d \r “,SPI1_Buffer_Rx[k]);<br>        k++;<br>    }<br><br>    while(1);<br>}<br><br>void Gpio_Init(void)<br>{<br>    RCC-&gt;APB2ENR |= 1&lt;&lt;2;            //使能PORTA时钟<br>    RCC-&gt;APB2ENR |= 1&lt;&lt;3;            //使能PORTB时钟;<br><br>    //SPI1 I/O设置<br><br>    GPIOA-&gt;CRL &amp;= 0x000FFFFF;         //PA 5,6,7 复用<br>    GPIOA-&gt;CRL |= 0xBBB00000;<br><br>    //SPI2 I/O设置<br><br>    GPIOB-&gt;CRH &amp;= 0x000FFFFF;         //PB 13,14,15 复用<br>    GPIOB-&gt;CRH |= 0xBBB00000;<br><br>    //USART1 串口I/O设置<br><br>    GPIOA -&gt; CRH &amp;= 0xFFFFF00F;       //设置USART1 的Tx(PA.9)为第二功能推挽，50MHz；Rx(PA.10)为浮空输入<br>    GPIOA -&gt; CRH |= 0x000008B0;<br><br>} </pre><div>User/stm32f10x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<br>#include “system.h”<br>#include “stdio.h”<br><br>#define LED1 PAout(4)<br>#define LED2 PAout(5)<br>#define LED3 PAout(6)<br>#define LED4 PAout(7)<br><br>void SPI1_IRQHandler()<br>{<br>    if(SPI1-&gt;SR &amp; 1&lt;&lt;7)        //SPI正忙于通信，或者发送缓冲非空<br>    {<br>        printf(“SPI1 is Busy”);<br>    }<br><br>    if(SPI1-&gt;SR &amp; 1&lt;&lt;6)        // 出现溢出错误<br>    {<br>        printf(“SPI1 is Overrun”);<br>    }<br><br>    if(SPI1-&gt;SR &amp; 1&lt;&lt;5)        //出现模式错误<br>    {<br>        printf(“SPI1 is Mode fault”);<br>    }<br><br>    if(SPI1-&gt;SR &amp; 1&lt;&lt;4)        //收到的CRC值和SPI_RXCRCR寄存器中的值不匹配<br>    {<br>        printf(“SPI1 is CRC Error”);<br>    }<br><br>    printf(“SPI1 Error”);<br><br>}<br><br>void SPI2_IRQHandler()<br>{<br>    printf(“SPI2 Error”);<br><br>}</pre><div>Library/src/spi.c</div><div><pre class="brush:cpp;">#include “spi.h”<br><br>//SPI初始化函数<br>//SPI1主机模式，SPI2从机模式，8bit数据格式，时钟空闲保持为低，数据采样从第二个时钟边沿开始，波特率 fPCLK/32<br>//先发送LSB（最低有效位），禁止硬件CRC校验<br>void Spi_Init(SPI_TypeDef <em> SPIx)<br>{<br>    if(SPIx == SPI1){<br><br>        RCC -&gt; APB2ENR  |= 1&lt;&lt;12;     //SPI1时钟使能<br>        RCC -&gt; APB2RSTR |= 1&lt;&lt;12;      //复位SPI1寄存器<br>        RCC -&gt; APB2RSTR &amp;= ~(1&lt;&lt;12);  //复位结束SPI1寄存器<br><br>        SPIx -&gt; CR1 |= 1&lt;&lt;2;         //主设备选择   0：配置为从设备   1：配置为主设备<br>        SPIx -&gt; CR1 |= 1&lt;&lt;8;         //SSI位，要保持主机模式,必须NSS 接到高电平信号<br><br>    }else if(SPIx == SPI2){<br>        RCC -&gt; APB1ENR  |= 1&lt;&lt;14;     //SPI2时钟使能<br>        RCC -&gt; APB1RSTR |= 1&lt;&lt;14;      //复位SPI2寄存器<br>        RCC -&gt; APB1RSTR &amp;= ~(1&lt;&lt;14);  //复位结束SPI2寄存器<br>        SPIx -&gt; CR1 |= 0&lt;&lt;2;         //主设备选择   0：配置为从设备   1：配置为主设备<br>        //SPIx -&gt; CR1 |= 0&lt;&lt;8;         //SSI位，要保持主机模式,必须NSS 接到高电平信号<br>    }<br><br>    SPIx -&gt; CR1 |= 0&lt;&lt;10;         //设置全双工模式  0：全双工(发送和接收)   1：禁止输出(只接收模式)<br>    SPIx -&gt; CR1 |= 0&lt;&lt;11;         //数据帧格式  0：使用8位数据帧格式进行发送/接收   1：使用16位数据帧格式进行发送/接收<br>       SPIx -&gt; CR1 |= 1&lt;&lt;7;         //帧格式          0：先发送MSB  1：先发送LSB<br><br>    //配置NSS为GPIO输出口控制从设备片选<br>    SPIx -&gt; CR1 |= 1&lt;&lt;9;         //软件从设备管理 当此位(SSM)被置位时，NSS引脚上的电平由SSI位的值决定。<br><br>    SPIx -&gt; CR1 |= 0&lt;&lt;1;         //配置时钟极性 0： 空闲状态时，SCK保持低电平  1： 空闲状态时，SCK保持高电平<br>    SPIx -&gt; CR1 |= 1&lt;&lt;0;         //时钟相位     0： 数据采样从第一个时钟边沿开始  1： 数据采样从第二个时钟边沿开始<br><br>    SPIx -&gt; CR1 |= 4&lt;&lt;3;         //波特率控制[5:3]  000： fPCLK/2   001： fPCLK/4   010： fPCLK/8  011： fPCLK/16  100： fPCLK/32<br>                                 //                 101： fPCLK/64    110： fPCLK/128 111： fPCLK/256<br><br>    //SPIx -&gt; CR2 |= 1&lt;&lt;7;         //发送缓冲区空中断使能<br>    //SPIx -&gt; CR2 |= 1&lt;&lt;6;         //接收缓冲区非空中断使能<br>    SPIx -&gt; CR2 |= 1&lt;&lt;5;         //错误中断使能<br><br>    SPIx -&gt; CR1 |= 1&lt;&lt;6;         //SPI设备使能<br><br>}<br><br>void Spi_Write(SPI_TypeDef </em> SPIx,u8 data)<br>{<br>    //while((SPIx-&gt;SR&amp;1&lt;&lt;1) == 0);    //等待发送缓冲为空置位<br><br>    SPIx-&gt;DR = data;<br><br>    Spi_Delay(3);                    //必须稍作延时<br>}<br><br>u8 Spi_Read(SPI_TypeDef <em> SPIx)<br>{<br><br>    //while((SPIx-&gt;SR&amp;1&lt;&lt;0) == 1);    //等待接收缓冲非空置位<br><br>    return SPIx-&gt;DR;<br><br>}<br><br>void Spi_Delay(u32 us)<br>{<br>    u32 time=100</em>us/7;<br>    while(–time);<br>}</pre><div>Library/inc/spi.h</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br><br>void Spi_Init(SPI_TypeDef <em> SPIx);<br>void Spi_Write(SPI_TypeDef </em> SPIx,u8 data);<br>u8   Spi_Read(SPI_TypeDef <em> SPIx);<br>void Spi_Delay(u32 us);</em></pre></div></div></div></div><div> </div></div><div><strong>操作库函数</strong></div><div> </div><div>main.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br>#include “string.h”<br><br>#define     PRINTF_ON  1<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void USART_Configuration(void);<br>void SPI_Configuration(void);<br><br>#define BufferSize 32<br><br>#define delay() for(i=0;i&lt;200;i++)<br><br>SPI_InitTypeDef SPI_InitStructure;<br><br>u8 SPI1_Buffer_Tx[BufferSize] =<br>{<br>    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,<br>     0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,<br>     0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,<br>     0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20<br>};<br><br>u8 SPI2_Buffer_Tx[BufferSize] =<br>{<br>    0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,<br>    0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,<br>    0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,<br>    0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70<br>};<br><br>u8 SPI1_Buffer_Rx[BufferSize+1] = {0};<br>u8 SPI2_Buffer_Rx[BufferSize] = {0};<br>u8 Tx_Counter = 0;<br>u8 Rx_Counter = 0;<br>u8 k=0,i=0;<br><br>int main(void)<br>{<br>      RCC_Configuration();<br>    GPIO_Configuration();<br>    USART_Configuration();<br>    SPI_Configuration();<br><br>    while(Tx_Counter &lt; BufferSize)<br>    {<br>        SPI_I2S_SendData(SPI2,SPI2_Buffer_Tx[Tx_Counter]);                //必须从机先发送数据<br>        //while(SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_TXE)==RESET);     //如果spi2 还有发送缓存则等待发送完成<br><br>        SPI_I2S_SendData(SPI1,SPI1_Buffer_Tx[Tx_Counter]);<br><br>        while(SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_RXNE) == RESET);    //没有接收缓存则等待<br>        SPI2_Buffer_Rx[Rx_Counter] = SPI_I2S_ReceiveData(SPI2);<br><br>        while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) ==RESET);<br><br>        SPI1_Buffer_Rx[Rx_Counter] = SPI_I2S_ReceiveData(SPI1);<br><br>        Tx_Counter++;<br>        Rx_Counter++;<br>    }<br><br>    printf(“\r\n The SPI1 has sended data below : \r\n”);<br><br>    while(k&lt;BufferSize)<br>    {<br>        printf(“ %0.2d \r “,SPI1_Buffer_Tx[k]);<br>        k++;<br>    }<br><br>    printf(“\r\n The SPI2 has received data below : \r\n”);<br><br>    k=0;<br><br>    while(k&lt;BufferSize)<br>    {<br>        printf(“ %0.2d \r “,SPI2_Buffer_Rx[k]);<br>        k++;<br>    }<br><br>    k=0;<br><br>    printf(“\r\n The SPI2 has sended data below : \r\n”);<br><br>    while(k&lt;BufferSize)<br>    {<br>        printf(“ %0.2d \r “,SPI2_Buffer_Tx[k]);<br>        k++;<br>    }<br><br>    printf(“\r\n The SPI1 has received data below : \r\n”);<br><br>    k=0;<br><br>    while(k&lt;BufferSize)<br>    {<br>        printf(“ %0.2d \r “,SPI1_Buffer_Rx[k]);<br>        k++;<br>    }<br><br>    while(1);<br>}<br><br>void SPI_Configuration(void)<br>{<br><br>    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;<br>    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;<br>    SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;<br>    SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;<br>    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;<br>    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;<br>    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_LSB;<br>    SPI_InitStructure.SPI_CRCPolynomial = 7;<br><br>    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;<br>    SPI_Init(SPI1,&amp;SPI_InitStructure);<br><br>    SPI_InitStructure.SPI_Mode = SPI_Mode_Slave;<br>    SPI_Init(SPI2,&amp;SPI_InitStructure);<br><br>    SPI_Cmd(SPI1,ENABLE);<br>    SPI_Cmd(SPI2,ENABLE);<br><br>}<br><br>void GPIO_Configuration(void)<br>{<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br><br>     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOB , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br>}<br><br>void RCC_Configuration(void)<br>{<br>    / 定义枚举类型变量 HSEStartUpStatus <em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /</em> 复位系统时钟设置<em>/<br>      RCC_DeInit();<br>      /</em> 开启HSE<em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /</em> 等待HSE起振并稳定<em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /</em> 判断HSE起是否振成功，是则进入if()内部 <em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /</em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 <em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /</em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 <em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /</em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 <em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /</em> 设置FLASH延时周期数为2 <em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /</em> 使能FLASH预取缓存 <em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /</em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz <em> 9 = 72MHz </em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /<em> 使能PLL </em>/<br>        RCC_PLLCmd(ENABLE);<br>        /<em> 等待PLL输出稳定 </em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /<em> 选择SYSCLK时钟源为PLL </em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /<em> 等待PLL成为SYSCLK时钟源 </em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /<em> 打开APB2总线上的GPIOA时钟</em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_USART1|RCC_APB2Periph_SPI1, ENABLE);<br><br>    //RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<br><br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);<br>    //RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP|RCC_APB1Periph_WWDG, ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>#if     PRINTF_ON<br><br>int fputc(int ch,FILE *f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br><br>#endif</pre></div><div> </div><div> </div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SPI(Serial Peripheral Interface–串行外设接口) 总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。 SPI是Freescale(原 Motorola)公司首先在其处理器上定义的。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; SPI是一种高速、主从式、全双工、同步传输的通信总线，SPI总线在物理层体现为四根传输线：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;em&gt;   MOSI (Master Output Slaver Input) – 主器件数据输出，从器件数据输入
&lt;/em&gt;   MISO (Master Input Slaver Output)&amp;nbsp;&amp;nbsp;– 主器件数据输入，从器件数据输出&lt;br&gt;&lt;em&gt;   SCLK – 时钟信号，由主器件产生
&lt;/em&gt;   NSS – 从器件使能信号，由主器件控制,有的IC会标注为CS(Chip select)&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CS线用于控制片选信号，当一个SPI从设备的CS线识别到了预先规定的片选电平，则该设备被选中。显然可以通过CS线，完成“一主多从”的SPI网络架设，在进行“一主一从”的SPI通信时，SPI并不是必须的。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SPI总线传输数据时，由主机的SCLK线提供时钟脉冲，从机被动的接收时钟脉冲。主机在数据发送前，将数据写入数据寄存器，等待时钟脉冲移位输出，每个脉冲周期传输1位数据。 从机在主机的数据发送中，依靠主机的时钟，将从机的数据寄存器内容移位发送。所以&lt;strong&gt;要实现主从数据交换，在时钟信号前，主机 从机都必须先将数据写入数据寄存器，并且从机必须在主机前写入，然后由主机的SCLK时钟驱动发送&lt;/strong&gt;。 不注意这个问题很容易造成SPI接收的数据错位。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 这样的全双工、同步传输完全依赖于 主机控制的时钟线SCLK，而且SCLK上只有数据传输的时候才有时钟信号。主机向从机发送数据不会有问题，但是如果从机主动向主机发送数据呢？&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 从机要发送数据，必须要有SCLK的时钟，所以只能主机发送一个DUMMY（哑巴）字节，产生时钟，来实现和从机的数据交换。 从设备只能被动发送数据，无法主动发送数据。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; 本例实现 通过将STM32上的2个SPI接口对接，进行一个简单的数据交换。使用SPI1作为主设备，SPI2作为从设备，通过串口查看数据通信的情况。&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;实现结果如下：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/4257083322.png&quot; alt=&quot;spi.png&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 can总线通信[库函数]</title>
    <link href="http://neil-pan.com/2012/07/12/stm32-can%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/12/stm32-can总线通信-库函数/</id>
    <published>2012-07-12T14:04:25.000Z</published>
    <updated>2024-07-11T12:49:21.229Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAN是控制器局域网络(Controller Area Network, CAN)的简称，是由研发和生产汽车电子产品著称的德国BOSCH公司开发了的，并最终成为国际标准（ISO118?8）。近年来，其所具有的高可靠性和良好的错误检测能力受到重视，被广泛应用于汽车计算机控制系统和环境温度恶劣、电磁辐射强和振动大的工业环境。相比于I2C和SPI总线结构，can总线定义了更为优秀的物理层、数据链路层，并拥有种类丰富、繁简不一的上层协议。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; CAN总线的物理连接只需要两根线，通常称为CAN_H和CAN_L,通常查分信号进行数据的传输。&nbsp;CAN总线有两种电平，分为隐性电平和显性电平，这两种电平表现为“与”的关系。</div><ul><li>若隐性电平相遇，则总线表现为隐性电平。</li><li>若显性电平相遇，则总线表现为显性电平。</li><li>若隐性电平和显性电平相遇，则总线表现为显性电平。<div>CAN总线的典型拓扑结构如下：</div><div><img src="/uploads/2012/07/3744164432.gif" alt="12KS3133950-12D9.gif"></div><div>&nbsp;&nbsp;&nbsp;&nbsp;CAN总线网络是一种多主机网络，在总线处于空闲时，任何一个节点都可以申请成为主机，向总线发送消息，最先访问总线的节点单元可以获得总线的控制权。</div><div> </div><div>&nbsp; &nbsp; CAN总线的所有消息都是以固定的形式打包发送的。两个以上的节点单元同时发送数据时，根据节点标志符决定各自优先关系。CAN总线并没有类似其他的总线上的地址的概念，在总线上增加节点时，连接节点的其他单元软硬件什么都不需要改变。</div><div> </div><div>&nbsp; &nbsp; CAN总线的通信速率和总线长度有关，在总线长度小于40m的场合中，数据传输速率可以达到1Mbps，即便长度达到1000m,数据传输数率也可以达到50Kbps，无论在数率和传输距离上都由于常见的RS232、RS485和I2C总线。</div><div>&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; CAN总线在理论上节点数没有上限，但是实际中受到总线上的时间延时和电气负载的限制。降低节点数可以增大通信速率。</div><div> </div><div>&nbsp; &nbsp; Stm32 至少配备一个CAN总线控制器，最高速率可以达到1Mbps，支持11位的标准帧格式和29为的拓展帧格式的接收和发送，具备三个邮箱和2个接收FIFO,此外还有3级可编程滤波器。</div><div> </div><div><strong>本例主要实现使用stm32的CAN总线实现数据的发送和接收，使用串口观察数据。</strong></div><div> </div></li></ul><a id="more"></a><div><strong>库函数操作</strong></div><div> </div><div><div>CAN 通信 过滤器 和 屏蔽器 ：</div><div> </div><div>例如设置某接收滤波寄存器00000000001(11位),接收屏蔽寄存器11111111101(11位),则该对组合会拒绝接收00000000011和00000000001之外所有的标识符对应的CAN帧,因为屏蔽器规定第二位(为0)以外的所有标识符位要严格匹配(与滤波器值一致),第二位的滤波器值和收到的CAN标识符第二位值是否一致都可以.</div><div> </div><div>main.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br><br>#define     PRINTF_ON  1<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void USART_Configuration(void);<br>void CAN_Configuration(void);<br>void NVIC_Configuration(void);<br><br>u8 TransmitMailbox = 0;<br>CanTxMsg TxMessage;<br>CanRxMsg RxMessage;<br><br>int main(void)<br>{<br>      RCC_Configuration();<br>    GPIO_Configuration();<br>    USART_Configuration();<br>    CAN_Configuration();<br><br>    TxMessage.ExtId = 0x00AA0000;<br>    TxMessage.RTR = CAN_RTR_DATA;<br>    TxMessage.IDE = CAN_ID_EXT;<br>    TxMessage.DLC = 8;<br>    TxMessage.Data[0] = 0x00;<br>    TxMessage.Data[1] = 0x12;<br>    TxMessage.Data[2] = 0x34;<br>    TxMessage.Data[3] = 0x56;<br>    TxMessage.Data[4] = 0x78;<br>    TxMessage.Data[5] = 0xAB;<br>    TxMessage.Data[6] = 0xCD;<br>    TxMessage.Data[7] = 0xEF;<br><br>    TransmitMailbox = CAN_Transmit(CAN1,&amp;TxMessage);<br>    while(CAN_TransmitStatus(CAN1,TransmitMailbox) != CANTXOK);<br>    printf(“\r\n The CAN has send data: %d ,%d,%d ,%d,%d ,%d,%d ,%d \r\n”,<br>        TxMessage.Data[0],<br>        TxMessage.Data[1],<br>        TxMessage.Data[2],<br>        TxMessage.Data[3],<br>        TxMessage.Data[4],<br>        TxMessage.Data[5],<br>        TxMessage.Data[6],<br>        TxMessage.Data[7]<br>    );<br><br>    while(CAN_MessagePending(CAN1,CAN_FIFO0) == 0);<br><br>    //RxMessage.StdId = 0x00;<br>    RxMessage.IDE = CAN_ID_EXT;<br>    RxMessage.DLC = 0;<br>    RxMessage.Data[0] = 0x00;<br>    RxMessage.Data[1] = 0x00;<br>    RxMessage.Data[2] = 0x00;<br>    RxMessage.Data[3] = 0x00;<br>    RxMessage.Data[4] = 0x00;<br>    RxMessage.Data[5] = 0x00;<br>    RxMessage.Data[6] = 0x00;<br>    RxMessage.Data[7] = 0x00;<br><br>    CAN_Receive(CAN1,CAN_FIFO0,&amp;RxMessage);<br>    printf(“\r\n The CAN　has receive data : %d,%d,%d,%d,%d,%d,%d,%d \r\n”,<br>        RxMessage.Data[0],<br>        RxMessage.Data[1],<br>        RxMessage.Data[2],<br>        RxMessage.Data[3],<br>        RxMessage.Data[4],<br>        RxMessage.Data[5],<br>        RxMessage.Data[6],<br>        RxMessage.Data[7]<br>    );<br><br>    while(1);<br>}<br><br>void CAN_Configuration(void)<br>{<br>    CAN_InitTypeDef CAN_InitStructure;<br>    CAN_FilterInitTypeDef CAN_FilterInitStructure;<br><br>    CAN_DeInit(CAN1);<br>    CAN_StructInit(&amp;CAN_InitStructure);<br><br>    CAN_InitStructure.CAN_TTCM = DISABLE;<br>    CAN_InitStructure.CAN_ABOM = DISABLE;<br>    CAN_InitStructure.CAN_AWUM = DISABLE;<br>    CAN_InitStructure.CAN_NART = DISABLE;<br>    CAN_InitStructure.CAN_RFLM = DISABLE;<br>    CAN_InitStructure.CAN_TXFP = DISABLE;<br>    CAN_InitStructure.CAN_Mode = CAN_Mode_LoopBack;<br>    CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;<br>    CAN_InitStructure.CAN_BS1 = CAN_BS1_8tq;<br>    CAN_InitStructure.CAN_BS2 = CAN_BS2_7tq;<br>    CAN_Init(CAN1,&amp;CAN_InitStructure);<br><br>    CAN_FilterInitStructure.CAN_FilterNumber = 0;<br>    CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;<br>    CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;<br>    CAN_FilterInitStructure.CAN_FilterIdHigh = 0x00AA &lt;&lt; 3;            //匹配过滤寄存器,因为数据标志符段 还有 IDE ,RTR 和一个补零位  所以左移三位<br>    CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;<br>    CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0x00FF &lt;&lt; 3 ;        //匹配屏蔽寄存器<br>    CAN_FilterInitStructure.CAN_FilterFIFOAssignment = 0;<br>    CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;<br><br>    CAN_FilterInit(&amp;CAN_FilterInitStructure);<br><br>}<br><br>void GPIO_Configuration(void)<br>{<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br><br>     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>      GPIO_Init(GPIOB , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOB , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br>}<br><br>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /<em> 复位系统时钟设置</em>/<br>      RCC_DeInit();<br>      /<em> 开启HSE</em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /<em> 等待HSE起振并稳定</em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /<em> 判断HSE起是否振成功，是则进入if()内部 </em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /<em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 </em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /<em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 </em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /<em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 </em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /<em> 设置FLASH延时周期数为2 </em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /<em> 使能FLASH预取缓存 </em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /<em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz </em> 9 = 72MHz <em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /</em> 使能PLL <em>/<br>        RCC_PLLCmd(ENABLE);<br>        /</em> 等待PLL输出稳定 <em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /</em> 选择SYSCLK时钟源为PLL <em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /</em> 等待PLL成为SYSCLK时钟源 <em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /</em> 打开APB2总线上的GPIOA时钟<em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE);<br><br>    //RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<br><br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,ENABLE);<br>    //RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP|RCC_APB1Periph_WWDG|RCC_APB1Periph_SPI2|RCC_APB1Periph_I2C1|RCC_APB1Periph_I2C2, ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>#if     PRINTF_ON<br><br>int fputc(int ch,FILE </em>f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br><br>#endif<br></pre></div><div> </div></div><div> </div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CAN是控制器局域网络(Controller Area Network, CAN)的简称，是由研发和生产汽车电子产品著称的德国BOSCH公司开发了的，并最终成为国际标准（ISO118?8）。近年来，其所具有的高可靠性和良好的错误检测能力受到重视，被广泛应用于汽车计算机控制系统和环境温度恶劣、电磁辐射强和振动大的工业环境。相比于I2C和SPI总线结构，can总线定义了更为优秀的物理层、数据链路层，并拥有种类丰富、繁简不一的上层协议。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; CAN总线的物理连接只需要两根线，通常称为CAN_H和CAN_L,通常查分信号进行数据的传输。&amp;nbsp;CAN总线有两种电平，分为隐性电平和显性电平，这两种电平表现为“与”的关系。&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;若隐性电平相遇，则总线表现为隐性电平。&lt;/li&gt;
&lt;li&gt;若显性电平相遇，则总线表现为显性电平。&lt;/li&gt;
&lt;li&gt;若隐性电平和显性电平相遇，则总线表现为显性电平。&lt;div&gt;CAN总线的典型拓扑结构如下：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/3744164432.gif&quot; alt=&quot;12KS3133950-12D9.gif&quot;&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;CAN总线网络是一种多主机网络，在总线处于空闲时，任何一个节点都可以申请成为主机，向总线发送消息，最先访问总线的节点单元可以获得总线的控制权。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; CAN总线的所有消息都是以固定的形式打包发送的。两个以上的节点单元同时发送数据时，根据节点标志符决定各自优先关系。CAN总线并没有类似其他的总线上的地址的概念，在总线上增加节点时，连接节点的其他单元软硬件什么都不需要改变。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; CAN总线的通信速率和总线长度有关，在总线长度小于40m的场合中，数据传输速率可以达到1Mbps，即便长度达到1000m,数据传输数率也可以达到50Kbps，无论在数率和传输距离上都由于常见的RS232、RS485和I2C总线。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; CAN总线在理论上节点数没有上限，但是实际中受到总线上的时间延时和电气负载的限制。降低节点数可以增大通信速率。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; Stm32 至少配备一个CAN总线控制器，最高速率可以达到1Mbps，支持11位的标准帧格式和29为的拓展帧格式的接收和发送，具备三个邮箱和2个接收FIFO,此外还有3级可编程滤波器。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;本例主要实现使用stm32的CAN总线实现数据的发送和接收，使用串口观察数据。&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 i2c通信 [操作寄存器+库函数]</title>
    <link href="http://neil-pan.com/2012/07/12/stm32-i2c%E9%80%9A%E4%BF%A1-%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/12/stm32-i2c通信-操作寄存器-库函数/</id>
    <published>2012-07-12T14:01:38.000Z</published>
    <updated>2024-07-11T12:49:21.230Z</updated>
    
    <content type="html"><![CDATA[<div>I2C总线是由NXP（原PHILIPS）公司设计，有十分简洁的物理层定义,其特性如下：</div><div><br><br><em>   只要求两条总线线路：一条串行数据线SDA，一条串行时钟线SCL；</em>   每个连接到总线的器件都可以通过唯一的地址和一直存在的简单的主机/从机关系软件设定地址，主机可以作为主机发送器或主机接收器；<br><em>   它是一个真正的多主机总线，如果两个或更多主机同时初始化，数据传输可以通过冲突检测和仲裁防止数据被破坏；</em>   串行的8 位双向数据传输位速率在标准模式下可达100kbit/s，快速模式下可达400kbit/s，高速模式下可达3.4Mbit/s；<br>*   连接到相同总线的IC 数量只受到总线的最大电容400pF 限制。<div>其典型的接口连线如下：</div><div><img src="/uploads/2012/07/3084720656.jpg" alt="I2C Devices.jpg"></div></div><div> </div><div>I2C的协议很简单：</div><div> </div><div><div><strong>数据的有效性</strong></div><div>　　在传输数据的时候，SDA线必须在时钟的高电平周期保持稳定，SDA的高或低电平状态只有在SCL 线的时钟信号是低电平时才能改变 。</div><div> </div><div><div><strong>起始和停止条件</strong></div><div>　　SCL 线是高电平时，SDA 线从高电平向低电平切换，这个情况表示起始条件；</div><div>　　SCL 线是高电平时，SDA 线由低电平向高电平切换，这个情况表示停止条件。</div><div> </div><div><div><strong>字节格式</strong></div><div>　　发送到SDA 线上的每个字节必须为8 位，每次传输可以发送的字节数量不受限制。每个字节后必须处理一个响应位。</div><div> </div><div><strong>应答响应 　　</strong></div><div>&nbsp; &nbsp; &nbsp; &nbsp;数据传输必须带响应，相关的响应时钟脉冲由主机产生。在响应的时钟脉冲期间发送器释放SDA 线（高）。 　　</div><div>&nbsp; &nbsp; &nbsp; &nbsp;在响应的时钟脉冲期间，接收器必须将SDA 线拉低，使它在这个时钟脉冲的高电平期间保持稳定的低电平。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;也就是说主器件发送完一字节数据后要接收一个应答位（低电平），从器件接收完一个字节后要发送一个低电平。</div><div> </div><div><div><strong>寻址方式(7位地址方式)</strong></div><div> </div><div>　　第一个字节的头7 位组成了从机地址，最低位（LSB）是第8 位，它决定了传输的 &nbsp;普通的和带重复开始条件的7位地址格式方向。第一个字节的最低位是</div><div>&nbsp;&nbsp;&nbsp;&nbsp;“0”，表示主机会写信息到被选中的从机；</div><div>&nbsp; &nbsp; “1”表示主机会向从机读信息。</div><div>当发送了一个地址后，系统中的每个器件都在起始条件后将头7 位与它自己的地址比较，如果一样，器件会判定它被主机寻址，至于是从机接收器还是从机发送器，都由R/W 位决定。</div><div> </div><div><strong>仲裁</strong></div><div> </div><div>&nbsp; &nbsp; I2C是所主机总线，每个设备都可以成为主机，但任一时刻只能有一个主机。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;stm32至少有一个I2C接口，提供多主机功能，可以实现所有I2C总线的时序、协议、仲裁和定时功能，支持标准和快速传输两种模式，同时与SMBus 2.0兼容。</div><a id="more"></a><div> </div><div><strong>&nbsp; &nbsp; 本实验直接操作寄存器实现对I2C总线结构的EEPROM AT24c02的写入和读取。AT24c02相关操作详见&nbsp;</strong><a href="http://www.ichanging.org/at24c02.html" target="_blank" rel="noopener">单片机读取EEPROM(AT24C02)</a>。</div><div> </div><div>&nbsp; &nbsp;&nbsp;<strong>库函数实现使用stm32的两个I2C模拟I2C**</strong>设备<strong>**间的数据收发，并通过串口查看数据交换情况。</strong></div><div> </div><div><strong>直接操作寄存器</strong></div><div> </div><div>首先需要配置I2C接口的时钟,相关寄存器如下：</div><div> </div><div>I2C_CR2寄存器低五位：&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;FREQ[5:0]：I2C模块时钟频率 ，必须设置正确的输入时钟频率以产生正确的时序，允许的范围在2～36MHz之间：</div><div>&nbsp;&nbsp;&nbsp;&nbsp;000000：禁用 &nbsp;&nbsp;&nbsp; &nbsp; 000001：禁用 &nbsp; &nbsp; &nbsp; 000010：2MHz &nbsp;&nbsp;&nbsp; &nbsp; … &nbsp;&nbsp;&nbsp; &nbsp; 100100：36MHz &nbsp;&nbsp;&nbsp; &nbsp; 大于100100：禁用。</div><div> </div><div>&nbsp;用于设置I2C设备的输入时钟，本例使用的是PLCK1总线上的时钟所以为36Mhz;</div><div> </div><div>时钟控制寄存器(I2C_CCR)低12位：</div><div><div>CCR[11:0]：快速/标准模式下的时钟控制分频系数(主模式)，该分频系数用于设置主模式下的SCL时钟。</div><div>在I2C标准模式或SMBus模式下：</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thigh = CCR ×TPCLK1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tlow = CCR ×TPCLK1</div><div> </div><div>&nbsp; &nbsp; &nbsp; &nbsp; 时钟周期为 T = Thigh + Tlow;</div><div> </div><div>例如：在标准模式下，FREQR = 36 即36Mhz,产生200kHz的SCL的频率</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时钟控制分频系数 &nbsp;= Freqr /2/f &nbsp; &nbsp;f 为想得到的频率&nbsp;</div><div> </div><div>配置好时钟，还需要配置本机地址，I2C支持7位地址和10位地址，这里用的是7位地址：</div><div>自身地址寄存器1(I2C_OAR1)[7:1]：接口地址，地址的7~1位。</div><div> </div><div>其他相关操作参见代码，有详细注释：<span style="text-align: left; ">（system.h 和&nbsp;</span><span style="text-align: left; ">stm32f10x_it.h</span><span style="text-align: left; ">&nbsp;等相关代码参照&nbsp;</span><a href="http://www.ichanging.org/mdk-stm32Register-set.html" target="_blank" rel="noopener">stm32 直接操作寄存器开发环境配置</a><span style="text-align: left; ">）</span></div><div> </div><div>User/main.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br>#include “system.h”<br>#include “usart.h”<br>#include “i2c.h”<br><br>#define LED1 PAout(4)<br>#define LED2 PAout(5)<br>#define LED3 PAout(6)<br>#define LED4 PAout(7)<br><br>void Gpio_Init(void);<br><br>int main(void)<br>{<br><br>    Rcc_Init(9);                            //系统时钟设置<br><br>    Usart1_Init(72,9600);<br><br>    Nvic_Init(1,0,I2C1_EV_IRQChannel,4);      //设置抢占优先级为1，响应优先级为0，中断分组为4<br><br>    Nvic_Init(0,0,I2C1_ER_IRQChannel,4);      //设置I2C错误中断抢占优先级为0<br><br>    Gpio_Init();<br><br>    I2c_Init(0x30);                              //设置I2C1地址为0x30<br><br>    I2c_Start();<br><br>    while(1);<br>}<br><br>void Gpio_Init(void)<br>{<br>    RCC-&gt;APB2ENR |= 1&lt;&lt;2;            //使能PORTA时钟<br>    RCC-&gt;APB2ENR |= 1&lt;&lt;3;            //使能PORTB时钟;<br><br>    GPIOA-&gt;CRL &amp;= 0x0000FFFF;         // PA0~3设置为浮空输入，PA4~7设置为推挽输出<br>    GPIOA-&gt;CRL |= 0x33334444;<br><br>    GPIOB-&gt;CRL &amp;= 0x00FFFFFF;        //PB6 I2C1_SCL ,PB7  I2C1_SDL<br>    GPIOB-&gt;CRL |= 0xFF000000;        //复用开漏输出<br><br>    //USART1 串口I/O设置<br><br>    GPIOA -&gt; CRH &amp;= 0xFFFFF00F;       //设置USART1 的Tx(PA.9)为第二功能推挽，50MHz；Rx(PA.10)为浮空输入<br>    GPIOA -&gt; CRH |= 0x000008B0;<br><br>}<br></pre><div>User/stm32f10x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<br>#include “system.h”<br>#include “stdio.h”<br>#include “i2c.h”<br><br>#define LED1 PAout(4)<br>#define LED2 PAout(5)<br>#define LED3 PAout(6)<br>#define LED4 PAout(7)<br><br>#define  ADDRS_R  0xA1    //读操作地址<br>#define  ADDRS_W  0xA0    //写操作地址<br><br>u8  go = 0;                  //操作步骤标记<br><br>void I2C1_EV_IRQHandler(void)     //I2C1 Event Interrupt<br>{<br>       u16 clear = 0;<br><br>    if(I2C1 -&gt; SR1 &amp; 1&lt;&lt;0 )          //已发送起始条件,写数据寄存器的操作将清除该位<br>    {<br>        printf(“\r\n I2C1 Start .. \r\n”);<br><br>        switch(go)<br>        {<br>            case 0:{<br>                 I2c_Write(ADDRS_W);           //写入从机地址,写指令操作地址<br>                break;<br>            }<br>            case 1:{<br>                I2c_Write(ADDRS_W);           //写入从机地址,写指令操作地址<br>                break;<br>            }<br>            case 2:{<br>                I2c_Write(ADDRS_R);           //写入从机地址,读数据操作地址<br>                break;<br>           }<br>        }<br><br>    }<br><br>    if(I2C1 -&gt; SR1 &amp; 1&lt;&lt;1 )        //从机地址已发送<br>    {<br>        printf(“\r\n I2C1 has send address .. \r\n”);<br>        clear = I2C1 -&gt; SR2;    //读取SR2可以清除该位中断<br><br>        switch(go)<br>        {<br>            case 0:{<br>                 I2c_Write(0x01);    //写入待写入的EEPROM单元地址<br>                break;<br>            }<br><br>            case 1:{<br>                I2c_Write(0x01);    //写入待写入的EEPROM单元地址<br>                break;<br>            }<br>            case 2:{<br>                delay(100000);<br>                 printf(“\r\n Read 0x%X from At24c02 ,Address 0x01 ..  \r\n”,I2c_Read());<br>                 I2c_Stop();<br>                break;<br>           }<br>        }<br><br>    }<br><br>    if(I2C1 -&gt; SR1 &amp; 1&lt;&lt;2 )        //字节发送结束  发送地址字节时，不触发此中断<br>    {<br><br>        //printf(“\r\n I2C1 send byte success .. \r\n”);<br>        switch(go)<br>        {<br>            case 0:{<br>                 I2c_Write(0x86);            //写入数据<br>                printf(“\r\n Write 0x%X to At24c02 ,Address 0x01 ..  \r\n”,0x86);<br>                //I2c_Stop();<br><br>                delay(10000);<br>                go = 1;<br>                I2c_Start();<br>                break;<br>            }<br><br>            case 1:{<br><br>                delay(10000);<br>                go = 2;<br>                I2c_Start();<br>                break;<br>            }<br>            case 2:{<br><br>                break;<br>           }<br>        }<br><br>    }<br><br>    delay(100000);<br>    LED3 = 1;<br><br>       //I2C1 -&gt; CR2 &amp;= ~(1&lt;&lt;9);            //事件中断关闭<br>}<br><br>void I2C1_ER_IRQHandler(void)        //I2C1 Error Interrupt<br>{<br>    delay(100000);<br>    LED4 = 1;<br><br>    if(I2C1-&gt;SR1 &amp; 1&lt;&lt;10)             //应答失败<br>    {<br>        printf(“\r\n ACK ERROR .. \r\n”);<br><br>        I2C1-&gt;SR1 &amp;=~(1&lt;&lt;10);        //清除中断<br>    }<br><br>    if(I2C1-&gt;SR1 &amp; 1&lt;&lt;14)            //超时<br>    {<br>        printf(“\r\n Timeout .. \r\n”);<br><br>        I2C1-&gt;SR1 &amp;=~(1&lt;&lt;14);        //清除中断<br>    }<br><br>    if(I2C1-&gt;SR1 &amp; 1&lt;&lt;11)            //过载/欠载<br>    {<br>        printf(“\r\n Overrun/Underrun .. \r\n”);<br>        I2C1-&gt;SR1 &amp;=~(1&lt;&lt;11);        //清除中断<br>    }<br><br>    if(I2C1-&gt;SR1 &amp; 1&lt;&lt;9)            //仲裁丢失<br>    {<br>        printf(“\r\n Arbitration lost .. \r\n”);<br>        I2C1-&gt;SR1 &amp;=~(1&lt;&lt;9);        //清除中断<br>    }<br><br>    if(I2C1-&gt;SR1 &amp; 1&lt;&lt;8)            //总线出错<br>    {<br>        printf(“\r\n Bus error .. \r\n”);<br>        I2C1-&gt;SR1 &amp;=~(1&lt;&lt;8);        //清除中断<br>    }<br><br>}<br></pre></div></div><div>Library/src/i2c.c</div><div><pre class="brush:cpp;">#include “i2c.h”<br><br>void I2c_Init(u16 Addr )<br>{<br><br>    RCC -&gt; APB1ENR |= 1&lt;&lt;21;            //打开I2C1时钟<br>    //RCC -&gt; APB1ENR |= 1&lt;&lt;22;            //打开I2C2时钟<br><br>    RCC-&gt;APB1RSTR  |= 1&lt;&lt;21;            //复位I2C1<br>    RCC-&gt;APB1RSTR  &amp;= ~(1&lt;&lt;21);            //复位结束I2C1<br>    //RCC-&gt;APB1RSTR  |= 1&lt;&lt;22;            //复位I2C2<br><br>    //I2C1 -&gt; CR1 |=  1&lt;&lt;15;                //复位寄存器<br><br>    //I2C模块时钟频率,2～36MHz之间<br>    I2C1 -&gt; CR2 |=    36 ;                //000000：禁用 000001：禁用 000010：2MHz … 100100：36MHz<br><br>    I2C1 -&gt; CCR |= 0&lt;&lt;15;                //I2C主模式  0：标准模式的I2C     1：快速模式的I2C<br>    //I2C1 -&gt; CCR |= 1&lt;&lt;14;                //快速模式时的占空比 0 Tlow/Thigh = 2     1    Tlow/Thigh = 16/9<br><br>    //得到200kHz频率<br>    I2C1 -&gt; CCR |= 90&lt;&lt;0;                //时钟控制分频系数  = PCLK1 /2/f    f 为想得到的频率<br><br>    //主模式最大上升时间<br>    I2C1 -&gt; TRISE |= 37;                //最大允许SCL上升时间为1000ns，故TRISE[5:0]中必须写入(1us/(1/36)us = 36+1)。<br><br>    I2C1 -&gt; CR1 |=  1&lt;&lt;10;                //打开ACK应答,在接收到一个字节后返回一个应答<br>    I2C1 -&gt; CR1 |= 1&lt;&lt;6;                //广播呼叫使能<br><br>    I2C1 -&gt; OAR1 |= 0&lt;&lt;15;                //寻址模式     1 响应10位地址  0  响应7位地址<br><br>    I2C1 -&gt; OAR1 |= 1&lt;&lt;14;                //必须始终由软件保持为 1<br><br>    I2C1 -&gt; OAR1 |=  Addr &lt;&lt;1 ;            //设置接口地址的 7~1位<br><br>    //I2C1 -&gt; OAR1 |=  0 ;              //设置10位地址模式时地址第0位<br>    //I2C1 -&gt; OAR1 |= 0&lt;&lt;8;                //设置10位地址模式时地址第9~8位<br><br>    //I2C1 -&gt; CR2 |=  1&lt;&lt;10;                //缓冲器中断使能<br>    I2C1 -&gt; CR2 |=  1&lt;&lt;9;                //事件中断使能<br>    I2C1 -&gt; CR2 |=  1&lt;&lt;8;                //出错中断使能<br><br>    I2C1 -&gt; CR1 |=    1&lt;&lt;0;                //开启I2C1<br>}<br><br>void  I2c_Start()<br>{<br><br>    I2C1 -&gt; CR1 |=    1&lt;&lt;8;                //I2C1产生起始条件<br>}<br><br>void  I2c_Stop()<br>{<br>    I2C1 -&gt; CR1 |=    1&lt;&lt;9;                //I2C1产生停止条件<br>}<br><br>void  I2c_Write(u8 data)<br>{<br>    I2C1 -&gt; DR = data;<br>}<br><br>u8  I2c_Read()<br>{<br>    while(!(I2C1 -&gt; SR1 &amp; 1&lt;&lt;6));        //接收到数据标志位<br><br>      return I2C1 -&gt; DR;<br>}<br><br>void  I2c_End()                            //关闭I2C<br>{<br>    I2C1 -&gt; CR1 &amp;=    ~(1&lt;&lt;0);<br>}<br></pre><div>Library/inc/i2c.h</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br><br>void I2c_Init(u16 Addr );<br><br>void  I2c_Start(void);<br>void  I2c_Stop(void);<br>void  I2c_Write(u8 data);<br>u8    I2c_Read(void);<br>void  I2c_End(void);<br></pre></div></div></div></div></div></div></div><div style="text-align: left;">串口接收数据如下：</div><div style="text-align: left;"> </div><div style="text-align: left;"><div>&nbsp;I2C1 Start ..&nbsp;</div><div>&nbsp;I2C1 has send address ..&nbsp;</div><div>&nbsp;Write 0x86 to At24c02 ,Address 0x01 .. &nbsp;</div><div>&nbsp;I2C1 Start ..&nbsp;</div><div>&nbsp;I2C1 has send address ..&nbsp;</div><div>&nbsp;I2C1 Start ..&nbsp;</div><div>&nbsp;I2C1 has send address ..&nbsp;</div><div>&nbsp;Read 0x86 from At24c02 ,Address 0x01 .. &nbsp;</div></div><div style="text-align: left;"> </div><div style="text-align: left;"> </div><div style="text-align: left;"><strong>库函数操作</strong></div><div style="text-align: left;"> </div><div>main.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br><br>#define     PRINTF_ON  1<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void USART_Configuration(void);<br>void I2C_Configuration(void);<br>void NVIC_Configuration(void);<br><br>u8 I2C1_ADDRESS = 0x30;   //7位 I2C 地址<br>u8 I2C2_ADDRESS = 0x31;<br><br>#define Size 4<br><br>vu8 I2C1_Buffer_Tx[Size] = {1,2,3,4};<br>vu8 I2C2_Buffer_Rx[Size] = {0};<br><br>u32 BufferSize = Size ;<br><br>int main(void)<br>{<br>      RCC_Configuration();<br>    GPIO_Configuration();<br>    USART_Configuration();<br>    I2C_Configuration();<br>    NVIC_Configuration();<br><br>    I2C_GenerateSTART(I2C1,ENABLE);<br><br>    while(1);<br>}<br><br>void I2C_Configuration(void)<br>{<br>    I2C_InitTypeDef I2C_InitStructure;<br><br>    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;<br>    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;<br>    I2C_InitStructure.I2C_OwnAddress1 = I2C1_ADDRESS;<br>    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;<br>    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<br>    I2C_InitStructure.I2C_ClockSpeed = 200000;<br>    I2C_Init(I2C1,&amp;I2C_InitStructure);<br><br>    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;<br>    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;<br>    I2C_InitStructure.I2C_OwnAddress1 = I2C2_ADDRESS;<br>    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;<br>    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<br>    I2C_InitStructure.I2C_ClockSpeed = 200000;<br>    I2C_Init(I2C2,&amp;I2C_InitStructure);<br><br>    I2C_ITConfig(I2C1,I2C_IT_EVT|I2C_IT_BUF,ENABLE);<br>    I2C_ITConfig(I2C2,I2C_IT_EVT|I2C_IT_BUF,ENABLE);<br><br>    I2C_Cmd(I2C1,ENABLE);<br>    I2C_Cmd(I2C2,ENABLE);<br>}<br><br>void NVIC_Configuration(void)<br>{<br>    NVIC_InitTypeDef NVIC_InitStructure;<br><br>    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);<br><br>    NVIC_InitStructure.NVIC_IRQChannel = I2C1_EV_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>    NVIC_Init(&amp;NVIC_InitStructure);<br><br>    NVIC_InitStructure.NVIC_IRQChannel = I2C2_EV_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>    NVIC_Init(&amp;NVIC_InitStructure);<br>}<br><br>void GPIO_Configuration(void)<br>{<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br><br>     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;<br>      GPIO_Init(GPIOB , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_11;<br>     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;<br>      GPIO_Init(GPIOB , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br>}<br><br>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /<em> 复位系统时钟设置</em>/<br>      RCC_DeInit();<br>      /<em> 开启HSE</em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /<em> 等待HSE起振并稳定</em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /<em> 判断HSE起是否振成功，是则进入if()内部 </em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /<em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 </em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /<em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 </em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /<em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 </em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /<em> 设置FLASH延时周期数为2 </em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /<em> 使能FLASH预取缓存 </em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /<em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz </em> 9 = 72MHz <em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /</em> 使能PLL <em>/<br>        RCC_PLLCmd(ENABLE);<br>        /</em> 等待PLL输出稳定 <em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /</em> 选择SYSCLK时钟源为PLL <em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /</em> 等待PLL成为SYSCLK时钟源 <em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /</em> 打开APB2总线上的GPIOA时钟<em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_USART1, ENABLE);<br><br>    //RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<br><br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1|RCC_APB1Periph_I2C2,ENABLE);<br>    //RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP|RCC_APB1Periph_WWDG|RCC_APB1Periph_SPI2, ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>#if     PRINTF_ON<br><br>int fputc(int ch,FILE </em>f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br><br>#endif<br></pre><div>stm32f10x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<br>#include “stdio.h”<br><br>extern u32 BufferSize ;<br>extern u8 I2C1_ADDRESS ;<br>extern u8 I2C2_ADDRESS ;<br><br>extern vu8 I2C1_Buffer_Tx[];<br>extern vu8 I2C2_Buffer_Rx[];<br>vu32 Tx_Counter = 0;<br>vu32 Rx_Counter = 0;<br><br>void I2C1_EV_IRQHandler(void)<br>{<br>    switch(I2C_GetLastEvent(I2C1))<br>    {<br>        case I2C_EVENT_MASTER_MODE_SELECT: //已发送启始条件<br>        {<br>            I2C_Send7bitAddress(I2C1,I2C2_ADDRESS,I2C_Direction_Transmitter);<br>            break;<br>        }<br>        case I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: //已发送从机地址<br>        {<br>            printf(“\r\n The I2C1 has send data %d \r\n”,I2C1_Buffer_Tx[Rx_Counter]);<br>            I2C_SendData(I2C1,I2C1_Buffer_Tx[Tx_Counter++]);<br>            break;<br>        }<br>        case I2C_EVENT_MASTER_BYTE_TRANSMITTED: //第一个数据已发送<br>        {<br>            if(Tx_Counter&lt;BufferSize)<br>            {<br>                printf(“\r\n The I2C1 has send data %d \r\n”,I2C1_Buffer_Tx[Rx_Counter]);<br>                I2C_SendData(I2C1,I2C1_Buffer_Tx[Tx_Counter++]);<br><br>            }else{<br>                I2C_GenerateSTOP(I2C1,ENABLE);<br>                I2C_ITConfig(I2C1,I2C_IT_EVT|I2C_IT_BUF,DISABLE);  //计数发送的个数<br>            }<br><br>            break;<br>        }<br>        default: {break;}<br>    }<br>}<br><br>void I2C2_EV_IRQHandler(void)<br>{<br>    switch(I2C_GetLastEvent(I2C2))<br>    {<br>        case I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: //收到匹配的地址数据<br>        {<br>            break;<br>        }<br>        case I2C_EVENT_SLAVE_BYTE_RECEIVED: //收到数据<br>        {<br>            if(Rx_Counter &lt; BufferSize )<br>            {<br>                I2C2_Buffer_Rx[Rx_Counter] = I2C_ReceiveData(I2C2);<br>                printf(“\r\n The I2C2 has received data %d \r\n”,I2C2_Buffer_Rx[Rx_Counter++]); //计数收到的个数<br>            }<br>            break;<br>        }<br>        case I2C_EVENT_SLAVE_STOP_DETECTED: //收到结束条件<br>        {<br>            I2C_ClearFlag(I2C2,I2C_FLAG_STOPF);<br>            I2C_ITConfig(I2C1,I2C_IT_EVT|I2C_IT_BUF,DISABLE);<br><br>            break;<br>        }<br>        default: {break;}<br>    }<br>}<br><br></pre></div></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;I2C总线是由NXP（原PHILIPS）公司设计，有十分简洁的物理层定义,其特性如下：&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;em&gt;   只要求两条总线线路：一条串行数据线SDA，一条串行时钟线SCL；
&lt;/em&gt;   每个连接到总线的器件都可以通过唯一的地址和一直存在的简单的主机/从机关系软件设定地址，主机可以作为主机发送器或主机接收器；&lt;br&gt;&lt;em&gt;   它是一个真正的多主机总线，如果两个或更多主机同时初始化，数据传输可以通过冲突检测和仲裁防止数据被破坏；
&lt;/em&gt;   串行的8 位双向数据传输位速率在标准模式下可达100kbit/s，快速模式下可达400kbit/s，高速模式下可达3.4Mbit/s；&lt;br&gt;*   连接到相同总线的IC 数量只受到总线的最大电容400pF 限制。&lt;div&gt;其典型的接口连线如下：&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/3084720656.jpg&quot; alt=&quot;I2C Devices.jpg&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;I2C的协议很简单：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;数据的有效性&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;　　在传输数据的时候，SDA线必须在时钟的高电平周期保持稳定，SDA的高或低电平状态只有在SCL 线的时钟信号是低电平时才能改变 。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;起始和停止条件&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;　　SCL 线是高电平时，SDA 线从高电平向低电平切换，这个情况表示起始条件；&lt;/div&gt;&lt;div&gt;　　SCL 线是高电平时，SDA 线由低电平向高电平切换，这个情况表示停止条件。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;字节格式&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;　　发送到SDA 线上的每个字节必须为8 位，每次传输可以发送的字节数量不受限制。每个字节后必须处理一个响应位。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;应答响应 　　&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;数据传输必须带响应，相关的响应时钟脉冲由主机产生。在响应的时钟脉冲期间发送器释放SDA 线（高）。 　　&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;在响应的时钟脉冲期间，接收器必须将SDA 线拉低，使它在这个时钟脉冲的高电平期间保持稳定的低电平。&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;也就是说主器件发送完一字节数据后要接收一个应答位（低电平），从器件接收完一个字节后要发送一个低电平。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;寻址方式(7位地址方式)&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;　　第一个字节的头7 位组成了从机地址，最低位（LSB）是第8 位，它决定了传输的 &amp;nbsp;普通的和带重复开始条件的7位地址格式方向。第一个字节的最低位是&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;“0”，表示主机会写信息到被选中的从机；&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; “1”表示主机会向从机读信息。&lt;/div&gt;&lt;div&gt;当发送了一个地址后，系统中的每个器件都在起始条件后将头7 位与它自己的地址比较，如果一样，器件会判定它被主机寻址，至于是从机接收器还是从机发送器，都由R/W 位决定。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;仲裁&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; I2C是所主机总线，每个设备都可以成为主机，但任一时刻只能有一个主机。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stm32至少有一个I2C接口，提供多主机功能，可以实现所有I2C总线的时序、协议、仲裁和定时功能，支持标准和快速传输两种模式，同时与SMBus 2.0兼容。&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 DMA数据搬运 [操作寄存器+库函数]</title>
    <link href="http://neil-pan.com/2012/07/09/stm32-DMA%E6%95%B0%E6%8D%AE%E6%90%AC%E8%BF%90-%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/09/stm32-DMA数据搬运-操作寄存器-库函数/</id>
    <published>2012-07-09T08:05:54.000Z</published>
    <updated>2024-07-11T12:49:21.217Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA（Direct Memory Access）常译为“存储器直接存取”。早在Intel的8086平台上就有了DMA应用了。</div><div> </div><div>&nbsp; &nbsp; &nbsp; &nbsp; 一个完整的微控制器通常由CPU、存储器和外设等组件构成。这些组件一般在结构和功能上都是独立的，而各个组件的协调和交互就由CPU完成。如此一来，CPU作为整个芯片的核心，其处理的工作量是很大的。如果CPU先从A外设拿到一个数据送给B外设使用，同时C外设又需要D外设提供一个数据。。。这样的数据搬运工作将使CPU的负荷显得相当繁重。</div><div> </div><div>&nbsp; &nbsp; &nbsp; &nbsp;严格的说，搬运数据只是CPU的比较不重要的一种工作。CPU最重要的工作室进行数据运算，从加减乘除到一些高级的运算，包括浮点、积分、微分、FFT等。CPU还需要负责复杂的中断申请和响应，以保证芯片的实时性能。</div><div> </div><div>&nbsp; &nbsp; 理论上常见的控制外设，比如Usart、I2C、SPI甚至是USB等通信接口，单纯的利用CPU进行协议模拟也是可以实现的，比如51单片机经常使用I/O口模拟I2C协议通信。但这样既浪费了CPU的资源，同时实现后的性能表现往往和使用专门的硬件模块实现的效果相差甚远。从这个角度来看，各个外设控制器的存在，无疑降低了CPU的负担，解放了CPU的资源。</div><div>&nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; 数据搬运这一工作占用了大部分的CPU资源，成为了降低CPU的工作效率的主要原因之一。于是需要一种硬件结构分担CPU这一职能 —— DMA。</div><div> </div><div>&nbsp; &nbsp; 从数据搬运的角度看，如果要把存储地址A的数值赋给另外一个地址上B的变量，CPU实现过程为首先读出A地址上的数据存储在一个中间变量，然后再转送到B地址的变量上。使用DMA则不需要中间变量，直接将A地址的数值传送到B地址的变量里。无疑减轻了CPU的负担，也提高了数据搬运的效率。</div><div> </div><div>stm32中 DMA1有7个通道，DMA2有5个通道。DMA挂载的时钟为AHB总线,其时钟为72Mhz，所以可以实现高速数据搬运。</div><div> </div><div>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm32的DMA1通道一览表</div><div><img src="/uploads/2012/07/3877113184.png" alt="DMA1.png"></div><div> </div><div>本例实现使用CPU和DMA搬运同一组数据，通过计时，比较两者的搬运效率。</div><div> </div><div><strong>直接操作寄存器</strong></div><div> </div><div><strong>DMA的中断状态寄存器（DMA_ISR）：</strong></div><div><img src="/uploads/2012/07/1277195535.png" alt="DMA_ISR.png"></div><div> </div><div>TEIFx：通道x的传输错误标志(x = 1 … 7) (Channel x transfer error flag) 硬件设置这些位。在DMA_IFCR寄存器的相应位写入’1’可以清除这里对应的标志位。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0：在通道x没有传输错误(TE)； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1：在通道x发生了传输错误(TE)。</div><div> </div><div>HTIFx：通道x的半传输标志(x = 1 … 7) (Channel x half transfer flag) 硬件设置这些位。在DMA_IFCR寄存器的相应位写入’1’可以清除这里对应的标志位。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0：在通道x没有半传输事件(HT)； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1：在通道x产生了半传输事件(HT)。</div><div> </div><div>TCIFx：通道x的传输完成标志(x = 1 … 7) (Channel x transfer complete flag) 硬件设置这些位。在DMA_IFCR寄存器的相应位写入’1’可以清除这里对应的标志位。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0：在通道x没有传输完成事件(TC)； &nbsp; &nbsp; &nbsp; 1：在通道x产生了传输完成事件(TC)。</div><div> </div><div><strong>DMA_IFCR中断标志清除寄存器：</strong></div><div> </div><div>结构类似DMA_ISR。</div><div> </div><div>CTEIFx：清除通道x的传输错误标志(x = 1 … 7) (Channel x transfer error clear) 这些位由软件设置和清除。 &nbsp;&nbsp;&nbsp;&nbsp;0：不起作用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1：清除DMA_ISR寄存器中的对应TEIF标志。</div><div> </div><div>CHTIFx：清除通道x的半传输标志(x = 1 … 7) (Channel x half transfer clear) 这些位由软件设置和清除。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0：不起作用 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1：清除DMA_ISR寄存器中的对应HTIF标志。</div><div> </div><div>CTCIFx：清除通道x的传输完成标志(x = 1 … 7) (Channel x transfer complete clear) 这些位由软件设置和清除。 0：不起作用 &nbsp; &nbsp; &nbsp; &nbsp;1：清除DMA_ISR寄存器中的对应TCIF标志。</div><div> </div><div>CGIFx：清除通道x的全局中断标志(x = 1 … 7) (Channel x global interrupt clear) 这些位由软件设置和清除。 &nbsp; &nbsp;0：不起作用 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1：清除DMA_ISR寄存器中的对应的GIF、TEIF、HTIF和TCIF标志。</div><div> </div><div><strong>DMA通道配置寄存器（DMA_CCRx）：</strong></div><div> </div><div><img src="/uploads/2012/07/4026871028.png" alt="DMA_CCRx.png"></div><div> </div><div>MEM2MEM：存储器到存储器模式 (Memory to memory mode) 该位由软件设置和清除。 0：非存储器到存储器模式； 1：启动存储器到存储器模式。</div><div> </div><div>PL：通道优先级 (Channel priority level) &nbsp;这些位由软件设置和清除。&nbsp;00：低 01：中 10：高 11：最高</div><div> </div><div>MSIZE：存储器数据宽度 (Memory size) 这些位由软件设置和清除。 00：8位 01：16位 10：32位 11：保留</div><div> </div><div>PSIZE：外设数据宽度 (Peripheral size) &nbsp;这些位由软件设置和清除。 00：8位 01：16位 10：32位 11：保留</div><div> </div><div>MINC：存储器地址增量模式 (Memory increment mode) &nbsp;该位由软件设置和清除。 0：不执行存储器地址增量操作 1：执行存储器地址增量操作</div><div> </div><div>PINC：外设地址增量模式 (Peripheral increment mode) 该位由软件设置和清除。 0：不执行外设地址增量操作 1：执行外设地址增量操作</div><div> </div><div>CIRC：循环模式 (Circular mode) &nbsp;该位由软件设置和清除。 0：不执行循环操作 1：执行循环操作</div><div> </div><div>DIR：数据传输方向 (Data transfer direction) &nbsp; 该位由软件设置和清除。 0：从外设读 1：从存储器读</div><div> </div><div>TEIE：允许传输错误中断 (Transfer error interrupt enable) &nbsp;该位由软件设置和清除。 0：禁止TE中断 0：允许TE中断</div><div> </div><div>HTIE：允许半传输中断 (Half transfer interrupt enable) 该位由软件设置和清除。 0：禁止HT中断 0：允许HT中断</div><div> </div><div>TCIE：允许传输完成中断 (Transfer complete interrupt enable) 该位由软件设置和清除。 0：禁止TC中断 0：允许TC中断</div><div> </div><div>EN：通道开启 (Channel enable) 该位由软件设置和清除。 0：通道不工作 1：通道开启</div><div> </div><div><strong>DMA通道x传输数量寄存器(DMA_CNDTRx)(x = 1…7)</strong></div><div> </div><div>低16位有效。这个寄存器控制通道每次传输的数据量，数据传输数量为0至65535。该寄存器会随着传输的进行而递减，为0表示已经发送完成。</div><div> </div><div><strong>DMA外设地址寄存器（DMA_CPARx）</strong></div><div>32位寄存器。外设数据寄存器的基地址，作为数据传输的源或目标。&nbsp;</div><div> </div><div><strong>DMA存储地址寄存器(DMA_CMARx)</strong></div><div>存储器地址[31:0],存储器地址作为数据传输的源或目标。</div><div> </div><div>代码如下： &nbsp;<span style="text-align: left; ">（system.h 和&nbsp;</span><span style="text-align: left; ">stm32f10x_it.h</span><span style="text-align: left; ">&nbsp;等相关代码参照&nbsp;</span><a href="http://www.ichanging.org/mdk-stm32Register-set.html" target="_blank" rel="noopener">stm32 直接操作寄存器开发环境配置</a><span style="text-align: left; ">）</span></div><div>User/main.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br>#include “system.h”<br>#include “usart.h”<br>#include “dma.h”<br>#include “tim.h”<br>#include “string.h”<br><br>#define LED1 PAout(4)<br>#define LED2 PAout(5)<br>#define LED3 PAout(6)<br><br>void Gpio_Init(void);<br><br>//数据源<br>uc32 SRC_Const_Buffer[32] =<br>{<br>    0x01020304,0x05060708,0x090A0B0C,0x0D0E0F10,<br>    0x11121314,0x15161718,0x191A1B1C,0x1D1E1F20,<br>    0x21222324,0x25262728,0x292A2B2C,0x2D2E2F30,<br>    0x31323334,0x35363738,0x393A3B3C,0x3D3E3F40,<br>    0x41424344,0x45464748,0x494A4B4C,0x4D4E4F50,<br>    0x51525354,0x55565758,0x595A5B5C,0x5D5E5F60,<br>    0x61626364,0x65666768,0x696A6B6C,0x6D6E6F70,<br>    0x71727374,0x75767778,0x797A7B7C,0x7D7E7F80<br>};<br><br>//目标位置<br>u32 DST_Buffer[32];<br><br>int main(void)<br>{<br>    u8 i=0;<br>    u16 StartTime=0,CPUSpendTime=0,DMASpendTime=0;;<br><br>    Rcc_Init(9);                            //系统时钟设置<br><br>    Usart1_Init(72,9600);<br><br>    Tim_Init(TIM_2,65535,71);            //初始化TIM2定时器，设定重装值和分频值,计时时间为1us/次<br><br>    Dma_Init(DMA1_Channel1,(u32)SRC_Const_Buffer,(u32)DST_Buffer);    //初始化DMA,外设地址示例 &amp;USART1-&gt;DR<br><br>    Nvic_Init(1,0,DMA1_Channel1_IRQChannel,4);      //设置抢占优先级为0，响应优先级为0，中断分组为4<br><br>    Gpio_Init();<br><br>    StartTime = TIM2-&gt;CNT;<br><br>    while(i&lt;32)                             //CPU搬运<br>    {<br>        DST_Buffer[i]=SRC_Const_Buffer[i];<br>        i++;<br>    }<br><br>    CPUSpendTime = TIM2-&gt;CNT - StartTime;<br><br>    printf(“\r\n the CPU spend : %dus! \r\n”,CPUSpendTime);<br><br>    if(strncmp((const char <em>)SRC_Const_Buffer,(const char </em>)DST_Buffer,32) ==0)      //验证传输效果，判断两数组是否相同<br>    {<br>        printf(“\r\n CPU Transmit Success! \r\n”);<br>    }else{<br>        printf(“\r\n CPU Transmit Fail! \r\n”);<br>    }<br><br>    i=0;<br><br>    while(i&lt;32)                            //清空目标数组，准备DMA搬运<br>    {<br>        DST_Buffer[i]=0;<br>        i++;<br>    }<br><br>    StartTime = TIM2-&gt;CNT;<br><br>    Dma_Enable(DMA1_Channel1,32);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//DMA搬运<br><br>    while( DMA1_Channel1 -&gt; CNDTR != 0);        //等待传输完成<br><br>    DMASpendTime= TIM2-&gt;CNT - StartTime;<br><br>    printf(“\r\n the DMA spend : %dus! \r\n”,DMASpendTime);<br><br>    if(strncmp((const char <em>)SRC_Const_Buffer,(const char </em>)DST_Buffer,32) ==0)      //验证传输效果，判断两数组是否相同<br>    {<br>        printf(“\r\n DMA Transmit Success! \r\n”);<br>    }else{<br>        printf(“\r\n DMA Transmit Fail! \r\n”);<br>    }<br><br>    while(1);<br>}<br><br>void Gpio_Init(void)<br>{<br>    RCC-&gt;APB2ENR|=1&lt;&lt;2;    //使能PORTA时钟<br><br>    GPIOA-&gt;CRL&amp;=0x0000FFFF; // PA0~3设置为浮空输入，PA4~7设置为推挽输出<br>    GPIOA-&gt;CRL|=0x33334444;<br><br>    //USART1 串口I/O设置<br><br>    GPIOA -&gt; CRH&amp;=0xFFFFF00F;   //设置USART1 的Tx(PA.9)为第二功能推挽，50MHz；Rx(PA.10)为浮空输入<br>    GPIOA -&gt; CRH|=0x000008B0;<br><br>}<br></pre><div>User/stm32f10x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<br>#include “system.h”<br>#include “stdio.h”<br><br>#define LED1 PAout(4)<br>#define LED2 PAout(5)<br>#define LED3 PAout(6)<br>#define LED4 PAout(7)<br><br>void DMAChannel1_IRQHandler(void)  //和启动文件有关,STM32F10x.s中 和  STM32F10x_md.s DMA中断接口函数不同<br>{<br><br>    if( DMA1 -&gt;ISR &amp; (1&lt;&lt;1))        //传输完成中断<br>    {<br><br>        LED1 = 1;<br>        DMA1-&gt;IFCR |= 1&lt;&lt;1;    //清除传输完成中断<br>    }<br><br>    if( DMA1 -&gt;ISR &amp; (1&lt;&lt;2))        //半传输完成中断<br>    {<br><br>        DMA1 -&gt;IFCR |= 1&lt;&lt;2;    //清除半传输完成中断<br>    }<br><br>    if( DMA1 -&gt;ISR &amp; (1&lt;&lt;3))        //传输错误中断<br>    {<br>        LED4 =1 ;<br>        DMA1 -&gt;IFCR |= 1&lt;&lt;3;    //清除传输错误中断<br>    }<br><br>    DMA1 -&gt;IFCR |= 1&lt;&lt;0;        //清除此通道的中断<br>}<br></pre><div>Library/src/dma.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br>#include “system.h”<br>#include “dma.h”<br><br>//DMA通道初始化函数<br>//传输方向：存储器 -&gt; 存储器模式 ,32位数据模式,存储器增量模式<br>//参数说明：<br>//            DMA_CHx         ：选择DMA控制器通道,DMA1有1-7，DMA2有1-4<br>//            P_Adress     ：外设地址<br>//            M_Adress     ：存储器地址<br><br>void Dma_Init(DMA_Channel_TypeDef <em> DMA_CHx,u32 P_Address ,u32 M_Address)<br>{<br><br>    RCC-&gt;AHBENR |= 1&lt;&lt;0;<br><br>    DMA_CHx -&gt; CCR  &amp;= 0xFFFF0000;        //复位<br><br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;1;            //允许传输完成中断<br>    //DMA_CHx -&gt; CCR  |= 1&lt;&lt;2;            //允许半传输中断<br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;3;            //允许传输错误中断 读写一个保留的地址区域,将会产生DMA传输错误<br><br>    //设定数据传输方向<br>    DMA_CHx -&gt; CCR  |= 0&lt;&lt;4;            //设定数据传输方向   0：从外设读 1：从存储器读<br>    DMA_CHx -&gt; CCR  |= 0&lt;&lt;5;            //0：不执行循环操作 1：执行循环操作<br><br>    //设定地址增量<br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;6;            //0：不执行外设地址增量操作 1：执行外设地址增量操作<br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;7;            //0：不执行存储器地址增量操作 1：执行存储器地址增量操作<br><br>    //设定外设数据宽度    S<br>    DMA_CHx -&gt; CCR  |= 0&lt;&lt;8;            //外设数据宽度,由[9:8]两位控制<br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;9;            //00：8位 01：16位 10：32位 11：保留<br><br>    //设定存储数据宽度<br>    DMA_CHx -&gt; CCR  |= 0&lt;&lt;10;            //存储器数据宽度,由[11:10]两位控制<br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;11;            //00：8位 01：16位 10：32位 11：保留<br><br>    //设定为中等优先级<br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;12;            //通道优先级,由[13:12]两位控制<br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;13;            //00：低 01：中 10：高 11：最高<br><br>    DMA_CHx -&gt; CCR  |= 1&lt;&lt;14;            //0：非存储器到存储器模式； 1：启动存储器到存储器模式。<br><br>    //必须配置好通道后配置地址<br>    DMA_CHx -&gt; CPAR = (u32)P_Address;    //设定外设寄存器地址<br>    DMA_CHx -&gt; CMAR = (u32)M_Address;    //设定数据存储器地址<br><br>}<br><br>//DMA通道使能<br>//参数说明：<br>//            DMA_CHx         ：选择DMA控制器通道,DMA1有1-7，DMA2有1-4<br>//            Number       ：数据传输量<br>void Dma_Enable(DMA_Channel_TypeDef </em> DMA_CHx,u16 Number)<br>{<br>    DMA_CHx -&gt; CCR &amp;= ~(1&lt;&lt;0);        //关闭上一次DMA传输<br>    DMA_CHx    -&gt; CNDTR = Number;        //数据传输量<br>    DMA_CHx -&gt; CCR |= 1&lt;&lt;0;            //开始DMA传输<br>}</pre><div>Library/inc/dma.h</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br><br>void Dma_Init(DMA_Channel_TypeDef <em> DMA_CHx,u32 P_Adress ,u32 M_Address);<br>void Dma_Enable(DMA_Channel_TypeDef </em> DMA_CHx,u16 Number);<br></pre></div></div><div>直接操作寄存器输出：</div><div><div> </div><div>&nbsp;the CPU spend : 972us!&nbsp;</div><div>&nbsp;CPU Transmit Success!&nbsp;</div><div> </div><div>&nbsp;the DMA spend : 5us!&nbsp;</div><div>&nbsp;DMA Transmit Success!&nbsp;</div></div></div></div><div> </div><div><strong>库函数操作</strong></div><div> </div><div>mian.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br>#include “string.h”<br><br>#define     PRINTF_ON  1<br>#define  BufferSize  32<br><br>vu16 LeftDataCounter;<br>vu32 Tick;<br><br>uc32 SRC_Const_Buffer[BufferSize] =<br>{<br>    0x01020304,0x05060708,0x090A0B0C,0x0D0E0F10,<br>    0x11121314,0x15161718,0x191A1B1C,0x1D1E1F20,<br>    0x21222324,0x25262728,0x292A2B2C,0x2D2E2F30,<br>    0x31323334,0x35363738,0x393A3B3C,0x3D3E3F40,<br>    0x41424344,0x45464748,0x494A4B4C,0x4D4E4F50,<br>    0x51525354,0x55565758,0x595A5B5C,0x5D5E5F60,<br>    0x61626364,0x65666768,0x696A6B6C,0x6D6E6F70,<br>    0x71727374,0x75767778,0x797A7B7C,0x7D7E7F80<br>};<br><br>u32 DST_Buffer[BufferSize];<br>u8 i=0,DMASpendTime=0,CPUSpendTime=0;<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void NVIC_Configuration(void);<br>void USART_Configuration(void);<br>void DMA_Configuration(void);<br><br>int main(void)<br>{<br>      RCC_Configuration();<br>      GPIO_Configuration();<br>    NVIC_Configuration();<br>    USART_Configuration();<br>    DMA_Configuration();<br><br>    SysTick_Config(72);<br><br>    Tick = 0;<br>    while(i&lt;BufferSize)<br>    {<br>        DST_Buffer[i]=SRC_Const_Buffer[i];<br>        CPUSpendTime = Tick;<br>        i++;<br>    }<br>    i=0;<br>      while(i&lt;BufferSize)<br>    {<br>        DST_Buffer[i]=0;<br>        i++;<br>    }<br><br>    Tick = 0;<br>    DMA_Cmd(DMA1_Channel6,ENABLE);<br>    while(LeftDataCounter != 0);    //等待传输完成<br>    DMASpendTime = Tick;<br><br>    if(strncmp((const char <em>)SRC_Const_Buffer,(const char </em>)DST_Buffer,BufferSize) ==0)<br>    {<br>        printf(“\r\n Transmit Success! \r\n”);<br>    }else{<br>         printf(“\r\n Transmit Fail! \r\n”);<br>    }<br><br>    printf(“\r\n the CPU spend : %dus! \r\n”,CPUSpendTime);<br>    printf(“\r\n the DMA spend : %dus! \r\n”,DMASpendTime);<br><br>}<br><br>void DMA_Configuration(void)<br>{<br>    DMA_InitTypeDef DMA_InitStructure;<br><br>    DMA_DeInit(DMA1_Channel6);<br>    DMA_InitStructure.DMA_PeripheralBaseAddr = (u32) SRC_Const_Buffer;<br>    DMA_InitStructure.DMA_MemoryBaseAddr = (u32) DST_Buffer;<br>    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<br>    DMA_InitStructure.DMA_BufferSize = BufferSize;<br>    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<br>    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<br>    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;<br>    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;<br>    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;<br>    DMA_InitStructure.DMA_Priority = DMA_Priority_High;<br>    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;<br>    DMA_Init(DMA1_Channel6,&amp;DMA_InitStructure);<br><br>    DMA_ITConfig(DMA1_Channel6,DMA_IT_TC,ENABLE);<br>}<br><br>void GPIO_Configuration(void)<br>{<br>      GPIO_InitTypeDef GPIO_InitStructure;<br>       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>}<br><br>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /<em> 复位系统时钟设置</em>/<br>      RCC_DeInit();<br>      /<em> 开启HSE</em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /<em> 等待HSE起振并稳定</em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /<em> 判断HSE起是否振成功，是则进入if()内部 </em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /<em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 </em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /<em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 </em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /<em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 </em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /<em> 设置FLASH延时周期数为2 </em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /<em> 使能FLASH预取缓存 </em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /<em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz </em> 9 = 72MHz <em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /</em> 使能PLL <em>/<br>        RCC_PLLCmd(ENABLE);<br>        /</em> 等待PLL输出稳定 <em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /</em> 选择SYSCLK时钟源为PLL <em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /</em> 等待PLL成为SYSCLK时钟源 <em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /</em> 打开APB2总线上的GPIOA时钟<em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE);<br>    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<br><br>    //RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP|RCC_APB1Periph_WWDG, ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>void NVIC_Configuration(void)<br>{<br>    NVIC_InitTypeDef NVIC_InitStructure;<br><br>    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);<br><br>    NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel6_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>    NVIC_Init(&amp;NVIC_InitStructure);<br>}<br><br>#if     PRINTF_ON<br><br>int fputc(int ch,FILE </em>f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br><br>#endif<br></pre><div>stm32f10x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<br>#include “stdio.h”<br><br>extern vu32 Tick;<br>extern vu16 LeftDataCounter;<br><br>void SysTick_Handler(void)<br>{<br>     Tick++;<br>}<br><br>void DMA1_Channel6_IRQHandler(void)<br>{<br><br>    LeftDataCounter = DMA_GetCurrDataCounter(DMA1_Channel6);   //获取剩余待传输数据<br>    DMA_ClearITPendingBit(DMA1_IT_GL6);<br>}<br></pre></div></div><div>库函数输出：</div><div><div> </div><div>&nbsp;Transmit Success!&nbsp;</div><div>&nbsp;the CPU spend : 68us!&nbsp;</div><div>&nbsp;the DMA spend : 7us!&nbsp;</div><div> </div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DMA（Direct Memory Access）常译为“存储器直接存取”。早在Intel的8086平台上就有了DMA应用了。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 Flash读写[库函数]</title>
    <link href="http://neil-pan.com/2012/07/08/stm32-Flash%E8%AF%BB%E5%86%99-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/08/stm32-Flash读写-库函数/</id>
    <published>2012-07-08T09:27:33.000Z</published>
    <updated>2024-07-11T12:49:21.219Z</updated>
    
    <content type="html"><![CDATA[<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对stm32内部的flash的读写可以实现对stm32的编程操作。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm32 的内置可编程Flash在许多场合具有十分重要的意义。如其支持ICP特性使得开发人员对stm32可以警醒调试开发，可以通过JTAG和SWD接口对stm32进行程序烧写；支持IAP特性使得开发人员可以在stm32运行程序的时候对其内部程序进行更新操作。对一些对数据安全有要求的场合，可编程FLASH可以结合stm32内部唯一的身份标识实现各种各样的防破解方案。并且stm32的FLASH在一些轻量级的防掉电存储方案中也有立足之地。</div><div> </div><div>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;stm32的FLASH分为主存储块和信息块。主存储块用于保存具体的程序代码和用户数据，信息块用于负责由stm32出厂是放置2KB的启动程序（Bootloader）和512B的用户配置信息区。</div><div> </div><div>&nbsp; &nbsp; 主存储块是以页为单位划分的，一页大小为1KB。范围为从地址0x08000000开始的128KB内。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;对Flash 的写入操作要 “先擦除后写入”的原则；</div><div>&nbsp;&nbsp;&nbsp;&nbsp;stm32的内置flash 编程操作都是以页为单位写入的，而写入的操作必须要以16位半字宽度数据位单位，允许跨页写，写入非16位数据时将导致stm32内部总线错误。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;进行内置flash读写时，必须要打开内部Rc振荡器。</div><a id="more"></a><div> </div><div>main.c:</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br><br>#define     PRINTF_ON  1<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void USART_Configuration(void);<br><br>u32 count=0;<br><br>u16 data[5]={0x0001,0x0002,0x0003,0x0004,0x0005};<br><br>int main(void)<br>{<br>      RCC_Configuration();<br>    GPIO_Configuration();<br>    USART_Configuration();<br><br>    RCC_HSICmd(ENABLE);<br><br>    FLASH_Unlock();<br><br>    FLASH_ClearFlag(FLASH_FLAG_EOP|FLASH_FLAG_PGERR|FLASH_FLAG_WRPRTERR);<br><br>    FLASH_ErasePage(0x8002000);<br><br>    while(count &lt; 5)<br>    {<br>        FLASH_ProgramHalfWord((0x8002000 +count<em>2),data[count]);  //flash  为一个字节存储，16位数据必须地址加2<br><br>        count++;<br><br>    }<br><br>    FLASH_Lock();<br><br>    count = 0;<br><br>    printf(“\r\n The Five Data Is : \r\n”);<br><br>    while(count &lt; 5)<br>    {<br><br>        printf(“\r %d \r”,</em>(u8 <em>)(0x8002000 + count</em>2));      //读取方法<br><br>        count++;<br><br>    }<br><br>    while(1);<br><br>}<br><br>void GPIO_Configuration(void)<br>{<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br><br>     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br>}<br><br>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /<em> 复位系统时钟设置</em>/<br>      RCC_DeInit();<br>      /<em> 开启HSE</em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /<em> 等待HSE起振并稳定</em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /<em> 判断HSE起是否振成功，是则进入if()内部 </em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /<em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 </em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /<em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 </em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /<em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 </em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /<em> 设置FLASH延时周期数为2 </em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /<em> 使能FLASH预取缓存 </em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /<em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz </em> 9 = 72MHz <em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /</em> 使能PLL <em>/<br>        RCC_PLLCmd(ENABLE);<br>        /</em> 等待PLL输出稳定 <em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /</em> 选择SYSCLK时钟源为PLL <em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /</em> 等待PLL成为SYSCLK时钟源 <em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /</em> 打开APB2总线上的GPIOA时钟<em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE);<br><br>    //RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<br><br>    //RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE);<br>    //RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP|RCC_APB1Periph_WWDG, ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>#if     PRINTF_ON<br><br>int fputc(int ch,FILE </em>f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br><br>#endif<br></pre></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过对stm32内部的flash的读写可以实现对stm32的编程操作。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stm32 的内置可编程Flash在许多场合具有十分重要的意义。如其支持ICP特性使得开发人员对stm32可以警醒调试开发，可以通过JTAG和SWD接口对stm32进行程序烧写；支持IAP特性使得开发人员可以在stm32运行程序的时候对其内部程序进行更新操作。对一些对数据安全有要求的场合，可编程FLASH可以结合stm32内部唯一的身份标识实现各种各样的防破解方案。并且stm32的FLASH在一些轻量级的防掉电存储方案中也有立足之地。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stm32的FLASH分为主存储块和信息块。主存储块用于保存具体的程序代码和用户数据，信息块用于负责由stm32出厂是放置2KB的启动程序（Bootloader）和512B的用户配置信息区。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; 主存储块是以页为单位划分的，一页大小为1KB。范围为从地址0x08000000开始的128KB内。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对Flash 的写入操作要 “先擦除后写入”的原则；&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stm32的内置flash 编程操作都是以页为单位写入的，而写入的操作必须要以16位半字宽度数据位单位，允许跨页写，写入非16位数据时将导致stm32内部总线错误。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;进行内置flash读写时，必须要打开内部Rc振荡器。&lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 RTC实时时钟[操作寄存器+库函数]</title>
    <link href="http://neil-pan.com/2012/07/07/stm32-RTC%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F-%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/07/stm32-RTC实时时钟-操作寄存器-库函数/</id>
    <published>2012-07-07T13:18:12.000Z</published>
    <updated>2024-07-11T12:49:21.222Z</updated>
    
    <content type="html"><![CDATA[<div>“RTC”是Real Time Clock 的简称，意为实时时钟。stm32提供了一个秒中断源和一个闹钟中断源。</div><div> </div><div>RTC的技术器是一个32位的计数器，使用32.768khz的外部晶振。</div><div> </div><div><div><div><strong>2038年问题</strong></div><div> </div><div>　在计算机应用上，2038年问题可能会导致某些软件在2038年无法正常工作。所有使用UNIX时间表示时间的程序都将受其影响，因为它们以自1970年1月1日经过的秒数（忽略闰秒）来表示时间。这种时间表示法在类Unix（Unix-like）操作系统上是一个标准，并会影响以其C编程语言开发给其他大部份操作系统使用的软件。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;在大部份的32位操作系统上，此“time_t”数据模式使用一个有正负号的32位元整数（signedint32)存储计算的秒数。也就是说最大可以计数的秒数为 2^31次方 可以算得：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2^31/3600/24/365 ≈ 68年</div><div>所以依照此“time_t”标准，在此格式能被表示的最后时间是2038年1月19日03:14:07，星期二（UTC）。超过此一瞬间，时间将会被掩盖（wrap around）且在内部被表示为一个负数，并造成程序无法工作，因为它们无法将此时间识别为2038年，而可能会依个别实作而跳回1970年或1901年。</div><div> </div><div><div>&nbsp;&nbsp;&nbsp;&nbsp;对于PC机来说，时间开始于1980年1月1日，并以无正负符号的32位整数的形式按秒递增，这与UNIX时间非常类似。可以算得：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;2^32/3600/24/365 ≈ 136年</div><div>到2116年，这个整数将溢出。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;Windows NT使用64位整数来计时。但是，它使用100纳秒作为增量单位，且时间开始于1601年1月1日，所以NT将遇到2184年问题。</div><div> </div><div>苹果公司声明，Mac在29,940年之前不会出现时间问题！</div><div> </div></div></div></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于RTC是一个32位计数器，同样其计时时间是有限的。库函数中使用到了C标准时间库，时间库中的计时起始时间是1900年，可以知道时间库中不是用 有符号位的32位整数来表示时间的，否则在1968年就已经溢出了。如果用32位无符号整数计时，其溢出时间为2036年左右，所以会遇到这个问题。</div><div> </div><div>&nbsp;&nbsp;&nbsp;&nbsp;直接操作寄存器中，可以自由设定这个时间戳起始的年份，RTC的32位寄存器存储的只是距离这个起始年份的总秒数，所以不会遇到这个问题。而且可以用无符号32位的二进制表示时间，这意味着此类系统的时间戳可以表示更多的秒数。但是由于其使用32位寄存器表示秒数，最大只能计时到136年后。</div><div> </div><div><strong>本例实现使用stm32每秒输出一次当前的时间，并设置一个闹钟，到时间时输出提醒信息。</strong></div><div> </div><a id="more"></a><div><strong>直接操作寄存器</strong></div><div> </div><div>RTC实时时钟的操作原则是 在每次读写前都要保证上一次读写完成。</div><div> </div><div>代码较多，使用到的寄存器请参见手册 &nbsp;<span style="text-align: left; ">（system.h 和&nbsp;</span><span style="text-align: left; ">stm32f10x_it.h</span><span style="text-align: left; ">&nbsp;等相关代码参照&nbsp;</span><a href="http://www.ichanging.org/mdk-stm32Register-set.html" target="_blank" rel="noopener">stm32 直接操作寄存器开发环境配置</a><span style="text-align: left; ">）</span></div><div> </div><div>User/main.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br>#include “system.h”<br>#include “usart.h”<br>#include “rtc.h”<br><br>#define LED1 PAout(4)<br>#define LED2 PAout(5)<br><br>void Gpio_Init(void);<br><br>extern const u8<em> Week_Table[7];<br><br>int main(void)<br>{<br><br>    Rcc_Init(9);                            //系统时钟设置<br><br>    Usart1_Init(72,9600);<br><br>    Nvic_Init(0,0,RTC_IRQChannel,0);      //设置中断<br><br>    Gpio_Init();<br><br>    Rtc_Init();<br><br>    //Rtc_TIME_AutoSet();                //将当前编译时间作为RTC开始时间<br>    Rtc_TIME_Set(2012,7,7,20,50,0);        //设定开始时间 参数说明：年，月，日，时，分，秒<br><br>    Rtc_ALARM_Set(2012,7,7,20,50,30);    //设定闹钟事件时间<br><br>    LED1 = 1;<br><br>    while(1);<br>}<br><br>void Gpio_Init(void)<br>{<br>    RCC-&gt;APB2ENR|=1&lt;&lt;2;    //使能PORTA时钟<br><br>    GPIOA-&gt;CRL&amp;=0x0000FFFF; // PA0~3设置为浮空输入，PA4~7设置为推挽输出<br>    GPIOA-&gt;CRL|=0x33334444;<br><br>    //USART1 串口I/O设置<br><br>    GPIOA -&gt; CRH&amp;=0xFFFFF00F;   //设置USART1 的Tx(PA.9)为第二功能推挽，50MHz；Rx(PA.10)为浮空输入<br>    GPIOA -&gt; CRH|=0x000008B0;<br>} </em></pre><div>User/stm32f103x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<br>#include “system.h”<br>#include “stdio.h”<br>#include “rtc.h”<br><br>#define LED1 PAout(4)<br>#define LED2 PAout(5)<br>#define LED3 PAout(6)<br>#define LED4 PAout(7)<br><br>//extern void Wwdg_Feed(void);<br>//extern u16 Read_Bkp(u8 reg);<br>extern void Rtc_Get(void);<br>extern const u8 Week_Table[7];<br><br>void RTC_IRQHandler(void)<br>{<br><br>    if(RTC-&gt;CRL&amp;0x0001)                    //秒钟中断<br>    {<br>        LED4 = !LED4;<br>        Rtc_Get();<br><br>        printf(“\r\n Time : %d - %d - %d,%d : %d : %d ,Today is %s \r\n”,<br><br>                timer.year,<br><br>                timer.month,<br><br>                timer.date,<br><br>                timer.hour,<br><br>                timer.minute,<br><br>                timer.second,<br>                Week_Table[timer.week]<br>        );<br>    }<br><br>    if(RTC-&gt;CRL&amp;0x0002)                    //闹钟中断<br>    {<br>        LED3 = 1;<br><br>        printf(“\r\nIt’s time to do sth.\r\n”);<br><br>        RTC-&gt;CRL &amp;= ~(0x0002);            //清除闹钟中断<br><br>    }<br><br>    RTC-&gt;CRL &amp;= 0x0FFA;                 //清除溢出，秒钟中断<br><br>    while(!(RTC-&gt;CRL &amp;(1&lt;&lt;5)));            //等待RTC寄存器操作完成<br><br>}<br></pre><div>Library/src/rtc.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br>#include “rtc.h”<br>#include “stdio.h”<br><br>tm timer;                    //定义时钟结构体,主函数直接可以调用此结构体读出时间<br><br>//平年的月份日期表,月份缩写表<br>const u8 Days_Table[12]={31,28,31,30,31,30,31,31,30,31,30,31};<br>const u8 Month_Table[12][3]={“Jan”,”Feb”,”Mar”,”Apr”,”May”,”Jun”,”Jul”,”Aug”,”Sep”,”Oct”,”Nov”,”Dec”};<br><br>const u8<em> Week_Table[7]={“Sunday”,”Monday”,”Tuesday”,”Wednesday”,”Thursday”,”Friday”,”Saturday”};<br><br>//月修正数据表<br>u8 const _Week[12]={0,3,3,6,1,4,6,2,5,0,3,5};<br><br>void Rtc_Init(void)<br>{<br>    RCC-&gt;APB1ENR |= 1&lt;&lt;28;    //使能PWR时钟<br>    RCC-&gt;APB1ENR |= 1&lt;&lt;27;  //使能BKP时钟,RTC校准在BKP相关寄存器中<br>     PWR-&gt;CR |= 1&lt;&lt;8;        //取消BKP相关寄存器写保护<br><br>    //RCC-&gt;BDCR |= 1&lt;&lt;16;    //备份区域软复位<br>    //RCC-&gt;BDCR |= ~(1&lt;&lt;16);    //备份区域软复位结束<br><br>    RCC-&gt;BDCR |= 1&lt;&lt;0;        //外部低速时钟（LSE）使能<br><br>    while(!(RCC-&gt;BDCR &amp; 0x02));    //等待外部时钟就绪<br><br>    RCC-&gt;BDCR |= 1&lt;&lt;8;            //LSE作为RTC时钟<br>    RCC-&gt;BDCR |= 1&lt;&lt;15;            //RTC时钟使能<br><br>    while(!(RTC-&gt;CRL &amp; (1&lt;&lt;5)));    //等待RTC寄存器最后一次操作完成<br>    while(!(RTC-&gt;CRL &amp; (1&lt;&lt;3)));    //等待RTC寄存器同步完成<br><br>    RTC-&gt;CRH |= 0x07;                //允许溢出中断[2]，闹钟中断[1]，秒中断[0],CRH寄存器低三位有效<br><br>    while(!(RTC-&gt;CRL &amp; (1&lt;&lt;5)));    //等待RTC寄存器最后一次操作完成<br><br>    RTC-&gt;CRL |=  1&lt;&lt;4;                //进入配置模式<br>    RTC-&gt;PRLH = 0x0000;<br>    RTC-&gt;PRLL = 32767;                //设定分频值<br><br>    //Rtc_TIME_AutoSet();                //将当前编译时间写入寄存器<br>    //Rtc_TIME_Set(2012,7,7,20,50,0);    //年，月，日，时，分，秒<br><br>    RTC-&gt;CRL &amp;= ~(1&lt;&lt;4);            //退出配置模式，开始更新RTC寄存器<br>    while(!(RTC-&gt;CRL &amp; (1&lt;&lt;5)));    //等待RTC寄存器最后一次操作完成<br><br>}<br><br>//设定RTC开始计时时间<br>void Rtc_TIME_Set(u16 year,u8 month,u8 date,u8 hour,u8 minute, u8 second)<br>{<br>        u32 sec;<br><br>        sec = Date_TO_Sec(year,month,date,hour,minute,second);<br><br>        //printf(“\nRtc TIME Set  Sec = %x\n”,sec);<br><br>        RCC-&gt;APB1ENR |= 1&lt;&lt;28;                            //使能PWR时钟,方便独立调用此函数<br>        RCC-&gt;APB1ENR |= 1&lt;&lt;27;                            //使能BKP时钟<br>        PWR-&gt;CR |= 1&lt;&lt;8;                                //取消写保护<br><br>        RTC-&gt; CRL |= 1&lt;&lt;4;                                //允许配置<br><br>        RTC-&gt; CNTL = sec&amp;0xffff;                        //取低16位<br>        RTC-&gt; CNTH = sec&gt;&gt;16;                            //取高16位<br><br>        RTC-&gt; CRL &amp;= ~(1&lt;&lt;4);                            //开始RTC寄存器更新<br><br>        while(!(RTC-&gt;CRL&amp;(1&lt;&lt;5)));                        //等待RTC寄存器操作完成<br>}<br><br>//判断是否是闰年函数<br>//<br>//判断方法：<br>//        普通年能整除4且不能整除100的为闰年。（如2004年就是闰年,1900年不是闰年）<br>//        世纪年能整除400的是闰年。(如2000年是闰年，1900年不是闰年)<br>//<br>//返回: 1,是闰年     0,不是闰年<br>u8 Is_LeapYear(u16 year)<br>{<br>    if(year%4==0)                 //必须能被4整除<br>    {<br>        if(year%100==0)<br>        {<br>            if(year%400==0)<br>                return 1;        //如果以00结尾,还要能被400整除<br>            else<br>                return 0;<br>        }else{<br>            return 1;<br>        }<br>    }else{<br>         return 0;<br>    }<br>}<br><br>//将时间转化为到1970年1月1日的总秒数<br>//Bugs:此函数秒数会多20左右，所以函数返回值做了校正,校正后没有问题<br>//待优化<br>u32 Date_TO_Sec(u16 year,u8 month,u8 date,u8 hour,u8 minute, u8 second)<br>{<br>    u16 t;<br>    u32 sec;<br><br>    if(year &gt;= 1970 &amp;&amp; year&lt;= 2106)          //判断是否为合法年份，RTC的时间是从1970开始，只能由32位表示秒数，最大只能到2106年左右<br>    {<br>        for(t= 1970 ;t&lt;year;t++)           //所有年份秒数累加<br>        {<br>            if(Is_LeapYear(t))              //判断是否为闰年<br><br>                sec += 31622400;<br>            else<br>                sec += 31536000;<br>        }<br><br>        for(t=0;t&lt;month-1;t++)                           //月份秒数累加<br>        {<br>            sec += (u32) Days_Table[t]</em>86400;<br>            if(Is_LeapYear(year) &amp;&amp; t== 1)                 //闰年加一天的秒钟数<br>                sec += 86400;<br><br>        }<br><br>        sec += (u32)(date-1)<em>86400;                        //本月日期的秒数累加<br>        sec += (u32)(hour)</em>3600;<br>        sec += (u32)(minute)<em>60;<br>        sec += second;<br>    }<br><br>    return sec-20;                                        //校正20秒，原因不详<br><br>}<br><br>//自动获取当前时间配置RTC<br>//可以根据MDK关键字获取时间<br>//<strong>DATE</strong>  获取编译日期, 格式为: Jul 7 2012<br>//<strong>TIME</strong>  获取编译时间, 格式为: 14:54:44<br><br>void Rtc_TIME_AutoSet()<br>{<br>       u16 year,i=0,j=0;<br>    u8  mon,date,sec,min,hour;<br><br>    u8 </em>_date = <strong>DATE</strong>;<br>    u8 <em>_time = <strong>TIME</strong>;<br><br>       for(i=0;i&lt;12;i++)<br>    {<br>        for(j=0;j&lt;3;j++)<br>        {<br>            if(Month_Table[i][j] == _date[j]) mon = i;    //得到月份<br>        }<br>    }<br><br>    if(_date[4]==’ ‘){             //得到日期<br>        date=_date[5]-‘0’;         //-‘0’操作将字符型转换为整型,参考ASCII码的转换，eg ‘7’-‘0’ =7<br>    }else{<br>        date=10</em>(_date[4]-‘0’)+_date[5]-‘0’;<br>    }<br><br>    year=1000<em>(_date[7]-‘0’)+100</em>(_date[8]-‘0’)+10<em>(_date[9]-‘0’)+_date[10]-‘0’;  //得到年份<br>    hour=10</em>(_time[0]-‘0’)+_time[1]-‘0’;                                            //得到小时<br>    min=10<em>(_time[3]-‘0’)+_time[4]-‘0’;<br>    sec=10</em>(_time[6]-‘0’)+_time[7]-‘0’;<br><br>    //printf(“\n%d-%d-%d  %d:%d:%d\n”,year,mon,date,hour,min,sec);<br><br>    Rtc_TIME_Set(year,mon,date,hour,min,sec);<br>}<br><br>//获取RTC时间<br>void Rtc_Get()<br>{<br>    u32 secs,days,temp,years = 1970,months = 0;<br><br>    secs = RTC-&gt;CNTH;     //读取RTC的当前时间值（距1970年的总秒数）<br>    secs &lt;&lt;= 16;<br>    secs += RTC-&gt;CNTL;<br><br>    //printf(“\nRtc_Get  Sec = %x\n”,secs);<br><br>    days = secs/86400;<br>    if(days &gt; 0)            //超过一天<br>    {<br>        temp = days;<br>        while(temp &gt;= 365)<br>        {<br>            if(Is_LeapYear(years))                //是闰年<br>            {<br>                if(temp &gt;= 366)<br>                    temp -=    366;    //闰年的天数<br>                else<br>                    break;<br>            }else{<br>                 temp -= 365;<br>            }<br>            years++;<br>        }<br><br>        timer.year = years;              //得到年份<br><br>        while(days &gt;= 28)<br>        {<br>            if(Is_LeapYear(years) &amp;&amp; months ==1)       //判断是否为闰年的第二月<br>            {<br>                if(temp &gt;= 29)<br>                    temp -= 29;<br>                else<br>                    break;<br>            }else{<br>                if(temp &gt;= Days_Table[months])<br>                    temp -= Days_Table[months];<br>                else<br>                    break;<br>            }<br><br>            months++;<br>        }<br><br>        timer.month = months+1;                //得到月数<br>         timer.date  = temp+1;                //得到日期<br>    }<br><br>    temp = secs % 86400;                    //得到剩余秒数<br>    timer.hour = temp/3600;                    //得到小时<br>    timer.minute = (temp%3600)/60;<br>    timer.second = (temp%3600)%60;<br>    timer.week = Rtc_DAY_Get(timer.year,timer.month,timer.date);<br><br>}<br><br>//判断当前为星期几<br><br>u8 Rtc_DAY_Get(u16 year,u8 month,u8 day)<br>{<br>    u16 temp;<br>    u8 yearH,yearL;<br><br>    yearH = year/100;<br>    yearL = year%100;<br><br>    // 如果为21世纪,年份数加100<br>    if( yearH &gt; 19 ) yearL += 100;<br><br>    // 所过闰年数只算1900年之后的<br><br>    temp = yearL+yearL/4;<br>    temp = temp%7;<br>    temp = temp + day + _Week[month-1];<br><br>    if( yearL%4 == 0 &amp;&amp; month &lt; 3 ) temp–;<br><br>    return(temp%7);<br>}<br><br>//设定闹钟时间<br><br>void Rtc_ALARM_Set(u16 year,u8 month,u8 date,u8 hour,u8 minute, u8 second)<br>{<br><br>        u32 sec;<br><br>        sec = Date_TO_Sec(year,month,date,hour,minute,second);<br><br>        RTC-&gt; CRL |= 1&lt;&lt;4;                                //允许配置<br><br>        //while(!(RTC-&gt;CRL&amp;(1&lt;&lt;5)));                        //RTOFF为1 才可以写入ALRL和ALRH寄存器<br><br>        RTC-&gt; ALRL = sec&amp;0xffff;                        //取低16位<br>        RTC-&gt; ALRH = sec&gt;&gt;16;                            //取高16位<br><br>        RTC-&gt; CRL &amp;= ~(1&lt;&lt;4);                            //开始RTC寄存器更新<br><br>        while(!(RTC-&gt;CRL&amp;(1&lt;&lt;5)));                        //等待RTC寄存器操作完成<br><br>}<br></pre></div></div></div><div>Library/inc/rtc.h</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br><br>typedef struct<br>{<br>    u8 hour;<br>    u8 minute;<br>    u8 second;<br><br>    u16 year;<br>    u8  month;<br>    u8     date;<br>    u8    week;<br>}tm;<br><br>extern tm timer;<br><br>void Rtc_Init(void);<br>void Rtc_TIME_Set(u16 year,u8 month,u8 date,u8 hour,u8 minute, u8 second);<br>u8 Is_LeapYear(u16 year);<br>u32  Date_TO_Sec(u16 year,u8 month,u8 date,u8 hour,u8 minute, u8 second);<br>void Rtc_TIME_AutoSet(void);<br>void Rtc_Get(void);<br>void Rtc_ALARM_Set(u16 year,u8 month,u8 date,u8 hour,u8 minute, u8 second);<br>u8 Rtc_DAY_Get(u16 year,u8 month,u8 day);</pre></div><div>这里用到了MDK的两个关键字 <strong>DATE</strong> 和 <strong>TIME</strong>获得当前编译的日期和时间，详见代码注释</div><div> </div><div><strong>库函数操作</strong></div><div> </div><div>ANSI C语言所提供的time.h的头文件中关于unix时间戳是从1900年开始的，和直接操作寄存器不同，所以如果unix时间戳中读出年份为100，则正确年份为1900+100=2000</div><div> </div><div>代码如下:</div><div> </div><div>main.c</div><pre class="brush:cpp;">#include “stm32f10x.h”<br>#include “stdio.h”<br>#include “time.h”<br><br>#define     PRINTF_ON  1<br><br>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void NVIC_Configuration(void);<br>void USART_Configuration(void);<br>void RTC_Configuration(void);<br><br>void TimeShow(void);<br><br>void SetAlarm(struct tm t);<br>void SetCalendarTime(struct tm t);<br>void SetUnixTime(time_t);<br>struct tm  ConvUnixToCalendar(time_t t);<br>u32 ConvCalendarToUnix(struct tm t);<br>u32 GetUnixTime(void);<br><br>vu32  Display;<br><br>struct tm CurrentTime = {0,30,10,11,4,2011};<br>struct tm AlarmTime = {5,30,10,11,4,2011};<br><br>int main(void)<br>{<br>      RCC_Configuration();<br>      GPIO_Configuration();<br>    NVIC_Configuration();<br>    USART_Configuration();<br>    RTC_Configuration();<br><br>    SetCalendarTime(CurrentTime);<br>    SetAlarm(AlarmTime);<br>    while(1){ TimeShow(); }<br>}<br><br>void TimeShow(void)<br>{<br>    u32    Time = 0;<br>    if(Display)<br>    {<br>        Time = GetUnixTime();<br>        CurrentTime = ConvUnixToCalendar(Time);<br><br>        printf(“\r\n Time : %d - %d - %d，%d : %d : %d \r\n”,<br>            CurrentTime.tm_year,<br>            CurrentTime.tm_mon,<br>            CurrentTime.tm_mday,<br>            CurrentTime.tm_hour,<br>            CurrentTime.tm_min,<br>            CurrentTime.tm_sec);<br>        Display = 0;<br>    }<br>}<br><br>void SetCalendarTime(struct tm t)<br>{<br>    SetUnixTime(ConvCalendarToUnix(t));<br>}<br><br>void SetUnixTime(time_t t)<br>{<br>    RTC_WaitForLastTask();<br>    RTC_SetCounter((u32)t);<br>    RTC_WaitForLastTask();<br>}<br><br>void SetAlarm(struct tm t)<br>{<br>    RTC_WaitForLastTask();<br>    RTC_SetAlarm(ConvCalendarToUnix(t));<br>    RTC_WaitForLastTask();<br>}<br><br>u32 GetUnixTime(void)<br>{<br>    return (u32)RTC_GetCounter();<br>}<br><br>u32 ConvCalendarToUnix(struct tm t)<br>{<br>    t.tm_year -=1900;<br>    return mktime(&amp;t);<br>}<br><br>struct tm  ConvUnixToCalendar(time_t t)<br>{<br>    struct tm <em>t_tm;<br>    t_tm = localtime(&amp;t);<br>    t_tm-&gt;tm_year += 1900;<br>    return </em>t_tm;<br>}<br><br>void GPIO_Configuration(void)<br>{<br>      GPIO_InitTypeDef GPIO_InitStructure;<br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;<br>      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br><br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);<br>}<br><br>void RTC_Configuration(void)<br>{<br>    PWR_BackupAccessCmd(ENABLE);<br>    BKP_DeInit();<br>    RCC_LSEConfig(RCC_LSE_ON);<br>    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET);<br>    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);<br>    RCC_RTCCLKCmd(ENABLE);<br><br>    RTC_WaitForSynchro();<br>    RTC_WaitForLastTask();<br><br>    RTC_ITConfig(RTC_IT_SEC|RTC_IT_ALR,ENABLE);<br>    RTC_WaitForLastTask();<br><br>    RTC_SetPrescaler(32767);<br>    RTC_WaitForLastTask();<br>}<br><br>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;<br><br>      /<em> 复位系统时钟设置</em>/<br>      RCC_DeInit();<br>      /<em> 开启HSE</em>/<br>      RCC_HSEConfig(RCC_HSE_ON);<br>      /<em> 等待HSE起振并稳定</em>/<br>      HSEStartUpStatus = RCC_WaitForHSEStartUp();<br>    /<em> 判断HSE起是否振成功，是则进入if()内部 </em>/<br>      if(HSEStartUpStatus == SUCCESS)<br>      {<br>        /<em> 选择HCLK（AHB）时钟源为SYSCLK 1分频 </em>/<br>        RCC_HCLKConfig(RCC_SYSCLK_Div1);<br>        /<em> 选择PCLK2时钟源为 HCLK（AHB） 1分频 </em>/<br>        RCC_PCLK2Config(RCC_HCLK_Div1);<br>        /<em> 选择PCLK1时钟源为 HCLK（AHB） 2分频 </em>/<br>        RCC_PCLK1Config(RCC_HCLK_Div2);<br>        /<em> 设置FLASH延时周期数为2 </em>/<br>        FLASH_SetLatency(FLASH_Latency_2);<br>        /<em> 使能FLASH预取缓存 </em>/<br>        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);<br>        /<em> 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz </em> 9 = 72MHz <em>/<br>        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);<br>        /</em> 使能PLL <em>/<br>        RCC_PLLCmd(ENABLE);<br>        /</em> 等待PLL输出稳定 <em>/<br>        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);<br>        /</em> 选择SYSCLK时钟源为PLL <em>/<br>        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);<br>        /</em> 等待PLL成为SYSCLK时钟源 <em>/<br>        while(RCC_GetSYSCLKSource() != 0x08);<br>      }<br>      /</em> 打开APB2总线上的GPIOA时钟<em>/<br>      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE);<br><br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP, ENABLE);<br><br>}<br><br>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;<br><br>    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;<br>    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;<br>    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;<br>    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;<br>    USART_ClockInit(USART1 , &amp;USART_ClockInitStructure);<br><br>    USART_InitStructure.USART_BaudRate = 9600;<br>    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>    USART_InitStructure.USART_StopBits = USART_StopBits_1;<br>    USART_InitStructure.USART_Parity = USART_Parity_No;<br>    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<br>    USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;<br>    USART_Init(USART1,&amp;USART_InitStructure);<br><br>     USART_Cmd(USART1,ENABLE);<br>}<br><br>void NVIC_Configuration(void)<br>{<br>    NVIC_InitTypeDef NVIC_InitStructure;<br><br>    NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<br>    NVIC_Init(&amp;NVIC_InitStructure);<br><br>}<br><br>#if     PRINTF_ON<br><br>int fputc(int ch,FILE </em>f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}<br><br>#endif<br></pre><div>stm32f10x_it.c:<p></p><pre class="brush:cpp;">#include “stm32f10x_it.h”<br><br>#include “stdio.h”<br><br>extern vu32 Display;<br><br>void RTC_IRQHandler(void)<br>{<br>    if(RTC_GetFlagStatus(RTC_FLAG_ALR) != RESET){<br>        printf(“\r\nIt’s time to do sth.\r\n”);<br>    }else{<br>        Display =1 ;<br><br>    }<br><br>    RTC_ClearITPendingBit(RTC_IT_ALR|RTC_IT_SEC);<br>}<br></pre></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;“RTC”是Real Time Clock 的简称，意为实时时钟。stm32提供了一个秒中断源和一个闹钟中断源。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;RTC的技术器是一个32位的计数器，使用32.768khz的外部晶振。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;2038年问题&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;　在计算机应用上，2038年问题可能会导致某些软件在2038年无法正常工作。所有使用UNIX时间表示时间的程序都将受其影响，因为它们以自1970年1月1日经过的秒数（忽略闰秒）来表示时间。这种时间表示法在类Unix（Unix-like）操作系统上是一个标准，并会影响以其C编程语言开发给其他大部份操作系统使用的软件。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在大部份的32位操作系统上，此“time_t”数据模式使用一个有正负号的32位元整数（signedint32)存储计算的秒数。也就是说最大可以计数的秒数为 2^31次方 可以算得：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 2^31/3600/24/365 ≈ 68年&lt;/div&gt;&lt;div&gt;所以依照此“time_t”标准，在此格式能被表示的最后时间是2038年1月19日03:14:07，星期二（UTC）。超过此一瞬间，时间将会被掩盖（wrap around）且在内部被表示为一个负数，并造成程序无法工作，因为它们无法将此时间识别为2038年，而可能会依个别实作而跳回1970年或1901年。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于PC机来说，时间开始于1980年1月1日，并以无正负符号的32位整数的形式按秒递增，这与UNIX时间非常类似。可以算得：&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;2^32/3600/24/365 ≈ 136年&lt;/div&gt;&lt;div&gt;到2116年，这个整数将溢出。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Windows NT使用64位整数来计时。但是，它使用100纳秒作为增量单位，且时间开始于1601年1月1日，所以NT将遇到2184年问题。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;苹果公司声明，Mac在29,940年之前不会出现时间问题！&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于RTC是一个32位计数器，同样其计时时间是有限的。库函数中使用到了C标准时间库，时间库中的计时起始时间是1900年，可以知道时间库中不是用 有符号位的32位整数来表示时间的，否则在1968年就已经溢出了。如果用32位无符号整数计时，其溢出时间为2036年左右，所以会遇到这个问题。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;直接操作寄存器中，可以自由设定这个时间戳起始的年份，RTC的32位寄存器存储的只是距离这个起始年份的总秒数，所以不会遇到这个问题。而且可以用无符号32位的二进制表示时间，这意味着此类系统的时间戳可以表示更多的秒数。但是由于其使用32位寄存器表示秒数，最大只能计时到136年后。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;本例实现使用stm32每秒输出一次当前的时间，并设置一个闹钟，到时间时输出提醒信息。&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 BKP寄存器操作[操作寄存器+库函数]</title>
    <link href="http://neil-pan.com/2012/07/06/stm32-BKP%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C-%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/06/stm32-BKP寄存器操作-操作寄存器-库函数/</id>
    <published>2012-07-06T09:13:45.000Z</published>
    <updated>2024-07-11T12:49:21.215Z</updated>
    
    <content type="html"><![CDATA[<div>BKP是“BACKUP”的缩写，stm32f103RCTE的内部配备了10个16位宽度的BKP寄存器。在主电源切断或系统产生复位时间时，BKP寄存器仍然可以在备用电源的支持下保持其内容。&nbsp;</div><div>BKP在实际应用中可以存入重要数据，防止被恶意查看，或用于断电回复等。</div><div> </div><div><strong>本例实现对BKP寄存器的读写操作，和入侵检测和处理。主程序中写入寄存器后，依次打印出10个BKP寄存器数据，然后触发GPIOC13的入侵中断（输入低电平），在中断中打印出入侵事件发生后的寄存器内容（复位为0 ）。</strong></div><div> </div><div><strong>直接操作寄存器</strong></div><div>用到的寄存器描述如下：</div><div><div> </div><div><strong>备份数据寄存器x(BKP_DRx) (x = 1 … 10)：</strong>低16位[15:0]有效，用来写入或读出备份数据。</div><div> </div><div><strong>备份控制寄存器(BKP_CR)：</strong></div><div>低两位有效。</div><div>TPAL[1]：侵入检测TAMPER引脚有效电平(TAMPER pin active level)</div><ul><li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0：侵入检测TAMPER引脚上的高电平会清除所有数据备份寄存器(如果TPE位为1)</li><li><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1：侵入检测TAMPER引脚上的低电平会清除所有数据备份寄存器(如果TPE位为1)<div>TPE[0]：启动侵入检测TAMPER引脚(TAMPER pin enable)</div></p></li><li><p>0：侵入检测TAMPER引脚作为通用IO口使用</p></li><li>1：开启侵入检测引脚作为侵入检测使用<div><strong>备份控制/状态寄存器(BKP_CSR):</strong></div><div> </div><div><img src="/uploads/2012/07/3972267929.png" alt="BKP_CSR.png"></div><p><a id="more"></a></p></li></ul></div><div>TIF[9]：侵入中断标志(Tamper interrupt flag) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0：无侵入中断 &nbsp; &nbsp; 1：产生侵入中断</div><div>当检测到有侵入事件且TPIE位为1时，此位由硬件置1。</div><div>通过向CTI位写1来清除此标志位(同时也清除了中断)。如果TPIE位被清除，则此位也会被清除。&nbsp;</div><div> </div><div>TEF[8]：侵入事件标志(Tamper event flag)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0：无侵入事件 &nbsp; &nbsp; &nbsp; 1：检测到侵入事件&nbsp;</div><div>当检测到侵入事件时此位由硬件置1。通过向CTE位写1可清除此标志位&nbsp;</div><div> </div><div>TPIE[2]：允许侵入TAMPER引脚中断(TAMPER pin interrupt enable)</div><div>0：禁止侵入检测中断 1：允许侵入检测中断(BKP_CR寄存器的TPE位也必须被置1)</div><div>注1：侵入中断无法将系统内核从低功耗模式唤醒。 注2：仅当系统复位或由待机模式唤醒后才复位该位。</div><div> </div><div>CTI[1]：清除侵入检测中断(Clear tamper interrupt) &nbsp;</div><div>0：无效 1：清除侵入检测中断和TIF侵入检测中断标志</div><div> </div><div>CTE[0]：清除侵入检测事件(Clear tamper event)</div><div>&nbsp;0：无效 1：清除TEF侵入检测事件标志(并复位侵入检测器)。</div><div> </div><div>要写入BKP寄存器数据必须在 PWR-&gt;CR中取消备份区写保护，才可以写入BKP数据。stm32开启入侵检测也不需要设置GPIOC的时钟和输入输出模式。</div><div> </div><div>代码如下：<span style="text-align: left; ">（system.h 和&nbsp;</span><span style="text-align: left; ">stm32f10x_it.h</span><span style="text-align: left; ">&nbsp;等相关代码参照&nbsp;</span><a href="http://www.ichanging.org/mdk-stm32Register-set.html" target="_blank" rel="noopener">stm32 直接操作寄存器开发环境配置</a><span style="text-align: left; ">）</span></div><div>User/main.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br>#include “system.h”<br>#include “usart.h”<br>#include “bkp.h” <p>#define LED1 PAout(4)</p><p>#define LED2 PAout(5)</p><p>void Gpio_Init(void);</p><p>int main(void)<br>{<br>    u16 data,i=10;</p><pre><code>Rcc_Init(9);                            //系统时钟设置Usart1_Init(72,9600);Bkp_Init();Tamper_Init();Nvic_Init(0,0,TAMPER_IRQChannel,0);      //设置中断Gpio_Init();while(i){    Write_Bkp(i,i);    data = Read_Bkp(i);    printf(&quot;\n DR%u = 0x%04X\n&quot;,i,data);    delay(30000);   //延时30ms    i--;}while(1);        </code></pre><p>}</p><p>void Gpio_Init(void)<br>{<br>    RCC-&gt;APB2ENR|=1&lt;&lt;2;    //使能PORTA时钟     </p><pre><code>GPIOA-&amp;gt;CRL&amp;amp;=0x0000FFFF; // PA0~3设置为浮空输入，PA4~7设置为推挽输出GPIOA-&amp;gt;CRL|=0x33334444; //USART1 串口I/O设置GPIOA -&amp;gt; CRH&amp;amp;=0xFFFFF00F;   //设置USART1 的Tx(PA.9)为第二功能推挽，50MHz；Rx(PA.10)为浮空输入GPIOA -&amp;gt; CRH|=0x000008B0;      </code></pre><p>}<br></p></pre></div><div>User/stm32f103x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<p></p><p>#include “system.h”</p><p>#include “stdio.h”</p><p>#define LED1 PAout(4)</p><p>#define LED2 PAout(5)</p><p>#define LED3 PAout(6)</p><p>#define LED4 PAout(7)</p><p>extern u16 Read_Bkp(u8 reg);</p><p>void TAMPER_IRQHandler(void)<br>{<br>    u16 i=10,data;</p><pre><code>LED4 =1 ;printf(&quot;\r\n A Tamper is coming .\r\n&quot;);while(i){    data = Read_Bkp(i);    printf(&quot;\n DR%u = 0x%04X\n&quot;,i,data);    delay(30000);   //延时30ms    i--;}BKP-&amp;gt;CSR |= 3&amp;lt;&amp;lt;0;    //清除事件中断标志位</code></pre><p>}<br></p></pre><div>Library/src/bkp.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<p></p><p>#include “bkp.h”</p><p>void Bkp_Init(void)<br>{<br>    RCC-&gt;APB1RSTR |= 1&lt;&lt;27;        //复位BKP寄存器<br>    RCC-&gt;APB1RSTR &amp;= ~(1&lt;&lt;27);</p><pre><code>RCC-&amp;gt;APB1ENR|=1&amp;lt;&amp;lt;28;     //使能电源时钟        RCC-&amp;gt;APB1ENR|=1&amp;lt;&amp;lt;27;     //使能BKP时钟      </code></pre><p>}</p><p>/**</p><ul><li><p><em>后备寄存器写入操作</em>reg:寄存器编号<br><em>data:要写入的数值 </em><br>**/<br>void Write_Bkp(u8 reg,u16 data)<br>{  </p><p>PWR-&gt;CR|=1&lt;&lt;8;           //取消备份区写保护 </p><p>switch(reg)<br>{</p><pre><code>case 1:    BKP-&amp;gt;DR1=data;    break;case 2:    BKP-&amp;gt;DR2=data;    break;case 3:    BKP-&amp;gt;DR3=data;    break; case 4:    BKP-&amp;gt;DR4=data;    break;case 5:    BKP-&amp;gt;DR5=data;    break;case 6:    BKP-&amp;gt;DR6=data;    break;case 7:    BKP-&amp;gt;DR7=data;    break;case 8:    BKP-&amp;gt;DR8=data;    break;case 9:    BKP-&amp;gt;DR9=data;    break;case 10:    BKP-&amp;gt;DR10=data;    break;</code></pre><p>}<br>}</p></li></ul><p>u16 Read_Bkp(u8 reg)<br>{<br>    u16 data;</p><pre><code>switch(reg){    case 1:        data = BKP-&amp;gt;DR1;        break;    case 2:        data = BKP-&amp;gt;DR2;        break;    case 3:        data = BKP-&amp;gt;DR3;        break;     case 4:        data = BKP-&amp;gt;DR4;        break;    case 5:        data = BKP-&amp;gt;DR5;        break;    case 6:        data = BKP-&amp;gt;DR6;        break;    case 7:        data = BKP-&amp;gt;DR7;        break;    case 8:        data = BKP-&amp;gt;DR8;        break;    case 9:        data = BKP-&amp;gt;DR9;        break;    case 10:        data = BKP-&amp;gt;DR10;        break;} return data;</code></pre><p>}</p><p>//开启入侵检测,检测引脚为GPIOC13 但是不用打开其时钟和设置引脚模式<br>void Tamper_Init()<br>{</p><pre><code>BKP-&amp;gt;CSR |= 3&amp;lt;&amp;lt;0;            //清除事件中断标志位BKP-&amp;gt;CR  |= 1&amp;lt;&amp;lt;1;            //设定为入侵电平为低电平BKP-&amp;gt;CSR |= 1&amp;lt;&amp;lt;2;            //允许入侵中断BKP-&amp;gt;CR  |= 1&amp;lt;&amp;lt;0;            //开启入侵检测</code></pre><p>}<br></p></pre><div>Library/inc/bkp.h</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<p></p><p>void Bkp_Init(void);</p><p>void Write_Bkp(u8 reg,u16 data);</p><p>u16 Read_Bkp(u8 reg);</p><p>void Tamper_Init(void);<br></p></pre></div></div></div><div> </div><div><strong>库函数操作</strong></div><div> </div><div>main.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”<p></p><p>#include “stdio.h”</p><p>#define     PRINTF_ON  1</p><p>#define  CHECK_CODE  0xAE86</p><p>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void NVIC_Configuration(void);<br>void USART_Configuration(void);<br>void BKP_Configuration(void);</p><p>void PrintBKP(void);<br>void WriteBKP(u16 Data,u8 DRNumber);<br>u8     CheckBKP(void);</p><p>int main(void)<br>{<br>      RCC_Configuration();<br>      GPIO_Configuration();<br>    NVIC_Configuration();<br>    USART_Configuration();<br>    BKP_Configuration();</p><pre><code>if(CheckBKP()){    printf(&quot;\r\n The datas are as their initial status. \r\n&quot;);    WriteBKP(0xA522,2);    PrintBKP();}else{    printf(&quot;\r\n The datas have been changed . \r\n&quot;);    WriteBKP(0xA53C,1);    PrintBKP();}  while(1);</code></pre><p>}</p><p>void GPIO_Configuration(void)<br>{<br>      GPIO_InitTypeDef GPIO_InitStructure;</p><pre><code>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;            GPIO_Init(GPIOA , &amp;amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;            GPIO_Init(GPIOA , &amp;amp;GPIO_InitStructure); </code></pre><p>}</p><p>void BKP_Configuration(void)<br>{<br>    PWR_BackupAccessCmd(ENABLE);<br>    BKP_ClearFlag();<br>    BKP_TamperPinLevelConfig(BKP_TamperPinLevel_Low);<br>    BKP_ITConfig(ENABLE);<br>    BKP_TamperPinCmd(ENABLE);<br>}</p><p>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;</p><pre><code>  /* 复位系统时钟设置*/  RCC_DeInit();  /* 开启HSE*/  RCC_HSEConfig(RCC_HSE_ON);  /* 等待HSE起振并稳定*/  HSEStartUpStatus = RCC_WaitForHSEStartUp();/* 判断HSE起是否振成功，是则进入if()内部 */  if(HSEStartUpStatus == SUCCESS)  {    /* 选择HCLK（AHB）时钟源为SYSCLK 1分频 */    RCC_HCLKConfig(RCC_SYSCLK_Div1);     /* 选择PCLK2时钟源为 HCLK（AHB） 1分频 */    RCC_PCLK2Config(RCC_HCLK_Div1);     /* 选择PCLK1时钟源为 HCLK（AHB） 2分频 */    RCC_PCLK1Config(RCC_HCLK_Div2);    /* 设置FLASH延时周期数为2 */    FLASH_SetLatency(FLASH_Latency_2);    /* 使能FLASH预取缓存 */    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);    /* 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz * 9 = 72MHz */    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);    /* 使能PLL */     RCC_PLLCmd(ENABLE);    /* 等待PLL输出稳定 */    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);    /* 选择SYSCLK时钟源为PLL */    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);    /* 等待PLL成为SYSCLK时钟源 */    while(RCC_GetSYSCLKSource() != 0x08);  }   /* 打开APB2总线上的GPIOA时钟*/  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE);RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP, ENABLE);</code></pre><p>}</p><p>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;</p><pre><code>USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;                                                                                                                                                      USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;USART_ClockInit(USART1 , &amp;amp;USART_ClockInitStructure);USART_InitStructure.USART_BaudRate = 9600;USART_InitStructure.USART_WordLength = USART_WordLength_8b;USART_InitStructure.USART_StopBits = USART_StopBits_1;USART_InitStructure.USART_Parity = USART_Parity_No;USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;USART_Init(USART1,&amp;amp;USART_InitStructure); USART_Cmd(USART1,ENABLE);</code></pre><p>}</p><p>void NVIC_Configuration(void)<br>{<br>    NVIC_InitTypeDef NVIC_InitStructure;</p><pre><code>NVIC_InitStructure.NVIC_IRQChannel = TAMPER_IRQn;NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;NVIC_Init(&amp;amp;NVIC_InitStructure);</code></pre><p>}</p><p>void WriteBKP(u16 Data,u8 DRNumber)          // 还可加入一些加密算法;DRNumber （1-9）<br>{<br>    switch(DRNumber)<br>    {<br>        case 0x01: BKP_WriteBackupRegister(BKP_DR1,Data); break;<br>        case 0x02: BKP_WriteBackupRegister(BKP_DR2,Data); break;<br>        case 0x03: BKP_WriteBackupRegister(BKP_DR3,Data); break;<br>        case 0x04: BKP_WriteBackupRegister(BKP_DR4,Data); break;<br>        case 0x05: BKP_WriteBackupRegister(BKP_DR5,Data); break;<br>        case 0x06: BKP_WriteBackupRegister(BKP_DR6,Data); break;<br>        case 0x07: BKP_WriteBackupRegister(BKP_DR7,Data); break;<br>        case 0x08: BKP_WriteBackupRegister(BKP_DR8,Data); break;<br>        case 0x09: BKP_WriteBackupRegister(BKP_DR9,Data); break;<br>        default:    BKP_WriteBackupRegister(BKP_DR1,Data);<br>    }<br>    BKP_WriteBackupRegister(BKP_DR10,CHECK_CODE);<br>}</p><p>u8 CheckBKP(void)<br>{<br>    if( BKP_ReadBackupRegister(BKP_DR10) == 0xAE86 )   // 如果此位数据丢失，则BPK数据丢失<br>        return 1;<br>    else<br>        return 0;<br>}</p><p>void PrintBKP(void)<br>{<br>    printf(“DR1 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR1));<br>    printf(“DR2 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR2));<br>    printf(“DR3 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR3));<br>    printf(“DR4 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR4));<br>    printf(“DR5 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR5));<br>    printf(“DR6 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR6));<br>    printf(“DR7 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR7));<br>    printf(“DR8 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR8));<br>    printf(“DR9 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR9));<br>    printf(“DR10 = 0x%04X\t”,BKP_ReadBackupRegister(BKP_DR10));</p><p>}</p><p>#if     PRINTF_ON</p><p>int fputc(int ch,FILE *f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}</p><p>#endif<br></p></pre><div> </div><div>stm12f10x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”<p></p><p>#include “stdio.h”</p><p>extern void PrintBKP(void);</p><p>void TAMPER_IRQHandler(void)<br>{<br>    printf(“\r\n A Tamper is coming .\r\n”);<br>    PrintBKP();<br>    BKP_ClearITPendingBit();<br>    BKP_ClearFlag();</p><p>}</p></pre></div></div><p></p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;BKP是“BACKUP”的缩写，stm32f103RCTE的内部配备了10个16位宽度的BKP寄存器。在主电源切断或系统产生复位时间时，BKP寄存器仍然可以在备用电源的支持下保持其内容。&amp;nbsp;&lt;/div&gt;&lt;div&gt;BKP在实际应用中可以存入重要数据，防止被恶意查看，或用于断电回复等。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;本例实现对BKP寄存器的读写操作，和入侵检测和处理。主程序中写入寄存器后，依次打印出10个BKP寄存器数据，然后触发GPIOC13的入侵中断（输入低电平），在中断中打印出入侵事件发生后的寄存器内容（复位为0 ）。&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;直接操作寄存器&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;用到的寄存器描述如下：&lt;/div&gt;&lt;div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;备份数据寄存器x(BKP_DRx) (x = 1 … 10)：&lt;/strong&gt;低16位[15:0]有效，用来写入或读出备份数据。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;备份控制寄存器(BKP_CR)：&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;低两位有效。&lt;/div&gt;&lt;div&gt;TPAL[1]：侵入检测TAMPER引脚有效电平(TAMPER pin active level)&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0：侵入检测TAMPER引脚上的高电平会清除所有数据备份寄存器(如果TPE位为1)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;1：侵入检测TAMPER引脚上的低电平会清除所有数据备份寄存器(如果TPE位为1)&lt;div&gt;TPE[0]：启动侵入检测TAMPER引脚(TAMPER pin enable)&lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;0：侵入检测TAMPER引脚作为通用IO口使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;1：开启侵入检测引脚作为侵入检测使用&lt;div&gt;&lt;strong&gt;备份控制/状态寄存器(BKP_CSR):&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/3972267929.png&quot; alt=&quot;BKP_CSR.png&quot;&gt;&lt;/div&gt;&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 低功耗设计[操作寄存器+库函数]</title>
    <link href="http://neil-pan.com/2012/07/05/stm32-%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1-%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/05/stm32-低功耗设计-操作寄存器-库函数/</id>
    <published>2012-07-05T13:45:34.000Z</published>
    <updated>2024-07-11T12:49:21.232Z</updated>
    
    <content type="html"><![CDATA[<div>stm32的低功耗模式有三种：</div><div> </div><ul><li>睡眠模式（内核停止，外设运行）</li><li>停机模式（所有时钟都停止）</li><li><p>待机模式（1.8V内核电源也关闭）<div> </div><div>在这三种模式中，最低功耗的是待机模式，在此模式下，最低只需要2uA左右的电流。整个1.8V供电区被断电，PLL、HSI、HSE振荡器都被关闭。SRAM和寄存器内容丢失。停机模式是次低功耗的的，其典型的电流损耗在20uA左右。最后就是睡眠模式。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>stm32低功耗一览表</div><div><img src="/uploads/2012/07/2007114394.png" alt="standby.png"></div><div> </div><div>这三种低功耗模式，唤醒后程序都会初始化运行。在例子中做了一番论证，结果如此。</div><div> </div><div><strong>直接操作寄存器</strong></div><div> </div><div><div>进入待机模式的通用步骤，其中涉及到2个寄存器，也就是电源控制寄存器（PWR_CR）和电源控制/状态寄存器（PWR_CSR）。</div><div> </div><div>电源控制寄存器（PWR_CR），该寄存器的各位描述如下：</div><div>这是一个低9位有效的寄存器。</div></div></p></li><li><p>DBP[8]：取消后备区域的写保护 位 8 在复位后，RTC和后备寄存器处于被保护状态以防意外写入。0：禁止写入RTC和后备寄存器 &nbsp;1：允许写入RTC和后备寄存器&nbsp;</p></li><li><p>PLS[ 7:5&nbsp;]：PVD电平选择。 这些位用于选择电源电压监测器的电压阀值。<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;000：2.2V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100：2.6V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;001：2.3V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 101：2.7V</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;010：2.4V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;110：2.8V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;011：2.5V &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;111：2.9V&nbsp;</div></p></li><li><p>PVDE[4]：电源电压监测器(PVD)使能。&nbsp;&nbsp;0：禁止PVD 1：开启PVD</p></li><li>CSBF[3]：清除待机位,始终读出为0。 0：无功效 &nbsp;1：清除SBF待机位(写)</li><li>CWUF[2]：清除唤醒位,始终读出为0。 0：无功效 1：2个系统时钟周期后清除WUF唤醒位(写)</li><li>PDDS[1]：掉电深睡眠,与LPDS位协同操作。 0：当CPU进入深睡眠时进入停机模式，调压器的状态由LPDS位控制。 1：CPU进入深睡眠时进入待机模式。</li><li>LPDS[0]：深睡眠下的低功耗。PDDS=0时，与PDDS位协同操作 0：在停机模式下电压调压器开启 1：在停机模式下电压调压器处于低功耗模式</li></ul><a id="more"></a><div><div>电源控制寄存器（PWR_CR），该寄存器的各位描述如下：</div><div>低9位有效的寄存器，只用了4位，其他位保留</div></div><ul><li>EWUP[8]：使能WKUP引脚 ，在系统复位时清除这一位。&nbsp;</li><li>PVDO[2]：PVD输出 ,当PVD被PVDE位使能后该位才有效。&nbsp;</li><li>SBF[1]：待机标志。</li><li>WUF[0]：唤醒标志。&nbsp;<div>待机函数实现：(参见 system.c文件)<p></p><pre class="brush:cpp;">//THUMB指令不支持汇编内联<br>//采用如下方法实现执行汇编指令WFI<br>__asm void WFI_SET(void)<br>{<br>WFI;<br>}</pre></div></li></ul><p>//进入待机模式<br>//参数说明：<br>//         var = 0 ,设定为睡眠模式<br>//       var = 1 ,设定为停机模式，电流消耗在20uA左右<br>//         var = 2 ,设定为待机模式，电流消耗在2uA左右</p><p>void Sys_Standby(u8 var)<br>{</p><pre><code>  RCC-&amp;gt;APB1ENR |= 1&amp;lt;&amp;lt;28;             //使能电源时钟        switch(var){     case 0:{ break;    }            //WFI进入睡眠模式    case 1:{                     //PDDS+LPDS+SLEEPDEEP+WFI进入停机模式        SCB-&amp;gt;SCR |= 1&amp;lt;&amp;lt;2;        //使能SLEEPDEEP位 (SYS-&amp;gt;CTRL)                    PWR-&amp;gt;CR    |= 1&amp;lt;&amp;lt;0;        //LPDS置位            PWR-&amp;gt;CR |= 1&amp;lt;&amp;lt;1;        //PDDS置位            break;                }     case 2:{                     //PDDS+SLEEPDEEP+WFI进入待机模式        SCB-&amp;gt;SCR |= 1&amp;lt;&amp;lt;2;        //使能SLEEPDEEP位 (SYS-&amp;gt;CTRL)        PWR-&amp;gt;CR|=1&amp;lt;&amp;lt;1;          //PDDS置位            break;                } }PWR-&amp;gt;CR  |= 1&amp;lt;&amp;lt;2;                  //清除Wake-up 标志PWR-&amp;gt;CSR |= 1&amp;lt;&amp;lt;8;                  //允许写入RTC和BKP寄存器WFI_SET();                         //执行WFI指令         </code></pre><p>}    </p><p>//系统软复位</p><p>void Sys_Soft_Reset(void)<br>{<br>    SCB-&gt;AIRCR =0X05FA0000|(u32)0x04;<br>} <div>代码如下：<span style="text-align: left; ">（system.h 和&nbsp;</span><span style="text-align: left; ">stm32f10x_it.h</span><span style="text-align: left; ">&nbsp;等相关代码参照&nbsp;</span><a href="http://www.ichanging.org/mdk-stm32Register-set.html" target="_blank" rel="noopener">stm32 直接操作寄存器开发环境配置</a><span style="text-align: left; ">）</span></div><div>User/main.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;    </pre></div></p><p>#include “system.h”     </p><p>#include “wdg.h” </p><p>#include “exti.h” </p><p>#define LED1 PAout(4)</p><p>#define LED2 PAout(5)</p><p>#define PWR_MODE_Sleep         0       //开启睡眠模式</p><p>#define PWR_MODE_STOP       1           //开启停机模式</p><p>#define PWR_MODE_STANDBY     0        //开启待机模式</p><p>void Gpio_Init(void);</p><p>int main(void)<br>{<br>    u32 i= 10,j=10;</p><pre><code>Rcc_Init(9);              //系统时钟设置 Exti_Init(GPIO_A,0,FTIR);  //设置PA1为下降沿触发,参数GPIO_x 和 FTIR 在system.h中有定义Nvic_Init(0,0,EXTI0_IRQChannel,0);      //设置外部中断Gpio_Init();while(i--){    LED1 = !LED1;    delay(30000);   //延时30ms}#if PWR_MODE_Sleep            //睡眠模式,外部中断唤醒后会复位    Sys_Standby(0);           #elif PWR_MODE_STOP           //停机模式，外部中断唤醒，唤醒后复位                             Sys_Standby(1);#elif PWR_MODE_STANDBY         //待机模式，由独立看门狗唤醒，唤醒后会初始化,LED闪烁5次后，暗一段时间    Iwdg_Init(3,2000);      //设置为1.6s内不喂狗复位，使用独立看门狗唤醒，唤醒后复位    Sys_Standby(2);  #endifwhile(j--){                    //这段程序用于检验唤醒后是否会继续运行后面的程序，还是会导致复位    LED2 = !LED2;    delay(10000);   //延时10ms}        </code></pre><p>}</p><p>void Gpio_Init(void)<br>{<br>    RCC-&gt;APB2ENR|=1&lt;&lt;2;    //使能PORTA时钟     </p><pre><code>GPIOA-&amp;gt;CRL&amp;amp;=0x0000FFFF; // PA0~3设置为浮空输入，PA4~7设置为推挽输出GPIOA-&amp;gt;CRL|=0x33334444; </code></pre><p>}<br><div>User/stm32f10x_it.c</div><div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”</pre></div></div></p><p>#include “system.h”</p><p>#define LED1 PAout(4)</p><p>#define LED2 PAout(5)</p><p>#define LED3 PAout(6)</p><p>#define LED4 PAout(7)</p><p>void EXTI0_IRQHandler(void)<br>{<br>       LED4 = !LED4;<br>    EXTI-&gt;PR = 1&lt;&lt;0;    //清除中断标志位<br>}<br></p><p>待机相关代码参见 system.c文件中<div> </div><div><strong>库函数操作</strong></div><div> </div><div>main.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”</pre></div></p><p>#include “stdio.h”</p><p>#define     PRINTF_ON  1</p><p>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void NVIC_Configuration(void);<br>void EXTI_Configuration(void);<br>void IWDG_Configuration(void);</p><p>#define PWR_MODE_Sleep 0    //开启睡眠模式</p><p>#define PWR_MODE_DeepSleep 1    //开启停机模式</p><p>#define PWR_MODE_STANDBY 0    //开启待机模式</p><p>vu32 DelayTime = 10000000;</p><p>int main(void)<br>{<br>      RCC_Configuration();<br>      GPIO_Configuration();<br>    NVIC_Configuration();<br>    EXTI_Configuration();</p><pre><code>SysTick_Config(10000000);while(--DelayTime);#if PWR_MODE_Sleep      //睡眠模式    PWR_EnterSTOPMode(PWR_Regulator_ON,PWR_STOPEntry_WFI);  //唤醒后时钟变为内置8MHz   #elif PWR_MODE_DeepSleep      //停机模式    PWR_EnterSTOPMode(PWR_Regulator_LowPower,PWR_STOPEntry_WFI);   //唤醒后时钟变为内置8MHz   #elif PWR_MODE_STANDBY         //待机模式       IWDG_Configuration();      //设置为2s内不喂狗复位，使用独立看门狗唤醒     PWR_EnterSTANDBYMode();     //唤醒后会初始化程序                             #endif  while(1);</code></pre><p>}</p><p>void IWDG_Configuration(void)<br>{<br>     RCC_LSICmd(ENABLE);                              //打开LSI<br>    while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY)==RESET);</p><pre><code>IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);IWDG_SetPrescaler(IWDG_Prescaler_32);IWDG_SetReload(2000);      //max 0xFFF  0~4095  IWDG_ReloadCounter();IWDG_Enable();</code></pre><p>}</p><p>void GPIO_Configuration(void)<br>{<br>      GPIO_InitTypeDef GPIO_InitStructure;<br>      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_7;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure);</p><pre><code>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;            GPIO_Init(GPIOA , &amp;amp;GPIO_InitStructure);GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;            GPIO_Init(GPIOA , &amp;amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;            GPIO_Init(GPIOA , &amp;amp;GPIO_InitStructure);  GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0);</code></pre><p>}</p><p>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;</p><pre><code>  /* 复位系统时钟设置*/  RCC_DeInit();  /* 开启HSE*/  RCC_HSEConfig(RCC_HSE_ON);  /* 等待HSE起振并稳定*/  HSEStartUpStatus = RCC_WaitForHSEStartUp();/* 判断HSE起是否振成功，是则进入if()内部 */  if(HSEStartUpStatus == SUCCESS)  {    /* 选择HCLK（AHB）时钟源为SYSCLK 1分频 */    RCC_HCLKConfig(RCC_SYSCLK_Div1);     /* 选择PCLK2时钟源为 HCLK（AHB） 1分频 */    RCC_PCLK2Config(RCC_HCLK_Div1);     /* 选择PCLK1时钟源为 HCLK（AHB） 2分频 */    RCC_PCLK1Config(RCC_HCLK_Div2);    /* 设置FLASH延时周期数为2 */    FLASH_SetLatency(FLASH_Latency_2);    /* 使能FLASH预取缓存 */    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);    /* 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz * 9 = 72MHz */    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);    /* 使能PLL */     RCC_PLLCmd(ENABLE);    /* 等待PLL输出稳定 */    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);    /* 选择SYSCLK时钟源为PLL */    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);    /* 等待PLL成为SYSCLK时钟源 */    while(RCC_GetSYSCLKSource() != 0x08);  }   /* 打开APB2总线上的GPIOA时钟*/  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE);//RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE);//RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP|RCC_APB1Periph_WWDG, ENABLE);</code></pre><p>}</p><p>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;</p><pre><code>USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;                                                                                                                                                      USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;USART_ClockInit(USART1 , &amp;amp;USART_ClockInitStructure);USART_InitStructure.USART_BaudRate = 9600;USART_InitStructure.USART_WordLength = USART_WordLength_8b;USART_InitStructure.USART_StopBits = USART_StopBits_1;USART_InitStructure.USART_Parity = USART_Parity_No;USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;USART_Init(USART1,&amp;amp;USART_InitStructure); USART_Cmd(USART1,ENABLE);</code></pre><p>}</p><p>void EXTI_Configuration(void)<br>{<br>    EXTI_InitTypeDef EXTI_InitStructure;</p><pre><code>EXTI_InitStructure.EXTI_Line = EXTI_Line0;EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;EXTI_InitStructure.EXTI_LineCmd = ENABLE;EXTI_Init(&amp;amp;EXTI_InitStructure);</code></pre><p>}</p><p>void NVIC_Configuration(void)<br>{<br>    NVIC_InitTypeDef NVIC_InitStructure;</p><pre><code>NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;NVIC_Init(&amp;amp;NVIC_InitStructure);</code></pre><p>}</p><p>#if     PRINTF_ON</p><p>int fputc(int ch,FILE *f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}</p><p>#endif<br><div>stm32f10x_it.c</div><div><pre class="brush:cpp;">#include “stm32f10x_it.h”</pre></div></p><p>#include “stdio.h”</p><p>void EXTI0_IRQHandler(void)<br>{<br>    GPIO_WriteBit(GPIOA,GPIO_Pin_7,Bit_SET);</p><pre><code>//EXTI_ClearFlag(EXTI_Line0);   //清除此中断标志位，系统由于唤醒将直接复位</code></pre><p>}</p><p>void SysTick_Handler(void)<br>{<br>   GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)(1-GPIO_ReadOutputDataBit(GPIOA,GPIO_Pin_4)));<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;stm32的低功耗模式有三种：&lt;/div&gt;&lt;div&gt; &lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;睡眠模式（内核停止，外设运行）&lt;/li&gt;
&lt;li&gt;停机模式（所有时钟都停止）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;待机模式（1.8V内核电源也关闭）&lt;div&gt; &lt;/div&gt;&lt;div&gt;在这三种模式中，最低功耗的是待机模式，在此模式下，最低只需要2uA左右的电流。整个1.8V供电区被断电，PLL、HSI、HSE振荡器都被关闭。SRAM和寄存器内容丢失。停机模式是次低功耗的的，其典型的电流损耗在20uA左右。最后就是睡眠模式。&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/div&gt;&lt;div&gt;stm32低功耗一览表&lt;/div&gt;&lt;div&gt;&lt;img src=&quot;/uploads/2012/07/2007114394.png&quot; alt=&quot;standby.png&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;这三种低功耗模式，唤醒后程序都会初始化运行。在例子中做了一番论证，结果如此。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;strong&gt;直接操作寄存器&lt;/strong&gt;&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;进入待机模式的通用步骤，其中涉及到2个寄存器，也就是电源控制寄存器（PWR_CR）和电源控制/状态寄存器（PWR_CSR）。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;电源控制寄存器（PWR_CR），该寄存器的各位描述如下：&lt;/div&gt;&lt;div&gt;这是一个低9位有效的寄存器。&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DBP[8]：取消后备区域的写保护 位 8 在复位后，RTC和后备寄存器处于被保护状态以防意外写入。0：禁止写入RTC和后备寄存器 &amp;nbsp;1：允许写入RTC和后备寄存器&amp;nbsp;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PLS[ 7:5&amp;nbsp;]：PVD电平选择。 这些位用于选择电源电压监测器的电压阀值。&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;000：2.2V &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;100：2.6V &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;001：2.3V&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 101：2.7V&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;010：2.4V &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;110：2.8V &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;011：2.5V &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;111：2.9V&amp;nbsp;&lt;/div&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PVDE[4]：电源电压监测器(PVD)使能。&amp;nbsp;&amp;nbsp;0：禁止PVD 1：开启PVD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;CSBF[3]：清除待机位,始终读出为0。 0：无功效 &amp;nbsp;1：清除SBF待机位(写)&lt;/li&gt;
&lt;li&gt;CWUF[2]：清除唤醒位,始终读出为0。 0：无功效 1：2个系统时钟周期后清除WUF唤醒位(写)&lt;/li&gt;
&lt;li&gt;PDDS[1]：掉电深睡眠,与LPDS位协同操作。 0：当CPU进入深睡眠时进入停机模式，调压器的状态由LPDS位控制。 1：CPU进入深睡眠时进入待机模式。&lt;/li&gt;
&lt;li&gt;LPDS[0]：深睡眠下的低功耗。PDDS=0时，与PDDS位协同操作 0：在停机模式下电压调压器开启 1：在停机模式下电压调压器处于低功耗模式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>stm32 AD模数转换[操作寄存器+库函数]</title>
    <link href="http://neil-pan.com/2012/07/05/stm32-AD%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2-%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://neil-pan.com/2012/07/05/stm32-AD模数转换-操作寄存器-库函数/</id>
    <published>2012-07-05T05:31:39.000Z</published>
    <updated>2024-07-11T12:49:21.213Z</updated>
    
    <content type="html"><![CDATA[<div>stm32f103最少有2个AD模数转换器，每个ADC都有18个通道，可以测量16个外部和2个内部模拟量。最大转换频率为1Mhz，也就是转换时间为1us（在 ADCCLK = 14Mhz,采样周期为1.5个时钟周期时）。最大时钟超过14Mhz，将导致ADC转换准确度降低。stm32的ADC是12位精度的。</div><div> </div><div>stm32的ADC转换有两种通道，规则通道和注入通道，注入通道可以抢占式地打断规则通道的采样，执行注入通道采样后，再执行之前的规则通道采样，和中断类似。本例只使用规则通道实现独立模式的中断采样，这里不再赘述两种通道区别。</div><div> </div><div>stm32的ADC可以由外部事件触发(例如定时器捕获，EXTI线)和软件触发(即在配置相关寄存器时，直接开启采样）。</div><div> </div><div><div><strong><br>        本例实现AD采样PB0口，使用串口输出PB0口电压值。PB0口接变阻器以改变调整电压。</strong></div><div>效果如下：</div><div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADValue = 1.39v</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADValue = 1.38v</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADValue = 1.40v</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADValue = 1.38v</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADValue = 1.39v</div><div> </div><p><a id="more"></a></p></div></div><div><strong>直接操作寄存器</strong></div><div> </div><div>首先需要配置ADC的时钟分频值，在RCC-&gt;CFGR的[15:14]位：</div><ul><li>00：PCLK2 2分频后作为ADC时钟 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01：PCLK2 4分频后作为ADC时钟</li><li><p>10：PCLK2 6分频后作为ADC时钟 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11：PCLK2 8分频后作为ADC时钟<div>设定各通道的采样时间ADCx-&gt;SMPR,该寄存器给每个通道3位来选择8种采样周期：</div></p></li><li><p>000：1.5周期 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 100：41.5周期</p></li><li>001：7.5周期 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 101：55.5周期</li><li>010：13.5周期 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 110：71.5周期</li><li>011：28.5周期 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;111：239.5周期<div>采样时间算法为:&nbsp;(采样周期+12.5)/分频后的时钟</div><div> </div><div>ADC采样得到的只是一个相对值，将 转换值/4096*参考电压 即可得到采样电压 这里的4096是因为stm32的adc为12位精度，表示参考电压时即为 2^12=4096</div><div> </div><div>代码如下： &nbsp;<span style="text-align: left; ">（system.h 和&nbsp;</span><span style="text-align: left; ">stm32f10x_it.h</span><span style="text-align: left; ">&nbsp;等相关代码参照&nbsp;</span><a href="http://www.ichanging.org/mdk-stm32Register-set.html" target="_blank" rel="noopener">stm32 直接操作寄存器开发环境配置</a><span style="text-align: left; ">）</span></div><div>User/main.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;<br>#include “system.h”<br>#include “usart.h”<br>#include “adc.h”<br>#include “stdio.h”    </pre></div></li></ul><p>#define LED1 PAout(4)</p><p>#define LED2 PAout(5)</p><p>#define VREF 3.3         //参考电压<br>void Gpio_Init(void);</p><p>int main(void)<br>{<br>    u16 ADValue;<br>    float temp;</p><pre><code>Rcc_Init(9);              //系统时钟设置Usart1_Init(72,9600);    //设置串口时钟和波特率Adc1_Init(8,7);      //使用8通道采样，采样时间系数为7（111），据手册可得采样时间为 (239.5+12.5)/12= 21 (us)Gpio_Init();while(1){    ADValue = Get_Adc(ADC_1,8);    temp = (float)VREF*(ADValue/4096);       //ADC精度为12位精度，即达到 VREF电压时为 2^12 = 4096    printf(&quot;\r\n ADValue = %.2fv\r\n&quot;,temp);    LED2 = !LED2;    delay(100000);   //延时100ms}        </code></pre><p>}</p><p>void Gpio_Init(void)<br>{<br>    RCC-&gt;APB2ENR|=1&lt;&lt;2;    //使能PORTA时钟<br>    RCC-&gt;APB2ENR|=1&lt;&lt;3;    //使能PORTB时钟     </p><pre><code>GPIOA-&amp;gt;CRL&amp;amp;=0xFF0FFFF0; GPIOA-&amp;gt;CRL|=0xFF3FFFF0; // PA0设置为模拟输入,PA4推挽输出GPIOB-&amp;gt;CRL&amp;amp;=0xFFFFFFF0; GPIOB-&amp;gt;CRL|=0xFFFFFFF0; // PB0设置为模拟输入//USART1 串口I/O设置GPIOA -&amp;gt; CRH&amp;amp;=0xFFFFF00F;   //设置USART1 的Tx(PA.9)为第二功能推挽，50MHz；Rx(PA.10)为浮空输入GPIOA -&amp;gt; CRH|=0x000008B0;      </code></pre><p>}<br><div>Library/src/adc.c</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;         </pre></div></p><p>#include “adc.h”</p><p>//ADC1采样初始化<br>//独立工作模式<br>//参数说明：<br>//            ADC_CH_x    选择使用通道（0~17)，目前暂支持0~15通道<br>//            ADC_CH_SMP     设定采样周期（0~7）<br>//采样周期算法：</p><p>void Adc1_Init(u8 ADC_CH_x,u8 ADC_CH_SMP)<br>{<br>    RCC -&gt; APB2ENR |= 1&lt;&lt;9;           //开启ADC1时钟<br>    RCC -&gt; APB2RSTR |= 1&lt;&lt;9;          //复位ADC1<br>    RCC -&gt; APB2RSTR &amp;= ~(1&lt;&lt;9);      //ADC1复位结束</p><pre><code>RCC -&amp;gt; CFGR &amp;amp;= ~(3&amp;lt;&amp;lt;14);        //分频因子清零RCC -&amp;gt; CFGR |= 2&amp;lt;&amp;lt;14;            //设定分频因数为2,PCLK2 6分频后作为ADC时钟ADC1 -&amp;gt; CR1 &amp;amp;= 0xF0FFFF;        //工作模式清零ADC1 -&amp;gt;    CR1 |= 0&amp;lt;&amp;lt;16;            //设定为独立模式ADC1 -&amp;gt; CR1 &amp;amp;= ~(1&amp;lt;&amp;lt;8);            //非扫描工作模式ADC1 -&amp;gt; CR2 &amp;amp;= ~(1&amp;lt;&amp;lt;1);            //关闭连续转换ADC1 -&amp;gt; CR2 &amp;amp;= ~(7&amp;lt;&amp;lt;17);        //清除规则通道启动事件ADC1 -&amp;gt; CR2 |= 7&amp;lt;&amp;lt;17;            //设定规则通道启动事件为软件启动（SWSTART）ADC1 -&amp;gt; CR2 |= 1&amp;lt;&amp;lt;20;            //使用外部事件触发 SWSTARTADC1 -&amp;gt; CR2 &amp;amp;= ~(1&amp;lt;&amp;lt;11);        //设置对齐模式为右对齐ADC1 -&amp;gt; SQR1 &amp;amp;= ~(0xF&amp;lt;&amp;lt;20);        //清零规则序列的数量ADC1 -&amp;gt; SQR1 |= 15&amp;lt;&amp;lt;20;            //设置规则序列的数量为16ADC1 -&amp;gt; SMPR2 &amp;amp;= 0x00000000;    //清零通道采样时间ADC1 -&amp;gt; SMPR1 &amp;amp;= 0xFF000000;    if(ADC_CH_x &amp;lt;= 9 ){    ADC1 -&amp;gt; SMPR2 |= 7&amp;lt;&amp;lt;(ADC_CH_x*3);            //设置通道x采样时间，提高采样时间可以提高采样精度 }if(ADC_CH_x &amp;gt; 9 ){    ADC1 -&amp;gt; SMPR1 |= 7&amp;lt;&amp;lt;((ADC_CH_x-10)*3);        }ADC1 -&amp;gt; CR2 |= 1&amp;lt;&amp;lt;0;            //开启AD转换ADC1 -&amp;gt; CR2 |= 1&amp;lt;&amp;lt;3;            //使能复位校准，由硬件清零while((ADC1 -&amp;gt; CR2)&amp;amp; (1&amp;lt;&amp;lt;3));    //等待校准结束ADC1 -&amp;gt; CR2 |= 1&amp;lt;&amp;lt;2;            //开启AD校准，由硬件清零while((ADC1 -&amp;gt; CR2)&amp;amp; (1&amp;lt;&amp;lt;2));    //等待校准结束</code></pre><p>}</p><p>//取得数模转换的值<br>//参数说明：（参数定义于adc.h）<br>//         ADC_x  （0~3）,选择数模转换器<br>//         ADC_CH_x    (0~15),选择通道<br>u16 Get_Adc(u8 ADC_x,u8 ADC_CH_x)<br>{<br>    u16 data = 0;</p><pre><code>switch(ADC_x)    {    case 1 : {        ADC1 -&amp;gt; SQR3 &amp;amp;= 0xFFFFFFE0;              //清除通道选择        ADC1 -&amp;gt; SQR3 |= ADC_CH_x;                //选择通道        ADC1 -&amp;gt; CR2  |= 1&amp;lt;&amp;lt;22;                //开启AD转换        while(!(ADC1 -&amp;gt; SR &amp;amp; 1&amp;lt;&amp;lt;1));            //等待转换结束        data = ADC1-&amp;gt;DR;        break;    }    case 2 : {break;}    case 3 : {break;}}return data;</code></pre><p>}<br><div>Library/inc/adc.h</div><div><pre class="brush:cpp;">#include &lt;stm32f10x_lib.h&gt;    </pre></div></p><p>#define  ADC_1 0x01</p><p>#define  ADC_2 0x02</p><p>#define  ADC_3 0x03</p><p>void Adc1_Init(u8 ADC_CH_x,u8 ADC_CH_SMP);<br>u16 Get_Adc(u8 ADC_x,u8 ADC_CH_x);<br><div> </div><div> </div><div><strong>库函数操作</strong></div><div> </div><div>main.c</div><div><pre class="brush:cpp;">#include “stm32f10x.h”</pre></div></p><p>#include “stdio.h”</p><p>#define     PRINTF_ON  1</p><p>#define  VREF       3.3        // 参考电压</p><p>void RCC_Configuration(void);<br>void GPIO_Configuration(void);<br>void USART_Configuration(void);<br>void ADC_Configuration(void);</p><p>int main(void)<br>{<br>    float ADValue = 0.00;<br>    u32 delayTime = 0;</p><pre><code>  RCC_Configuration();  GPIO_Configuration();USART_Configuration();ADC_Configuration();while(1){    if(delayTime++ &amp;gt;=2000000)    {        delayTime = 0;        ADValue = VREF*ADC_GetConversionValue(ADC1)/0x0fff;        printf(&quot;\r\n ADValue = %.2fv\r\n&quot;,ADValue);    }}</code></pre><p>}</p><p>void GPIO_Configuration(void)<br>{<br>      GPIO_InitTypeDef GPIO_InitStructure;<br>      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 ;<br>      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;<br>      GPIO_Init(GPIOA , &amp;GPIO_InitStructure); </p><pre><code>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;            GPIO_Init(GPIOA , &amp;amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;            GPIO_Init(GPIOA , &amp;amp;GPIO_InitStructure); </code></pre><p>}</p><p>void ADC_Configuration(void)<br>{<br>    ADC_InitTypeDef ADC_InitStructure;    </p><pre><code>RCC_ADCCLKConfig(RCC_PCLK2_Div4);    //配置ADC时钟分频ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;ADC_InitStructure.ADC_ScanConvMode = ENABLE;ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;ADC_InitStructure.ADC_NbrOfChannel = 1;ADC_Init(ADC1,&amp;amp;ADC_InitStructure);ADC_RegularChannelConfig(ADC1,ADC_Channel_8,1,ADC_SampleTime_55Cycles5);ADC_Cmd(ADC1,ENABLE);ADC_ResetCalibration(ADC1);while(ADC_GetResetCalibrationStatus(ADC1));ADC_StartCalibration(ADC1);while(ADC_GetCalibrationStatus(ADC1));ADC_SoftwareStartConvCmd(ADC1,ENABLE);</code></pre><p>}</p><p>void RCC_Configuration(void)<br>{<br>    /<em> 定义枚举类型变量 HSEStartUpStatus </em>/<br>    ErrorStatus HSEStartUpStatus;</p><pre><code>  /* 复位系统时钟设置*/  RCC_DeInit();  /* 开启HSE*/  RCC_HSEConfig(RCC_HSE_ON);  /* 等待HSE起振并稳定*/  HSEStartUpStatus = RCC_WaitForHSEStartUp();/* 判断HSE起是否振成功，是则进入if()内部 */  if(HSEStartUpStatus == SUCCESS)  {    /* 选择HCLK（AHB）时钟源为SYSCLK 1分频 */    RCC_HCLKConfig(RCC_SYSCLK_Div1);     /* 选择PCLK2时钟源为 HCLK（AHB） 1分频 */    RCC_PCLK2Config(RCC_HCLK_Div1);     /* 选择PCLK1时钟源为 HCLK（AHB） 2分频 */    RCC_PCLK1Config(RCC_HCLK_Div2);    /* 设置FLASH延时周期数为2 */    FLASH_SetLatency(FLASH_Latency_2);    /* 使能FLASH预取缓存 */    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);    /* 选择锁相环（PLL）时钟源为HSE 1分频，倍频数为9，则PLL输出频率为 8MHz * 9 = 72MHz */    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);    /* 使能PLL */     RCC_PLLCmd(ENABLE);    /* 等待PLL输出稳定 */    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);    /* 选择SYSCLK时钟源为PLL */    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);    /* 等待PLL成为SYSCLK时钟源 */    while(RCC_GetSYSCLKSource() != 0x08);  }   /* 打开APB2总线上的GPIOA时钟*/  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOB|RCC_APB2Periph_ADC1, ENABLE);//RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 , ENABLE);</code></pre><p>}</p><p>void USART_Configuration(void)<br>{<br>    USART_InitTypeDef USART_InitStructure;<br>    USART_ClockInitTypeDef USART_ClockInitStructure;</p><pre><code>USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;                                                                                                                                                      USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;USART_ClockInit(USART1 , &amp;amp;USART_ClockInitStructure);USART_InitStructure.USART_BaudRate = 9600;USART_InitStructure.USART_WordLength = USART_WordLength_8b;USART_InitStructure.USART_StopBits = USART_StopBits_1;USART_InitStructure.USART_Parity = USART_Parity_No;USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;USART_Init(USART1,&amp;amp;USART_InitStructure); USART_Cmd(USART1,ENABLE);</code></pre><p>}</p><p>#if     PRINTF_ON</p><p>int fputc(int ch,FILE *f)<br>{<br>    USART_SendData(USART1,(u8) ch);<br>    while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);<br>    return ch;<br>}</p><p>#endif</p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;stm32f103最少有2个AD模数转换器，每个ADC都有18个通道，可以测量16个外部和2个内部模拟量。最大转换频率为1Mhz，也就是转换时间为1us（在 ADCCLK = 14Mhz,采样周期为1.5个时钟周期时）。最大时钟超过14Mhz，将导致ADC转换准确度降低。stm32的ADC是12位精度的。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;stm32的ADC转换有两种通道，规则通道和注入通道，注入通道可以抢占式地打断规则通道的采样，执行注入通道采样后，再执行之前的规则通道采样，和中断类似。本例只使用规则通道实现独立模式的中断采样，这里不再赘述两种通道区别。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;stm32的ADC可以由外部事件触发(例如定时器捕获，EXTI线)和软件触发(即在配置相关寄存器时，直接开启采样）。&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;div&gt;&lt;strong&gt;&lt;br&gt;        本例实现AD采样PB0口，使用串口输出PB0口电压值。PB0口接变阻器以改变调整电压。&lt;/strong&gt;&lt;/div&gt;&lt;div&gt;效果如下：&lt;/div&gt;&lt;div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ADValue = 1.39v&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ADValue = 1.38v&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ADValue = 1.40v&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ADValue = 1.38v&lt;/div&gt;&lt;div&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ADValue = 1.39v&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
